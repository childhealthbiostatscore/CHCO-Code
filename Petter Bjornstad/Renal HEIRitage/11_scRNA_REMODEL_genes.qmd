---
title: "11_scRNA REMODEL Genes"
author: "Ye Ji Choi"
format: html
---

```{r}
library(dplyr)
library(aws.s3)
library(jsonlite)
library(ggplot2)
library(ggforce)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(msigdbr)
library(ggpubr)
library(ggrepel)
library(RColorBrewer)
library(ggtrace)
library(ggtext)
library(nebula)
```

```{r}
user <- Sys.info()[["user"]]

if (user == "choiyej") { # local version
  root_path <- "/Users/choiyej/Library/CloudStorage/OneDrive-UW/Bjornstad/Biostatistics Core Shared Drive"
  git_path <- "/Users/choiyej/GitHub/CHCO-Code/Petter Bjornstad"
  keys <- fromJSON("/Users/choiyej/Library/CloudStorage/OneDrive-TheUniversityofColoradoDenver/Bjornstad Pyle Lab/keys.json")
} else if (user == "rameshsh") { # hyak version
  root_path <- ""
  git_path <- "/mmfs1/gscratch/togo/rameshsh/CHCO-Code/Petter Bjornstad"
} else if (user == "yejichoi") { # hyak version
  root_path <- "/mmfs1/gscratch/togo/yejichoi/"
  git_path <- "/mmfs1/gscratch/togo/yejichoi/CHCO-Code/Petter Bjornstad"
  keys <- fromJSON("/mmfs1/home/yejichoi/keys.json")
} else if (user == "pylell") {
  root_path <- "/Users/pylell/Library/CloudStorage/OneDrive-SharedLibraries-UW/Bjornstad/Biostatistics Core Shared Drive"
  git_path <- "/Users/pylell/Documents/GitHub/CHCO-Code/Petter Bjornstad"
  keys <- fromJSON("/mmfs1/home/pylell/keys.json")
} else {
  stop("Unknown user: please specify root path for this user.")
}

source(file.path(git_path, "Renal HEIRitage/RH_RH2_IMPROVE_functions.R"))
source(file.path(git_path, "Renal HEIRitage/RH_RH2_IMPROVE_scRNA_functions.R"))

entrez_map <- AnnotationDbi::select(
 org.Hs.eg.db,
 keys   = keys(org.Hs.eg.db, keytype = "ENTREZID"),
 columns = c("SYMBOL", "GENENAME", "ALIAS"),
 keytype = "ENTREZID"
)


s3write_using_region <- function(FUN, ..., object, bucket, region = NULL, opts = NULL, filename = NULL) {
  if (missing(bucket)) {
    bucket <- get_bucketname(object)
  }
  object <- get_objectkey(object)
  
  tmp <- if (is.character(filename)) {
    file.path(tempdir(TRUE), filename)
  } else {
    # if object has an extension, keep it; otherwise make a generic tmp
    ext <- tools::file_ext(object)
    if (nzchar(ext)) tempfile(fileext = paste0(".", ext)) else tempfile()
  }
  
  on.exit(unlink(tmp), add = TRUE)
  
  # Add region to opts if provided
  if (!is.null(region)) {
    if (is.null(opts)) {
      opts <- list(region = region)
    } else {
      opts$region <- region
    }
  }
  
  FUN(tmp, ...)
  
  if (is.null(opts)) {
    r <- put_object(file = tmp, bucket = bucket, object = object)
  } else {
    r <- do.call("put_object", c(list(file = tmp, bucket = bucket, object = object), opts))
  }
  
  return(invisible(r))
}

pb90_subset <- s3readRDS("data_clean/subset/pb90_ckd_analysis_subset.rds", "scrna", region = "")
pb90_subset <- subset(pb90_subset, group != "Obese_Control")
```

```{r}
celltype_groups <- list(
  PT = c("PT-S1/S2", "PT-S3", "aPT"),
  TAL = c("C-TAL-1", "C-TAL-2", "aTAL", "dTAL"),
  PC = c("CCD-PC", "CNT-PC", "dCCD-PC", "M-PC", "tPC-IC"),
  IC = c("IC-A", "IC-B", "aIC"),
  DTL_ATL = c("DTL", "aDTL", "ATL"),   # grouped thin limbs
  DCT_CNT = c("DCT", "dDCT", "CNT"),   # grouped distal tubule/connecting tubule
  EC = c("EC-AVR", "EC-GC", "EC-PTC", "EC-AEA", "EC-LYM", "EC/VSMC", "EC-A"), 
  # Immune = c("MAC", "MON", "cDC", "pDC", "CD4+ T", "CD8+ T", "B", "NK", "cycT"),
  Immune_Myeloid = c("MAC", "MON", "cDC", "pDC"),
  Immune_Lymphoid = c("CD4+ T", "CD8+ T", "B", "NK", "cycT"),
  VSMC_P_FIB = c("VSMC/P", "FIB"),
  POD = "POD",
  MC = "MC",                         # mesangial cells
  PEC = "PEC",                       # parietal epithelial cells
  Schwann = "SchwannCells",
  Other = c("non-specific")          # catchall
)

remodel_genes <- c("LMF1", "LSAMP", "EMC10", "KCNK6", "FAT1", "NES", "MAPKAPK3", "FLT4", "CASR", "IRF3", "ACER1", "ACSM2B", "GLS", "CA12")
```

```{r}
# extract each gene expression for UMAP
expr_df <- NULL
for (gene in remodel_genes) {
  expr_vec <- Seurat::FetchData(pb90_subset, vars = gene)[, 1]
  expr_df <- cbind(expr_df, expr_vec)
}
expr_df <- as.data.frame(expr_df)
colnames(expr_df) <- remodel_genes

# Custom FeaturePlot UMAPs
umap_colors <- colorRampPalette(brewer.pal(12, "Set3"))(43)

celltype_colors <- setNames(umap_colors, levels(pb90_subset$KPMP_celltype))
# Read Seurat object and run UMAP, obtain cell numbers, etc
pb90_subset_meta <- pb90_subset@meta.data %>%
  cbind(pb90_subset@reductions$umap.harmony@cell.embeddings) %>%
  cbind(expr_df)

centers <- pb90_subset_meta %>%
  group_by(KPMP_celltype) %>%
  summarise(x = median(umapharmony_1),
            y = median(umapharmony_2), .groups = "drop")

for (gene in remodel_genes) {
  feature_p <- pb90_subset_meta %>%
    dplyr::mutate(feature_color_logic = case_when(
      .data[[gene]] > 0 ~ KPMP_celltype,
      T ~ "No")) %>%
    ggplot(aes(x = umapharmony_1, y = umapharmony_2, color = feature_color_logic)) +
    geom_point(alpha = 0.4) +
    geom_text_repel(data = centers,
                    aes(x = x, y = y, label = KPMP_celltype),
                    inherit.aes = FALSE,
                    size = 4, fontface = "bold", color = "black",
                    max.overlaps = Inf) +
    scale_color_manual(values = c(celltype_colors, "No" = "#edede9")) +
    theme_minimal() + 
    theme(panel.grid = element_blank(),
          text = element_text(size = 15),
          # legend.position = "none",
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_text(hjust = 0),   # move x label to left
          axis.title.y = element_text(hjust = 0))  + # push y label down to bottom) 
    labs(x = "UMAP1", y = "UMAP2", title = gene)
  print(feature_p)
}
```

```{r}
# Feature Plots
for (gene in remodel_genes) {
  # Calculate which cell types express the gene and their percentages
  expr_stats <- pb90_subset_meta %>%
    group_by(KPMP_celltype) %>%
    summarise(
      pct_expressed = round(mean(.data[[gene]] > 0) * 100, 1),
      n_total = n(),
      .groups = "drop"
    ) %>%
    filter(pct_expressed > 10)  # Only keep cell types that express the gene
  
  # Filter centers to only include expressing cell types
  centers_filtered <- centers %>%
    mutate(pct_expressed_5 = case_when(KPMP_celltype %in% expr_stats$KPMP_celltype ~ "Y", T ~ "N"))
  
  # Create caption text
  caption_text <- expr_stats %>%
    arrange(desc(pct_expressed)) %>%
    mutate(
      color = celltype_colors[KPMP_celltype],
      label = paste0("<span style='color:", color, "'>&#9679; </span>**", KPMP_celltype, "**: ", pct_expressed, "%"),
      group = ceiling(row_number() / 5)
    ) %>%
    group_by(group) %>%
    summarise(line = paste(label, collapse = " | "), .groups = "drop") %>%
    rbind(data.frame(group = 0, line = "**% Expressed (>10%):**")) %>%
    arrange(group) %>%
    pull(line) %>%
    paste(collapse = "<br><br>") 
  
  feature_p <- pb90_subset_meta %>%
    dplyr::mutate(feature_color_logic = case_when(
      .data[[gene]] > 0 ~ KPMP_celltype,
      TRUE ~ "No")) %>%
    ggplot(aes(x = umapharmony_1, y = umapharmony_2, color = feature_color_logic)) +
    geom_point(alpha = 0.4) +
    geom_text_repel(data = centers_filtered,  # Use filtered centers
                    aes(x = x, y = y, label = KPMP_celltype),
                    inherit.aes = FALSE,
                    size = 4, 
                    fontface = ifelse(centers_filtered$pct_expressed_5 == "Y", "bold", "plain"), 
                    color = ifelse(centers_filtered$pct_expressed_5 == "Y", "black", "#495057"), 
                    max.overlaps = Inf) +
    scale_color_manual(values = c(celltype_colors, "No" = "#edede9")) +
    theme_minimal() + 
    theme(panel.grid = element_blank(),
          text = element_text(size = 15),
          legend.position = "none",
          plot.title = element_text(hjust = 0.5, face = "bold"),
          plot.caption = element_markdown(size = 12, hjust = 0.5),  # Add caption styling
          axis.title.x = element_text(hjust = 0),
          axis.title.y = element_text(hjust = 0)) +
    labs(x = "UMAP1", y = "UMAP2", 
         title = gene,
         caption = caption_text)  # Add caption
  
  print(feature_p)
  s3write_using_region(feature_p, FUN = ggsave, 
                       object = paste0("Projects/CKD/RH_RH2/Results/Figures/UMAP/REMODEL genes/", gene, "_FeaturePlot.png"), 
                       bucket = "scrna", region = "", height = 10, width = 10)
}

```

```{r}
# Dot Plots per cell type
dotplot_df <- pb90_subset_meta %>%
  # For each gene and cell type combination
  group_by(KPMP_celltype_general2) %>%
  summarise(
    across(
      .cols = all_of(remodel_genes),
      .fns = list(
        pct_expressed = ~mean(. > 0) * 100,  # Percent of cells expressing
        mean_expr = ~mean(.[. > 0], na.rm = TRUE)  # Mean expression in expressing cells only
      ),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  ) %>%
  # Reshape to long format
  pivot_longer(
    cols = -KPMP_celltype_general2,
    names_to = c("gene", ".value"),
    names_pattern = "(.+)_(pct_expressed|mean_expr)"
  ) %>%
  # Optional: filter out combinations with no expression
  filter(pct_expressed > 0)

ggplot(dotplot_df, aes(x = gene, y = KPMP_celltype_general2)) +
  geom_point(aes(size = pct_expressed, color = mean_expr)) +
  scale_size_continuous(name = "% Expressed", range = c(1, 10)) +
  scale_colour_gradient(low = "#ffffff", high = "#f08080", name = "Mean Expression") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid = element_blank(),
    text = element_text(size = 20)
  ) +
  labs(x = NULL, y = NULL)

s3write_using_region(FUN = ggsave, 
                     object = paste0("Projects/CKD/RH_RH2/Results/Figures/Dot Plot/REMODEL_genes_celltype_dotplot.png"), 
                       bucket = "scrna", region = "", height = 15, width = 10)

```

```{r}
# Dot Plots per GLP group
dotplot_glp_t2dob_df <- pb90_subset_meta %>%
  filter(group != "Obese_Control") %>%
  # For each gene and cell type combination
  group_by(glp_t2dob) %>%
  summarise(
    across(
      .cols = all_of(remodel_genes),
      .fns = list(
        pct_expressed = ~mean(. > 0) * 100,  # Percent of cells expressing
        mean_expr = ~mean(.[. > 0], na.rm = TRUE)  # Mean expression in expressing cells only
      ),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  ) %>%
  # Reshape to long format
  pivot_longer(
    cols = -glp_t2dob,
    names_to = c("gene", ".value"),
    names_pattern = "(.+)_(pct_expressed|mean_expr)"
  ) %>%
  # Optional: filter out combinations with no expression
  filter(pct_expressed > 0)

ggplot(dotplot_glp_t2dob_df, aes(x = gene, y = glp_t2dob)) +
  geom_point(aes(size = pct_expressed, color = mean_expr)) +
  scale_size_continuous(name = "% Expressed", range = c(1, 10)) +
  scale_colour_gradient(low = "#ffffff", high = "#f08080", name = "Mean Expression") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid = element_blank(),
    text = element_text(size = 20)
  ) +
  labs(x = NULL, y = NULL)

s3write_using_region(FUN = ggsave, 
                     object = paste0("Projects/CKD/RH_RH2/Results/Figures/Dot Plot/REMODEL_genes_glp_t2dob_dotplot.png"), 
                       bucket = "scrna", region = "", height = 5, width = 10)

```

# Clinical correlations (not adjusting for any vars)

## Low res

```{r}
# nebula
pb90_subset$glp_t2dob <- relevel(factor(pb90_subset$glp_t2dob), ref = "HC")

combinations <- expand.grid(
  gene = remodel_genes,
  celltype = names(celltype_groups),
  var = c("hba1c", "acr_u", "eGFR_CKD_epi"),
  stringsAsFactors = FALSE
) %>%
  filter(celltype != "Other")

nebula_results_list <- foreach(i = 1:nrow(combinations),
                               .packages = c("nebula", "Matrix", "Seurat")) %do% {
                                 
                                 g <- combinations$gene[i]
                                 cell <- combinations$celltype[i]
                                 var <- combinations$var[i]
                                 
                                 tryCatch({
                                   cat("Processing:", g, "in", cell, ", ", var, "\n")
                                   
                                   # Subset to current cell type
                                   subset_obj <- subset(pb90_subset, KPMP_celltype_general2 == cell)
                                   
                                   # Get counts for the current gene
                                   count_gene <- round(GetAssayData(subset_obj, layer = "counts")[g, , drop = FALSE])
                                   
                                   # Get metadata
                                   meta_gene <- subset_obj@meta.data
                                   
                                   # Skip if too few cells with non-zero expression
                                   if (sum(count_gene > 0) < 10) {
                                     cat("  Skipping - too few expressing cells\n")
                                     return(NULL)
                                   }
                                   
                                   # Check for complete cases in clinical variables
                                   complete_cases <- complete.cases(meta_gene[, c(var)])
                                   if (sum(complete_cases) < 20) {
                                     cat("  Skipping - too few cells after removing NAs\n")
                                     return(NULL)
                                   }
                                   
                                   # Subset to complete cases
                                   count_gene <- count_gene[, complete_cases, drop = FALSE]
                                   meta_gene <- meta_gene[complete_cases, ]
                                   
                                   # Create predictor matrix
                                   pred_gene <- model.matrix(~ var, data = meta_gene)
                                   
                                   # Run nebula
                                   result <- nebula(
                                     count = count_gene,
                                     id = meta_gene$kit_id,
                                     pred = pred_gene,
                                     ncore = 1,
                                     output_re = TRUE
                                   )
                                   
                                   # Return results with metadata
                                   list(gene = g, celltype = cell, var = var, result = result)
                                   
                                 }, error = function(e) {
                                   cat("  Error:", conditionMessage(e), "\n")
                                   return(NULL)
                                 })
                               }

s3saveRDS(nebula_results_list, object = "Projects/CKD/RH_RH2/Results/clinical_associations/REMODEL_genes_hba1c_uacr_egfr_nebula_lowres.RDS", bucket = "scrna", region = "")
```

```{r}
# nebula results processing
# Remove NULL entries (failed analyses) from the results
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)

# Assign gene names as list names
names(nebula_results_list) <- sapply(nebula_results_list, function(x) 
  paste0(x$gene, "_", x$celltype, "_", x$var))

# Simplify the list to only contain the result objects
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)

# Extract convergence status into a dataframe
nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name, Convergence_Code = converged)
    return(df)
  }
)

# Extract model summaries into a dataframe
nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)

# Identify genes that did not converge (Convergence_Code == -40)
nonconverge_genes <- unique(nebula_converged$Gene[which(nebula_converged$Convergence_Code == -40)])

# ---- Final Cleanup ----

# Create a full results dataframe
full_results <- as.data.frame(nebula_summaries)

# Adjust p-values using False Discovery Rate (FDR) method
full_results <- full_results %>%
  mutate(fdr = p.adjust(`p_group`, method = "fdr"))

# Calculate -log10(p-values), avoid log(0) by setting minimum p-value
full_results$PValue10 <- -log10(pmax(full_results$`p_group`, 1e-10))

# Assign colors based on log fold-change and FDR significance
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_group` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_group` < 0, "lightblue", "gray"))

# Identify significantly differentially expressed genes (FDR < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

s3saveRDS(full_results, object = "Projects/CKD/RH_RH2/Results/clinical_associations/REMODEL_genes_hba1c_uacr_egfr_nebula_processed_lowres.RDS", bucket = "scrna", region = "")
```

## High res

```{r}
# nebula
combinations_highres <- expand.grid(
  gene = remodel_genes,
  celltype = unique(pb90_subset$KPMP_celltype),
  var = c("hba1c", "acr_u", "eGFR_CKD_epi"),
  stringsAsFactors = FALSE
) %>%
  filter(celltype != "non-specific")

nebula_results_list_highres <- foreach(i = 1:nrow(combinations_highres),
                               .packages = c("nebula", "Matrix", "Seurat")) %do% {
                                 
                                 g <- combinations_highres$gene[i]
                                 cell <- combinations_highres$celltype[i]
                                 var <- combinations_highres$var[i]
                                 
                                 tryCatch({
                                   cat("Processing:", g, "in", cell, ", ", var, "\n")
                                   
                                   # Subset to current cell type
                                   subset_obj <- subset(pb90_subset, KPMP_celltype == cell)
                                   
                                   # Get counts for the current gene
                                   count_gene <- round(GetAssayData(subset_obj, layer = "counts")[g, , drop = FALSE])
                                   
                                   # Get metadata
                                   meta_gene <- subset_obj@meta.data
                                   
                                   # Skip if too few cells with non-zero expression
                                   if (sum(count_gene > 0) < 10) {
                                     cat("  Skipping - too few expressing cells\n")
                                     return(NULL)
                                   }
                                   
                                   # Check for complete cases in clinical variables
                                   complete_cases <- complete.cases(meta_gene[, c(var)])
                                   if (sum(complete_cases) < 20) {
                                     cat("  Skipping - too few cells after removing NAs\n")
                                     return(NULL)
                                   }
                                   
                                   # Subset to complete cases
                                   count_gene <- count_gene[, complete_cases, drop = FALSE]
                                   meta_gene <- meta_gene[complete_cases, ]
                                   
                                   # Create predictor matrix
                                   pred_gene <- model.matrix(~ var, data = meta_gene)
                                   
                                   # Run nebula
                                   result <- nebula(
                                     count = count_gene,
                                     id = meta_gene$kit_id,
                                     pred = pred_gene,
                                     ncore = 1,
                                     output_re = TRUE
                                   )
                                   
                                   # Return results with metadata
                                   list(gene = g, celltype = cell, var = var, result = result)
                                   
                                 }, error = function(e) {
                                   cat("  Error:", conditionMessage(e), "\n")
                                   return(NULL)
                                 })
                               }

s3saveRDS(nebula_results_list_highres, object = "Projects/CKD/RH_RH2/Results/clinical_associations/REMODEL_genes_hba1c_uacr_egfr_nebula_highres.RDS", bucket = "scrna", region = "")
```

```{r}
# nebula results processing
# Remove NULL entries (failed analyses) from the results
nebula_results_list_highres <- Filter(Negate(is.null), nebula_results_list_highres)

# Assign gene names as list names
names(nebula_results_list_highres) <- sapply(nebula_results_list_highres, function(x) 
  paste0(x$gene, "_", x$celltype, "_", x$var))

# Simplify the list to only contain the result objects
nebula_results_list_highres <- lapply(nebula_results_list_highres, function(x) x$result)

# Extract convergence status into a dataframe
nebula_converged <- map_dfr(
  names(nebula_results_list_highres),
  function(gene_name) {
    converged <- nebula_results_list_highres[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name, Convergence_Code = converged)
    return(df)
  }
)

# Extract model summaries into a dataframe
nebula_summaries_highres <- map_dfr(
  names(nebula_results_list_highres),
  function(gene_name) {
    df <- nebula_results_list_highres[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)

# Identify genes that did not converge (Convergence_Code == -40)
nonconverge_genes_highres <- unique(nebula_converged$Gene[which(nebula_converged$Convergence_Code == -40)])

# ---- Final Cleanup ----

# Create a full results dataframe
full_results_highres <- as.data.frame(nebula_summaries_highres)

# Adjust p-values using False Discovery Rate (FDR) method
full_results_highres <- full_results_highres %>%
  mutate(fdr = p.adjust(`p_group`, method = "fdr"))

# Calculate -log10(p-values), avoid log(0) by setting minimum p-value
full_results_highres$PValue10 <- -log10(pmax(full_results_highres$`p_group`, 1e-10))

# Assign colors based on log fold-change and FDR significance
full_results_highres$color <- ifelse(full_results_highres$fdr < 0.05 & full_results_highres$`logFC_group` > 0, "lightcoral",
                             ifelse(full_results_highres$fdr < 0.05 & full_results_highres$`logFC_group` < 0, "lightblue", "gray"))

# Identify significantly differentially expressed genes (FDR < 0.05)
significant_df_highres <- full_results_highres[full_results_highres$fdr < 0.05, ]

s3saveRDS(full_results_highres, object = "Projects/CKD/RH_RH2/Results/clinical_associations/REMODEL_genes_hba1c_uacr_egfr_nebula_processed_highres.RDS", bucket = "scrna", region = "")
```
