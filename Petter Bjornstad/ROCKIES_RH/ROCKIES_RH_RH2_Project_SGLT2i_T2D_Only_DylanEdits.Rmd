---
title: "ROCKIES_RH_RH2_Project"
author: "Hailey Hampson"
date: "2025-04-15"
output: html_document
---

#Analysis Plan & Research Questions
```{r}
# Within T2D and T2D/OB: TCA and oxphos transcripts SGLT2i y/n
# Ye Ji and Hailey you have done most of this, we just need to run the new mixed models and also determine if we should adjust for any covariates
# Evaluate associations between TCA and oxphos transcripts and K2 and K2/F in a mixed models. We will likely have better power looking at this in a linear model with continuous K2 and K2/F in lieu of groups (i.e., above and below median / tertiles), but can try both.
```

# 1. Set up 
## a. Libraries & Directores
```{r, include=F}
#Load libraries
#source("Libraries.R")
library(scran)
library(future)
library(future.apply)
library(tidyverse)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(rstatix)
library(arsenal)
library(Biobase)
library(msigdbr)
library(kableExtra)
library(knitr)
library(REDCapR)
library(data.table)
library(emmeans)
library(NMF)
library(pheatmap)
library(UpSetR)
library(enrichR)
library(WriteXLS)
library(SAVER)
library(readxl)
library(limma)
library(edgeR)
library(BiocGenerics)
library(GSEABase)
library(slingshot)
library(SingleCellExperiment)
library(MAST)
library(muscat)
library(scater)
library(Seurat)
library(jsonlite)
library(dplyr)
library(glmmTMB)
library(reshape2)
library(broom.mixed)
library(nebula)






#Set number of cores for parallellization
#maxCores <- detectCores()
#numCores <- maxCores-1
#cl <- makeCluster(numCores)  # Create a cluster with the desired number of cores
#registerDoParallel(cl) 

#Local file path
#dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
#dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
#dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
#dir.results <- c("/Volumes/Peds Endo/Petter Bjornstad/Kidney Project/Results")

# #Lambda file path
# dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
# dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Kidney scRNA/Kidney scRNA")
# dir.results <- c(fs::path(dir.dat,"Kidney Project/Results"))

#Lambda work station file path
# dir.results <- "/home/hailey/Documents/ROCKIES Results"

# #Mac Studio File Path
dir.dat <- c("C:/Users/netio/OneDrive - UW/Laura Pyle's files - Biostatistics Core Shared Drive")
dir.results <- c("C:/Users/netio/Documents/UofW/Rockies/")
# dir.ipa <- c("/Users/hhampson/Documents/IPA/Results")

#Load functions
# source("Kidney_functions_sc.R")
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")
# dir.results <- c("/home/hailey/Documents/Results")

# # write file
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# write.csv(df, temp_file, row.names = FALSE) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, bucket, 'Kidney transcriptomics/ROCKIES Results/filename.csv')

```

## b. Cyberduck 
### i. Lambda
```{r, Cyberduck setup}
# knitr::opts_knit$set(root.dir = dir.results)
# install.packages("reticulate")
# Sys.setenv(RETICULATE_PYTHON = "/home/hailey/miniconda3/envs/py310_env/bin/python")
library(reticulate)
reticulate::py_config()
# library(reticulate)
# reticulate::use_condaenv("py310_env", required = TRUE)
# reticulate::py_config()
# Sys.setenv(LD_LIBRARY_PATH = "/usr/lib/x86_64-linux-gnu")
# reticulate::use_python("/home/hailey/miniconda3/bin/python")
# reticulate::use_condaenv("base", required = TRUE)

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/home/hailey/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```
### ii. Hyak
```{r, Cyberduck setup}
# knitr::opts_knit$set(root.dir = dir.results)
# install.packages("reticulate")
# Sys.setenv(RETICULATE_PYTHON = "/home/hailey/miniconda3/envs/py310_env/bin/python")
library(reticulate)
reticulate::py_config()
# library(reticulate)
# reticulate::use_condaenv("py310_env", required = TRUE)
# reticulate::py_config()
# Sys.setenv(LD_LIBRARY_PATH = "/usr/lib/x86_64-linux-gnu")
# reticulate::use_python("/home/hailey/miniconda3/bin/python")
# reticulate::use_condaenv("base", required = TRUE)

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/mmfs1/home/hhampson/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```

# 2. Quality Control & Preprocessing
## a. Load Kidney scRNA seq Data
### i. Lambda load
```{r, include=F}
#Load PB90 with new KPMP Cell Types
gc()
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "Kidney transcriptomics/Single cell RNA seq/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds", temp_file)
so_kpmp_sc <- readRDS(temp_file)

so_kmpm_sc <- readRDS('C:/Users/netio/Downloads/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds')







```

### ii. Local Load 
```{r}
#Mac Studio pathway
so_kpmp_sc <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/scRNA/data_raw/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds")

```

## b. Load Gene Sets
```{r}
#Lambda
gc()
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# s3$download_file(bucket, "data_clean/tca_cycle_genes.csv", temp_file)
# tca1 <- read.csv(temp_file)
# tca1 <- tca1$genesymbol

# #Local
tca1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/tca_cycle_genes.csv")$genesymbol
tca2 <- c(
  "ACO1", "ACO2", "IDH1", "IDH2", "IDH3A", "IDH3B", "IDH3G", "OGDH", "OGDHL",
  "SUCLA2", "SUCLG1", "SUCLG2", "SDHA", "SDHB", "SDHC", "SDHD", "FH", "MDH1",
  "MDH2", "FAS", "CS"
) #21 genes

tca <- unique(c(tca1,tca2))


#Lambda
# gc()
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# s3$download_file(bucket, "data_clean/ox_phos_genes.csv", temp_file)
# ox_phos1 <- read.csv(temp_file)
# ox_phos1 <- ox_phos1$genesymbol

#Local
ox_phos1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/ox_phos_genes.csv")$genesymbol
ox_phos2 <- c(
  "NDUFS6",  "SDHB", "SDHC", "SDHD",
  "UQCRC1", "UQCRC2", "COX4I1", "COX4I2", "ATP5PF") #47 genes
ox_phos <- unique(c(ox_phos1,ox_phos2))

# #Check gene names
# genes <- unique(c(tca,ox_phos)) #82 genes
# 
# rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% genes)] #37 genes in data

# #Check if other genes are named differentily 
# missing <- genes[!genes %in% rownames(so_kpmp_sc)] #45 missing genes
# rownames(so_kpmp_sc)[which(grepl("ATP5PF",rownames(so_kpmp_sc)))]
```

## c. Data Cleaning, QC & Preprocessing
```{r, echo=F, warning=F, fig.width=15, fig.height=15}
#Fix Typos in kit ids in PB90
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="KI-0014643")] <- "KL-0014643"
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="kl-0023998")] <- "KL-0023998"

# #Lambda load
# bucket <- "harmonized.dataset" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# s3$download_file(bucket, "harmonized_dataset.csv", temp_file)
# harmonized_data <- read.csv(temp_file,na="")

# #Load raw harmonized dataset
harmonized_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean","harmonized_dataset.csv"),na="")

dat <- harmonized_data %>%
  arrange(screen_date) %>% 
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(record_id, visit))
length(unique(dat$mrn))#467
length(unique(dat$record_id))#644

#Filter to renal heir/renal heritage
dat <- dat %>% 
  filter(grepl("RH",record_id) |grepl("RH2",record_id))  #grepl("IT",record_id)
length(unique(dat$mrn))#113
length(unique(dat$record_id))#146

#Filter to baseline visits only (no post surgery)
dat <- dat %>% 
  filter(visit=="baseline") 
length(unique(dat$mrn))#113
length(unique(dat$record_id))#146

#Filter to T2D
dat <- dat %>% 
  filter(group=="Type 2 Diabetes")
length(unique(dat$mrn))#71
length(unique(dat$record_id))#80

#Filter to those with complete SGLT2 data
dat <- dat %>% 
  filter(!is.na(epic_sglti2_1))
length(unique(dat$mrn))#42
length(unique(dat$record_id))#46

#Filter to only those with a kit id and biospy in pb 90
dat <- dat %>% 
  filter(kit_id %in% so_kpmp_sc$kit_id)
length(unique(dat$mrn))#28
length(unique(dat$record_id))#30

# #Find coenrolled individuals
dat$record_id[which(duplicated(dat$mrn))] #"RH2-14-T/RH-23-T" "RH2-19-T/RH-67-T"
dat$mrn[which(duplicated(dat$mrn))] #1664581
dat$kit_id[which(dat$record_id=="RH-23-T")] #KL-0014632
dat$kit_id[which(dat$record_id=="RH2-14-T")] #KL-0029535, Exclude their second biopsy. Maintian baseline no repeated measures only

dat$kit_id[which(dat$record_id=="RH-67-T")] #KL-0024002
dat$kit_id[which(dat$record_id=="RH2-19-T")] 

dat <- dat %>%
  filter(record_id!="RH2-14-T") %>% 
  filter(record_id!="RH2-19-T")

length(unique(dat$mrn))#28
length(unique(dat$record_id))#28

#Final dataset = 31
table(dat$study,dat$group)
#               Lean Control Type 2 Diabetes
# CROCODILE                 13               0
# RENAL-HEIR                 0              11
# RENAL-HEIRitage            0               7

table(dat$group,dat$epic_sglti2_1)
#                 No
# Lean Control    13
# Type 2 Diabetes 18

length(unique(dat$mrn)) #91 LC and T2D at baseline
length(unique(dat$record_id)) #25 no med
length(unique(which(dat$group=="Lean Control"))) #13
length(unique(which(dat$group=="Type 2 Diabetes"))) #18
table1(~age + sex + bmi+epic_mfm_1+epic_insulin_1+epic_sglti2_1+epic_glp1ra_1| group,data=dat)
dat$record_id
#Double check for any missing improve/renal heir coenrolled participants
dat2 <- harmonized_data %>%
  arrange(screen_date) %>% 
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(record_id, visit))

dat2 <- dat2 %>% 
  filter(grepl("IT",record_id))
length(unique(dat2$mrn))#22
length(unique(dat2$record_id))#22

#Filter to baseline visits only (no post surgery)
dat2 <- dat2 %>% 
  filter(visit=="baseline") 
length(unique(dat2$mrn))#22
length(unique(dat2$record_id))#22

#Filter to T2D or LC only
dat2 <- dat2 %>% 
  filter(group=="Type 2 Diabetes")
length(unique(dat2$mrn))#22
length(unique(dat2$record_id))#22

#Filter to those with complete SGLT2s data
dat2 <- dat2 %>% 
  filter(!is.na(epic_sglti2_1))
length(unique(dat2$mrn))#10
length(unique(dat2$record_id))#10

#Filter to only those with a kit id and biospy in pb 90
dat2 <- dat2 %>% 
  filter(kit_id %in% so_kpmp_sc$kit_id)
length(unique(dat2$mrn))#7
length(unique(dat2$record_id))#7

# #Find coenrolled individuals - NONE
dat2$record_id[which(duplicated(dat2$mrn))] #"RH-23-T/"RH2-14-T"
dat2$mrn[which(duplicated(dat2$mrn))] #1664581

#Determine which of these 7 are already included in dat
dat2$mrn[which(dat2$mrn %in% dat$mrn)]
dat2$record_id[which(dat2$mrn %in% dat$mrn)] #"IT_07" "IT_10" "IT_09"
dat2 <- dat2 %>% 
  filter(record_id!="IT_09" & record_id!="IT_07"& record_id!="IT_10")

dat2$mrn[which(!dat2$mrn %in% dat$mrn)]
dat2$record_id[which(!dat2$mrn %in% dat$mrn)] #"IT_11" "IT_12" "IT_13" "IT_19"
#ONLY IT_19 is renal heir coenrolled

#Make sure coenrolled in Renal heir (because IT11 not in RH but IT19 is in RH)
#Remove IT11, merge IT19 into final dataset
dat2 <- dat2 %>% 
  filter(record_id=="IT_19")

#Combine with dataset
dat <- rbind(dat,dat2)
rm(dat2)

#Final dataset = 31
table(dat$study,dat$group)
#               Lean Control Type 2 Diabetes
# CROCODILE                 13               0
# RENAL-HEIR                 0              11
# RENAL-HEIRitage            0               7

table(dat$group,dat$epic_sglti2_1)
# ###########################
# 
# 
# 
# dat <- harmonized_data %>% 
#   filter(visit=="baseline") %>% 
#   filter(group=="Type 2 Diabetes") %>% 
#   filter(grepl("RH",record_id) | record_id=="IT_19")
# # filter(grepl("RH",record_id) | grepl("IT",record_id)) #| grepl("IT",record_id)
# dat$kit_id[which(dat$record_id=="IT_19")] #KL-0027475
# dat$kit_id[which(dat$record_id=="RH-98-T")]
# # datcheck <- dat %>%
# #   arrange(screen_date) %>% 
# #   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
# #                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
# #                    .by = c(mrn, visit))
# # datcheck <- datcheck %>% 
# #   filter(!is.na(kit_id)) %>% 
# #   filter(!is.na(epic_sglti2_1)) %>%  
# #   filter(!(is.na(rh_id) & is.na(rh2_id))) 
# # ids1 <- unique(datcheck$kit_id)
# # ids2 <-unique(datcheck$record_id)
# 
# #Kit ID for IT_08: KL-0019092 for T2D, remove RH-60-T and kit id KL-0014643
# dat2 <- dat %>%
#   arrange(screen_date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
#                    .by = c(mrn, visit))
# length(unique(dat2$mrn)) #all unique mrns
# dat2$kit_id[which(dat2$record_id=="IT_19")] #KL-0027475
# dat2$kit_id[which(dat2$record_id=="RH-98-T")]
# 
# #Filter to having a kit id & a renal heir id & med data
# dat2 <- dat2 %>% 
#   # filter(grepl("RH",record_id) | grepl("IT",record_id)) %>% 
#   # filter(group=="Type 2 Diabetes") %>% 
#   filter(!is.na(kit_id)) %>% 
#   filter(!is.na(epic_sglti2_1)) %>%  
#   filter(!(is.na(rh_id) & is.na(rh2_id))) #34 participants have T2D, RH/RH2, SGLT2 data & biopsies
# #IT_19/RH-98-T enrolled simultenosuly 
# 
# length(unique(dat2$mrn)) #33
# length(unique(dat2$record_id)) #33
# 
# # dat2<- dat2 %>% 
# #   filter(record_id!="IT_08") #33 remain
# 
# dat2$kit_id[which(dat2$kit_id=="KI-0014643")] <- "KL-0014643"
# dat2$kit_id[which(dat2$kit_id=="kl-0023998")] <- "KL-0023998" 
# dat2$kit_id[which(dat2$kit_id=="Kl-0014643")] <- "KL-0014643" 
# #"KL-0030913" "KL-0031453" "KL-0031460" "KL-0032459" kit IDs with biopsies IDs but missing in the pb90 dataset - potentially run after pb90
# 
# #At time of biopsy, baseline in RH2, participant RH2-07-O was an Obese Control, after surgery, developed T2D but must exclude
# # # RH2-07-O
# # dat2$kit_id[which(dat2$record_id=="IT_03")]
# length(unique(dat2$mrn)) #33
# length(unique(dat2$record_id)) #33
# 


ids <- c(dat$kit_id)
biopsy <- unique(so_kpmp_sc$kit_id)
ids[which(!ids %in% biopsy)] 

# unique(so_kpmp_sc$kit_id[which(!so_kpmp_sc$kit_id %in% ids)])
# dat2$record_id[which(!dat2$kit_id %in% so_kpmp_sc$kit_id)]
# meta <- so_kpmp_sc@meta.data
# # ids <- ids[which(!ids %in% c("KL-0030913","KL-0031453","KL-0031460","KL-0032459"))] #30 remain
# ids <- ids[which(ids %in% biopsy)] #30
# length(ids) #29

#Remove "KL-0029521" id
# ids <- ids[which(!ids %in% "KL-0029521")]
# ids
# ids2[which(!ids1 %in% ids)]

#Filter pb90 to these 34 kit ids for aim 1
ids <- c(dat$kit_id)
so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)
length(unique(so_kpmp_sc$kit_id))#29
unique(so_kpmp_sc$kit_id)
unique(so_kpmp_sc$record_id)

#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  so_kpmp_sc@meta.data
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(dat,by="kit_id")
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata back into seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)

#Check number of unique ids
length(unique(so_kpmp_sc$kit_id)) #should be 29
# unique(ids[which(!ids %in% so_kpmp_sc$kit_id)]) 

#Remove metadatasets
rm(meta_kidney_sc,harm_meta_data,harmonized_data,dat,dat2)
length(unique(so_kpmp_sc$record_id[which(grepl("RH2",so_kpmp_sc$record_id))])) #9 RH2
length(unique(so_kpmp_sc$record_id[which(grepl("RH",so_kpmp_sc$record_id))])) #9 RH2
length(unique(so_kpmp_sc$record_id[which(grepl("IT",so_kpmp_sc$record_id))])) #9 RH2


# unique(so_kpmp_sc$record_id)
# #Load raw harmonized dataset
# # #Load raw harmonized dataset
# harmonized_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean","harmonized_dataset.csv"),na="")
# dat <- harmonized_data %>%
#   arrange(screen_date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
#                    .by = c(mrn, visit))
# #Which MRNs have biopsy data
# biopsy <- unique(so_kpmp_sc$kit_id)
# 
# 
# #T2D
# t2d <- dat %>% 
#   filter(grepl("RH",record_id) |grepl("RH2",record_id)| grepl("IT",record_id)) %>% 
#   filter(!is.na(kit_id)) %>%
#   filter(visit=="baseline") %>% 
#   filter(!(is.na(rh_id) & is.na(rh2_id))) %>% 
#   filter(group=="Type 2 Diabetes") %>% 
#   filter(epic_glp1ra_1=="No" & epic_sglti2_1=="No")
# 
# # t2d$record_id[which(is.na(t2d$kit_id))] #missing biopsy: "RH-97-T"  "RH2-41-T" "RH2-49-T"
# # t2d$mrn[which(is.na(t2d$kit_id))] # 978451  758908 2839963
# # t2d <- t2d %>% 
# #   filter(!is.na(kit_id)) 
# 
# length(unique(t2d$mrn)) #12 
# t2d$kit_id[which(!t2d$kit_id %in% so_kpmp_sc$kit_id)]
# t2d$kit_id[which(t2d$kit_id=="KI-0014643")] <- "KL-0014643"
# t2d$kit_id[which(t2d$kit_id=="kl-0023998")] <- "KL-0023998" 
# t2d$kit_id[which(t2d$kit_id=="Kl-0014643")] <- "KL-0014643" #Kl-0014643 
# t2d$kit_id[which(!t2d$kit_id %in% biopsy)] #KL-0030913
# t2d$record_id[which(!t2d$kit_id %in% biopsy)] #"RH2-60-T" missing biopsy 
# 
# t2d <- t2d %>% 
#   filter(kit_id %in% biopsy) #11 participants
# 
# #IT_08 remove because OB at time of baseline biopsy, developed t2d later
# t2d <- t2d %>% 
#   filter(record_id!="IT_08") #10 remain
# 
# # meta <- so_kpmp_sc@meta.data
# 
# #LC
# lc <- dat %>% 
#   # filter(grepl("RH",record_id) | grepl("IT",record_id)) %>% 
#   filter(!is.na(kit_id)) %>% 
#   filter(visit=="baseline") %>% 
#   # filter(!(is.na(rh_id) & is.na(rh2_id))) %>% 
#   filter(group=="Lean Control") %>% 
#   filter(epic_glp1ra_1=="No" & epic_sglti2_1=="No")
# length(unique(lc$mrn)) #13
# lc$kit_id %in% biopsy
# 
# 
# #Combine
# dat2 <- rbind(t2d,lc)
# 
# dat2$kit_id[which(dat2$kit_id=="KI-0014643")] <- "KL-0014643"
# dat2$kit_id[which(dat2$kit_id=="kl-0023998")] <- "KL-0023998" 
# dat2$kit_id[which(dat2$kit_id=="Kl-0014643")] <- "KL-0014643" #Kl-0014643 KL-0019092
# dat2$kit_id[which(!dat2$kit_id %in% so_kpmp_sc$kit_id)]
# 
# 
# #"KL-0030913" "KL-0031453" "KL-0031460" "KL-0032459" kit IDs with biopsies IDs but missing in the pb90 dataset - potentially run after pb90
# 
# ids <- c(dat2$kit_id)
# # ids <- ids[which(!ids %in% c("KL-0030913","KL-0031453","KL-0031460","KL-0032459"))] #30 remain
# length(ids) #23
# 
# 
# #Filter pb90 to these 34 kit ids for aim 1
# so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)
# unique(so_kpmp_sc$kit_id)
# length(unique(so_kpmp_sc$kit_id)) #23
# sort(unique(so_kpmp_sc$record_id))
# 
# #Select metadata from seurat object to facilitate merge of new metadata into seurat object
# meta_kidney_sc <-  so_kpmp_sc@meta.data
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# 
# #Merge metadata from 83 participants at baseline into seurat object metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(dat2,by="kit_id")
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# 
# #Merge metadata back into seurat object
# so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
# 
# #Check number of unique ids
# length(unique(so_kpmp_sc$kit_id)) #should be 24
# # unique(ids[which(!ids %in% so_kpmp_sc$kit_id)]) 
# 
# #Remove metadatasets
# rm(meta_kidney_sc,harm_meta_data,harmonized_data,dat,dat2,lc,t2d)
# gc()

#Create medication & disease status groups of interest
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)

so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
so_kpmp_sc@meta.data$medication <- factor(so_kpmp_sc@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))


# #Filter to RH/RH2 at baseline only
# #RENAL-HEIR or RENAL-HEIRitage
# so_kpmp_sc <- subset(so_kpmp_sc,study=="RENAL-HEIR" | study=="RENAL-HEIRitage")

#Ensure default assay in seurat object to RNA
DefaultAssay(so_kpmp_sc) <- "RNA"


#Before filtering
ncol(so_kpmp_sc)
#  45934 cells
nrow(so_kpmp_sc)
#31332 genes
length(unique(so_kpmp_sc$kit_id))
length(unique(so_kpmp_sc$record_id))
#24 participants
# length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIR")]))
# unique(so_kpmp_sc$record_id[which(so_kpmp_sc$study=="RENAL-HEIR")])
# unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIR")])
# #"RH-68-T"  "RH-49-T"  "RH-63-T"  "RH-23-T"  "RH-71-T"  "RH-62-T"  "RH-50-T"  "RH-74-T"  "RH-72-T"  "RH-76-T"  "RH-77-T" 
# #"RH-75-T"  "RH-67-T"  "IT_19"    "RH-91-T"  "RH2-23-T"
# length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIRitage")]))
# unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIRitage")])
# #9, "RH2-51-T" "RH2-53-T" "RH-93-T"  "RH2-22-T" "RH2-38-T" "RH2-21-T" "RH2-55-T" "RH2-43-T" "RH2-42-T"
# length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$cohort=="IMPROVE")]))
# #5 coenrolled in improve and Renal Heirage, 4 in Renal Heir, 1 in RH2
# #"RH-66-T"  "RH-65-T"  "RH-59-T"  "RH-60-T"  "RH2-07-O"
# 
# unique(so_kpmp_sc$record_id[which(so_kpmp_sc$study=="IMPROVE")])
# unique(so_kpmp_sc$record_id)

#21 total from renal heir, 10 from renal heritage

ncol(so_kpmp_sc)
#43972 cells
nrow(so_kpmp_sc) #31332
#YE JI's filtering code for percent expression 
#Filter out rare genes expressed in less than "gene_pct" of cells
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, layer = "counts"))
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, assay = "RNA", layer = "counts"))
# expr_matrix <- so_kpmp_sc@assays$RNA@counts
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.05])
so_kpmp_sc <- subset(so_kpmp_sc, features = genes_to_keep)
# #After filtering
ncol(so_kpmp_sc) #72469 cells
nrow(so_kpmp_sc) # 9661 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_kpmp_sc), value = TRUE)
# mito_genes2 <- grep("^MT.", rownames(so_kpmp_sc), value = TRUE)
#Filter out all mitochondrial genes

#keep_ids <- unique(rownames(so_kpmp_sc)[which(!rownames(so_kpmp_sc) %in% mito_genes)])
# so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#so_kpmp_sc$Gene <- rownames(so_kpmp_sc)
#so_kpmp_sc <- subset(so_kpmp_sc, Gene %in% keep_ids)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
#so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc@assays$RNA@counts), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc, !rownames(so_kpmp_sc) %in% mito_genes)
# grep("^MT-", rownames(so_kpmp_sc@assays$RNA@counts), value = TRUE)
# dim(so_kpmp_sc@assays$RNA@counts) #9276 186125
# dim(so_kpmp_sc@assays$RNA@data) #9276 186125
# dim(so_kpmp_sc@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
rownames(so_kpmp_sc)[(grepl("^MT", rownames(so_kpmp_sc)))] #0
ncol(so_kpmp_sc) #186125 cells
nrow(so_kpmp_sc) #15180 genes


#Step 3: Remove ribosomal Genes
# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), ribo_genes))
# sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
length(which(rownames(so_kpmp_sc) %in% ribo_genes)) #0
ncol(so_kpmp_sc) #65,062 cells
nrow(so_kpmp_sc) #15103 genes

#Renormalize & Scale after filtering
so_kpmp_sc <- NormalizeData(so_kpmp_sc)
so_kpmp_sc <- ScaleData(so_kpmp_sc, features = VariableFeatures(so_kpmp_sc))

# Calculate cell library size for offset in NEBULA --------------------------------------
counts_layer <- round(GetAssayData(so_kpmp_sc, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
so_kpmp_sc$library_size <- library_size
# View(so_kpmp_sc@meta.data)

# # TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- log(dge$samples$lib.size) + log(dge$samples$norm.factors)
# so_kpmp_sc$tmm_offset <- tmm_offset

# Pooled offset
bp <- MulticoreParam(workers = 63) 
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
# sce <- computeSumFactors(sce)
sce <- computeSumFactors(sce, BPPARAM = bp)
# View size factors
# sizeFactors(sce)
# STEP 3: Calculate offset → log(size factors)
pooled_offset <- sizeFactors(sce)
so_kpmp_sc$pooled_offset <- pooled_offset
#----------------------------------------------------------------------------

#Create general hepatocyte cell type variable
#Create PT and TAL pseudobulk cell type variable
so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
                                  grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
                                  grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
                                  grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
                                  grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
                                  grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
                                  grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
                                  grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
                                  grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
                                  so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
                                  so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
                                  so_kpmp_sc$celltype_rpca=="B"~"B",
                                  so_kpmp_sc$celltype_rpca=="T"~"T")
so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)

so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
                                 so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
                                 so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
                               ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                      ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))
# so_kpmp_sc$celltype2 <- factor(so_kpmp_sc$celltype2)

so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(medication=="sglt2","SGLT2i","No SGLT2i"))

# #Filter to TCA cycle & Ox Phos Genes
# genes <- unique(c(tca,ox_phos))
# so_kpmp_sc <- subset(so_kpmp_sc, features = genes)
# DefaultAssay(so_kpmp_sc) <- "RNA"
# rownames(so_kpmp_sc) #34 genes remain
# nrow(so_kpmp_sc) #34
# ncol(so_kpmp_sc) #45,934 cells
# saveRDS(so_kpmp_sc,fs::path(dir.dat,"Cleaned_so_kpmp_sc2.rds"))
# so_kpmp_sc <- readRDS(fs::path(dir.dat,"Cleaned_so_kpmp_sc2.rds"))
# so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
#                                   grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
#                                   grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
#                                   grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
#                                   grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
#                                   grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
#                                   grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
#                                   grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
#                                   grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
#                                   so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
#                                   so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
#                                   so_kpmp_sc$celltype_rpca=="B"~"B",
#                                   so_kpmp_sc$celltype_rpca=="T"~"T")
# so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)

so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
                                 so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
                                 so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
                               ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                      ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))
#Make sure TAL includes all types
unique(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$TAL_celltype <- ifelse((so_kpmp_sc$KPMP_celltype=="C-TAL-1" | 
                                     so_kpmp_sc$KPMP_celltype=="C-TAL-2"|
                                     so_kpmp_sc$KPMP_celltype=="dTAL" |
                                     so_kpmp_sc$KPMP_celltype=="aTAL"), "TAL","Non-TAL")
# so_kpmp_sc$celltype2 <- factor(so_kpmp_sc$celltype2)

so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(medication=="sglt2","SGLT2i","No SGLT2i"))

tca_genes <- rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% tca)]
ox_phos_genes <- rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% ox_phos)]

#DCT cells
unique(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$DCT_celltype <- ifelse((so_kpmp_sc$KPMP_celltype=="DCT" | 
                                     so_kpmp_sc$KPMP_celltype=="dDCT"), "DCT","Non-DCT")

# #Calculate K2 and F variables
# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
#   rowwise() %>%
#   mutate(avg_c_k2 = (lc_k2+rc_k2)/2) %>%
#   mutate(avg_m_k2 = (lm_k2+rm_k2)/2) %>%
#   mutate(avg_c_f = (lc_f+rc_f)/2) %>%
#   mutate(avg_m_f = (lm_f+rm_f)/2) %>%
#   ungroup()
# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
#   rowwise() %>%
#   mutate(avg_c_k2_f = (avg_c_k2/avg_c_f)) %>%
#   mutate(avg_m_k2_f = (avg_m_k2/avg_m_f)) %>%
#   ungroup()

#Filter to TCA cycle & Ox Phos Genes
genes <- unique(c(tca,ox_phos))
so_subset <- subset(so_kpmp_sc, features = genes)
DefaultAssay(so_subset) <- "RNA"
rownames(so_subset) #34 genes remain
nrow(so_subset) #34
ncol(so_subset) #68909 cells
rm(counts_layer,meta,sce)
# 
# #Calculate K2 and F variables
# so_subset@meta.data <- so_subset@meta.data %>%
#   rowwise() %>%
#   mutate(avg_c_k2 = (lc_k2+rc_k2)/2) %>%
#   mutate(avg_m_k2 = (lm_k2+rm_k2)/2) %>%
#   mutate(avg_c_f = (lc_f+rc_f)/2) %>%
#   mutate(avg_m_f = (lm_f+rm_f)/2) %>%
#   ungroup()
# so_subset@meta.data <- so_subset@meta.data %>%
#   rowwise() %>%
#   mutate(avg_c_k2_f = (avg_c_k2/avg_c_f)) %>%
#   mutate(avg_m_k2_f = (avg_m_k2/avg_m_f)) %>%
#   ungroup()
```

## d. Explore Distribution & Zero-Inflation
```{r}
# #Filter to TCA cycle & Ox Phos Genes
# genes <- unique(c(tca,ox_phos))
# so_subset <- subset(so_kpmp_sc, features = genes)
# DefaultAssay(so_subset) <- "RNA"
# rownames(so_subset) #34 genes remain
# nrow(so_subset) #34
# ncol(so_subset) #68909 cells

#Check if data have been normalized 
so_subset@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_subset, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_subset, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
#Raw counts
pdf(fs::path(dir.results,"Raw_count_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
# genes <- sample(rownames(so_subset), 100)
genes <- rownames(so_subset)
# genes <- unique(c(tca,ox_phos))
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))
# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_subset, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Count Expression")     # Label for x-axis
}
# Close the PDF device — this writes the file to disk
dev.off()

#Normalized Expression
pdf(fs::path(dir.results,"Normalized_Expression_gene_expression_histograms_counts.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
# genes <- sample(rownames(so_subset), 100)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_subset, layer = "data")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Normalized Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_subset, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_subset, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=25, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 8))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)
```

## g. Evaluate Covariates before Adjustment
```{r}
#Categorical Covariates
#Get metadata for everyone
dat <- so_subset@meta.data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
# label(dat$SGLT2) <- "SGLT2i"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"

dat$group <- factor(dat$group)

#Check
table1(~age + sex + bmi + triglycerides + hba1c+ eGFR_CKD_epi+gfr_bsa_plasma +acr_u +epic_mfm_1+epic_insulin_1+group | epic_sglti2_1,data=dat)

#Examine covariates
cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_SGLT2i_T2D.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  p <- ggplot(dat, aes_string(x = "SGLT2", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#2a9d8f", "#e9c46a")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_SGLT2_T2D.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "SGLT2", y = covariate, fill = "SGLT2")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()
```

## h. Visualizations 
```{r}
# PCA
so_kpmp_sc <- FindVariableFeatures(object = so_kpmp_sc)
so_kpmp_sc <- RunPCA(so_kpmp_sc, features = VariableFeatures(object = so_kpmp_sc),assay="RNA")
ElbowPlot(so_kpmp_sc)

# # Find neighbors and clusters (again using integrated data)
so_kpmp_sc <- FindNeighbors(so_kpmp_sc, assay = "RNA", dims = 1:20)
so_kpmp_sc <- FindClusters(so_kpmp_sc, resolution = 0.5)

p <- DimPlot(so_kpmp_sc, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")
p
#Print plot
png(fs::path(dir.results, "UMAP_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(so_kpmp_sc, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type among T2D")
print(p)
dev.off()

# so_kpmp_sc$group <- factor(so_kpmp_sc$group)
# DimPlot(so_kpmp_sc, reduction = "umap.harmony",group.by = "group",label=F,raster=F) +
#   ggtitle(paste0("UMAP by Diabetes Category"))
# 
# so_kpmp_sc$medication <- factor(so_kpmp_sc$medication)
# DimPlot(so_kpmp_sc, reduction = "umap.harmony",group.by = "medication",label=F,raster=F) +
#   ggtitle(paste0("UMAP by Medication Category"))

# so_kpmp_sc$medication3 <- ifelse(so_kpmp_sc$medication=="SGLT2","SGLT2i","No SGLT2i")
# so_kpmp_sc$medication3 <- factor(so_kpmp_sc$medication3)
DimPlot(
  so_kpmp_sc,
  reduction = "umap.harmony",
  group.by = "SGLT2",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("lightgray","darkblue")) +
  ggtitle("UMAP by SGLT2i Status")


#Print plot
png(fs::path(dir.results, "UMAP_SGLT2_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_kpmp_sc,
  reduction = "umap.harmony",
  group.by = "SGLT2",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("lightgray","darkblue")) +
  ggtitle("UMAP by SGLT2i Status")
print(p)
dev.off()

#Print plot
png(fs::path(dir.results, "UMAP_Medication_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_kpmp_sc,
  reduction = "umap.harmony",
  group.by = "medication",
  label = FALSE,
  raster = FALSE
) +
  # scale_color_manual(values = c( "#e9c46a", "#f4a261", "#e76f51","darkred")) +
  ggtitle("UMAP by Medication Status in T2D")
print(p)
dev.off()

#Barcharts of proportions
cellcount <- so_kpmp_sc@meta.data
prop_plot <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Participant IDs") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(SGLT2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png(fs::path(dir.results, "Barchart_SGLT2_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()


# prop_plot <- ggplot(data=cellcount,aes(medication3, fill = KPMP_celltype)) + 
#   geom_bar(stat = "count", position = "fill") +
#   theme_classic() +
#   labs(x = NULL,
#        y = "Proportion of Cells",
#        fill = "Cell type") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
#   theme(plot.title = element_text(hjust=0.5, face="bold"),
#         text = element_text(size = 20)) 
# # ggtitle("PT Cells") +
# # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
# prop_plot

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "PT")
# cellcount$SGLT2 <- ifelse(cellcount$SGLT2=="Yes","SGLT2","No SGLT2")
label(cellcount$SGLT2) <- "SGLT2i Status"
prop_plota <- ggplot(data=cellcount,aes(SGLT2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("PT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_PT_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plota)
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "aPT", "aPT", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "PT-S1/S2", "PT-S1/S2", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "PT-S3", "PT-S3", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)


cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "TAL")
# cellcount$SGLT2 <- ifelse(cellcount$SGLT2=="Yes","SGLT2","No SGLT2")

label(cellcount$SGLT2) <- "SGLT2i Status"
prop_plotb <- ggplot(data=cellcount,aes(SGLT2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("TAL Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_TAL_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotb)
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "C-TAL-1", "C-TAL-1", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "C-TAL-2", "C-TAL-2", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "dTAL", "dTAL", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "aTAL", "aTAL", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))
# cellcount$SGLT2 <- ifelse(cellcount$SGLT2=="Yes","SGLT2","No SGLT2")
label(cellcount$SGLT2) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(SGLT2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("EC Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_EC_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC/VSMC", "EC/VSMC", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC-AVR", "EC-AVR", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC-PTC", "EC-PTC", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC-LYM", "EC-LYM", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC-AEA", "EC-AEA", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "EC-GC", "EC-GC", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("dDCT",KPMP_celltype) | grepl("DCT",KPMP_celltype))
# cellcount$SGLT2 <- ifelse(cellcount$SGLT2=="Yes","SGLT2","No SGLT2")
label(cellcount$SGLT2) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(SGLT2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("DCT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_DCT_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_dDCT = ifelse(KPMP_celltype == "dDCT", "dDCT", "Other"))
table_dDCT <- table(cellcount$SGLT2, cellcount$is_dDCT)
print(table_dDCT)
chisq.test(table_dDCT)

cellcount <- so_kpmp_sc@meta.data %>% 
  mutate(is_DCT = ifelse(KPMP_celltype == "DCT", "DCT", "Other"))
table_DCT <- table(cellcount$SGLT2, cellcount$is_DCT)
print(table_DCT)
chisq.test(table_DCT)


#Individual
#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "PT")

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plota <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  facet_wrap(~SGLT2,scales = "free_x")+
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("PT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_PT_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plota )
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "TAL")

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotb <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  facet_wrap(~SGLT2,scales = "free_x")+
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("TAL Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_TAL_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotb)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  facet_wrap(~SGLT2,scales = "free_x")+
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("EC Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plotc 

png(fs::path(dir.results, "Barchart_EC_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("dDCT",KPMP_celltype) | grepl("DCT",KPMP_celltype))

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  facet_wrap(~SGLT2,scales = "free_x")+
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("DCT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plotc 

png(fs::path(dir.results, "Barchart_DCT_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

```

## i. Descriptive Stats
```{r, echo = F,warning=F}
#Get metadata for everyone
dat <- so_subset@meta.data %>%
  # filter(group=="Type_2_Diabetes") %>% 
  
  # group_by(record_id) %>%
  # summarise(across(everything(), first)) %>%
  # ungroup() 
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))

# dat <- dat %>% 
#   mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i"))

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
label(dat$SGLT2) <- "SGLT2i"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$gfr_bsa_plasma) <- "Body-Surface Adj. Measured Glomerular Filtration Rate (mGFR)"


#Table 1
table1(~age + sex + bmi + triglycerides + hba1c+pah_clear_bsa + eGFR_CKD_epi+gfr_bsa_plasma +acr_u +epic_mfm_1+epic_insulin_1| epic_sglti2_1,data=dat)



```


# 3. Comparitive Data Analysis
#A. SGLT2i Yes vs No (T2D Only)
##a. All Cells
####TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- so_subset
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #68909 PT cells

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
#Make sure to set reference level
so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(tca_genes)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_TCA_cycle_ALL_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cell <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_epic_sglti2_1Yes`)
# max <- 3.1
min <- min(full_results$`logFC_epic_sglti2_1Yes`)

dot_plot <- ggplot(full_results, aes(
  y = reorder(gene, `logFC_epic_sglti2_1Yes`),
  x = `logFC_epic_sglti2_1Yes`,
  color = color,
  size = abs(`logFC_epic_sglti2_1Yes`)
)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +  # Retains grid lines
  labs(
    title = "Differentially Expressed TCA Cycle Genes in All Cell Types",
    subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Cells = ", Cell,
      ", Non-Convergence Rate: ", Nonconvergence_Rate,
      ", Genes Filtered out for Low Expression: ", low_exp
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    # axis.text.x = element_text(angle = 0, hjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )
dot_plot

png(fs::path(dir.results, "Plot_TCA_cycle_NEBULA_All_Cells_SGLT2_T2D_unadjusted_pooled_offset.png"), 
    width = 2500, height = 2000, res = 300)
print(dot_plot)
dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- so_subset
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #68909 PT cells

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
#Make sure to set reference level
so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#OX_PHOS Cycle
# List of genes
genes_list <- ox_phos_genes

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(ox_phos_genes)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_OX_PHOS_cycle_ALL_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cell <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_epic_sglti2_1Yes`)
# max <- 3.1
min <- min(full_results$`logFC_epic_sglti2_1Yes`)

dot_plot <- ggplot(full_results, aes(
  y = reorder(gene, `logFC_epic_sglti2_1Yes`),
  x = `logFC_epic_sglti2_1Yes`,
  color = color,
  size = abs(`logFC_epic_sglti2_1Yes`)
)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +  # Retains grid lines
  labs(
    title = "Differentially Expressed OX PHOS Cycle Genes in All Cell Types",
    subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Cells = ", Cell,
      ", Non-Convergence Rate: ", Nonconvergence_Rate,
      ", Genes Filtered out for Low Expression: ", low_exp
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    # axis.text.x = element_text(angle = 0, hjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )
dot_plot

png(fs::path(dir.results, "Plot_OX_PHOS_cycle_NEBULA_All_Cells_SGLT2_T2D_unadjusted_pooled_offset.png"), 
    width = 2500, height = 2000, res = 300)
print(dot_plot)
dev.off()
```
##b. PT Cells 
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,celltype2=="PT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #13534 PT cells

#Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
#Make sure to set reference level
so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")


counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(tca_genes)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cell <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_epic_sglti2_1Yes`)
# max <- 3.1
min <- min(full_results$`logFC_epic_sglti2_1Yes`)

dot_plot <- ggplot(full_results, aes(
  y = reorder(gene, `logFC_epic_sglti2_1Yes`),
  x = `logFC_epic_sglti2_1Yes`,
  color = color,
  size = abs(`logFC_epic_sglti2_1Yes`)
)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +  # Retains grid lines
  labs(
    title = "Differentially Expressed TCA Cycle Genes in PT Cells",
    subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Cells = ", Cell,
      ", Non-Convergence Rate: ", Nonconvergence_Rate,
      ", Genes Filtered out for Low Expression: ", low_exp
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    # axis.text.x = element_text(angle = 0, hjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )
dot_plot

png(fs::path(dir.results, "Plot_TCA_cycle_NEBULA_PT_Cells_SGLT2_T2D_unadjusted_pooled_offset.png"), 
    width = 2500, height = 2000, res = 300)
print(dot_plot)
dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,celltype2=="PT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #13534 PT cells

#Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
#Make sure to set reference level
so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")


counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#Ox_Phos Cycle
# List of genes
genes_list <- ox_phos_genes

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(ox_phos_genes)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_OX_PHOS_cycle_PT_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cell <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_epic_sglti2_1Yes`)
# max <- 3.1
min <- min(full_results$`logFC_epic_sglti2_1Yes`)

dot_plot <- ggplot(full_results, aes(
  y = reorder(gene, `logFC_epic_sglti2_1Yes`),
  x = `logFC_epic_sglti2_1Yes`,
  color = color,
  size = abs(`logFC_epic_sglti2_1Yes`)
)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +  # Retains grid lines
  labs(
    title = "Differentially Expressed OX PHOS Cycle Genes in PT Cells",
    subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Cells = ", Cell,
      ", Non-Convergence Rate: ", Nonconvergence_Rate,
      ", Genes Filtered out for Low Expression: ", low_exp
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    # axis.text.x = element_text(angle = 0, hjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )
dot_plot

png(fs::path(dir.results, "Plot_OX_PHOS_cycle_NEBULA_PT_Cells_SGLT2_T2D_unadjusted_pooled_offset.png"), 
    width = 2500, height = 2000, res = 300)
print(dot_plot)
dev.off()
```
###i. PT Subtypes
```{r}
celltypes <- c("PT-S1/S2","PT-S3","aPT")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,KPMP_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```

##c. TAL
```{r}
celltypes <- c("TAL")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,celltype2==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```
###i. TAL Subtypes
```{r}
celltypes <- c("C-TAL-1","C-TAL-2","aTAL","dTAL")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,KPMP_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```

##d. DCT
```{r}
celltypes <- c("DCT")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,DCT_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```
### i. DCT Subtypes
```{r}
celltypes <- c("DCT","dDCT")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,KPMP_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```

##e. EC Cells
```{r}
celltypes <- c("EC")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,celltype2==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```
###i. EC Subtypes
```{r}
celltypes <- c("EC/VSMC","EC-AVR","EC-PTC","EC-AEA","EC-LYM","EC-GC")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,KPMP_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```

##f. Podocytes
```{r}
celltypes <- c("POD")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,celltype2==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```

##g. Immune cells
```{r}
celltypes <- c(
  "cDC",
  "cycT",
  "CD4+ T",
  "CD8+ T",
  "NK",
  "B",
  "MON",
  "MAC",
  "MC")
for (celltype in celltypes) {
  #Filter to PT Cells
  so_celltype <- subset(so_subset,KPMP_celltype==celltype)
  DefaultAssay(so_celltype) <- "RNA" 
  
  nrow(so_celltype) #34 genes
  ncol(so_celltype) #13534 PT cells
  
  celltype2 <- str_replace_all(celltype,"/","_")
  celltype2 <- str_replace_all(celltype2,"-","_")
  celltype2 <- str_replace_all(celltype2," ","")
  celltype2 <- str_replace_all(celltype2,"\\+","_")
  
  #Make sure exposure/independent/x variable or SGLT2 variable is a factor variable
  so_celltype$epic_sglti2_1 <- factor(so_celltype$epic_sglti2_1)
  #Make sure to set reference level
  so_celltype$epic_sglti2_1  <- relevel(so_celltype$epic_sglti2_1 ,ref="No")
  
  
  counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
  
  # With parallelization
  #TCA Cycle
  # List of genes
  genes_list <- tca_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_TCA_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_epic_sglti2_1Yes`3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_tca <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed TCA Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  
  #Ox_Phos Cycle
  # List of genes
  genes_list <- ox_phos_genes
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~epic_sglti2_1, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_epic_sglti2_1Yes`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_epic_sglti2_1Yes`, 1e-10))  # Avoid log(0)
  
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_OX_PHOS_cycle_",celltype2,"_cells_SGLT2_T2D_Only_unadjusted_pooled_offset.csv")))
  
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` > 0, "lightcoral",
                               ifelse(full_results$fdr < 0.05 & full_results$`logFC_epic_sglti2_1Yes` < 0, "lightblue", "gray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Cell <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  
  
  max <- max(full_results$`logFC_epic_sglti2_1Yes`)
  # max <- 3.1
  min <- min(full_results$`logFC_epic_sglti2_1Yes`)
  
  dot_plot_ox_phos <- ggplot(full_results, aes(
    y = reorder(gene, `logFC_epic_sglti2_1Yes`),
    x = `logFC_epic_sglti2_1Yes`,
    color = color,
    size = abs(`logFC_epic_sglti2_1Yes`)
  )) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    scale_size(range = c(2, 6), name = "|LogFC|") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
    theme_minimal() +  # Retains grid lines
    labs(
      title = paste0("Differentially Expressed OX PHOS Cycle Genes in ",celltype," Cells"),
      subtitle = "SGLT2i vs. No SGLT2i (T2D Only), Unadjusted (Pooled Offset)",
      x = "Log Fold Change",
      y = "Gene",
      caption = paste0(
        "FDR < 0.05, Genes = ", Genes,
        ", Cells = ", Cell,
        ", Non-Convergence Rate: ", Nonconvergence_Rate,
        ", Genes Filtered out for Low Expression: ", low_exp
      )
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.y = element_text(size = 8),
      # axis.text.x = element_text(angle = 0, hjust = 1),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks.x = element_line(color = "black"),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  comb_plot <- dot_plot_tca + dot_plot_ox_phos
  # dot_plot
  # 
  png(fs::path(dir.results, paste("Plot_NEBULA_",celltype2,"_Cells_SGLT2_T2D_unadjusted_pooled_offset.png")),
      width = 5000, height = 2000, res = 300)
  print(comb_plot)
  dev.off()
  
}
```



# B. K2 & K2/F
```{r}
#Calculate K2 and F variables
so_kpmp_sc$avg_c_k2 <- (so_kpmp_sc$lc_k2+so_kpmp_sc$rc_k2)/2 
so_kpmp_sc$avg_m_k2 <- (so_kpmp_sc$lm_k2+so_kpmp_sc$rm_k2)/2
so_kpmp_sc$avg_c_f <- (so_kpmp_sc$lc_f+so_kpmp_sc$rc_f)/2 
so_kpmp_sc$avg_m_f <- (so_kpmp_sc$lm_f+so_kpmp_sc$rm_f)/2
so_kpmp_sc$avg_c_k2_f <- so_kpmp_sc$avg_c_k2/so_kpmp_sc$avg_c_f
so_kpmp_sc$avg_m_k2_f <- so_kpmp_sc$avg_m_k2/so_kpmp_sc$avg_m_f

#Calculate above and below median values
so_kpmp_sc$avg_c_k2_med <- ifelse(so_kpmp_sc$avg_c_k2>median(so_kpmp_sc$avg_c_k2,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_c_k2_med <- factor(so_kpmp_sc$avg_c_k2_med)
so_kpmp_sc$avg_c_k2_med <- relevel(so_kpmp_sc$avg_c_k2_med,"Below Median")

so_kpmp_sc$avg_m_k2_med <- ifelse(so_kpmp_sc$avg_m_k2>median(so_kpmp_sc$avg_m_k2,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_m_k2_med <- factor(so_kpmp_sc$avg_m_k2_med)
so_kpmp_sc$avg_m_k2_med <- relevel(so_kpmp_sc$avg_m_k2_med,"Below Median")

so_kpmp_sc$avg_c_f_med <- ifelse(so_kpmp_sc$avg_c_f>median(so_kpmp_sc$avg_c_f,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_c_f_med <- factor(so_kpmp_sc$avg_c_f_med)
so_kpmp_sc$avg_c_f_med <- relevel(so_kpmp_sc$avg_c_f_med,"Below Median")

so_kpmp_sc$avg_m_f_med <- ifelse(so_kpmp_sc$avg_m_f>median(so_kpmp_sc$avg_m_f,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_m_f_med <- factor(so_kpmp_sc$avg_m_f_med)
so_kpmp_sc$avg_m_f_med <- relevel(so_kpmp_sc$avg_m_f_med,"Below Median")

so_kpmp_sc$avg_c_k2_f_med <- ifelse(so_kpmp_sc$avg_c_k2_f>median(so_kpmp_sc$avg_c_k2_f,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_c_k2_f_med  <- factor(so_kpmp_sc$avg_c_k2_f_med )
so_kpmp_sc$avg_c_k2_f_med  <- relevel(so_kpmp_sc$avg_c_k2_f_med ,"Below Median")

so_kpmp_sc$avg_m_k2_f_med <- ifelse(so_kpmp_sc$avg_m_k2_f>median(so_kpmp_sc$avg_m_k2_f,na.rm=T),"Above Median","Below Median")
so_kpmp_sc$avg_m_k2_f_med <- factor(so_kpmp_sc$avg_m_k2_f_med)
so_kpmp_sc$avg_m_k2_f_med <- relevel(so_kpmp_sc$avg_m_k2_f_med,"Below Median")

#Among subset data
#Calculate K2 and F variables
so_subset$avg_c_k2 <- (so_subset$lc_k2+so_subset$rc_k2)/2 
so_subset$avg_m_k2 <- (so_subset$lm_k2+so_subset$rm_k2)/2
so_subset$avg_c_f <- (so_subset$lc_f+so_subset$rc_f)/2 
so_subset$avg_m_f <- (so_subset$lm_f+so_subset$rm_f)/2
so_subset$avg_c_k2_f <- so_subset$avg_c_k2/so_subset$avg_c_f
so_subset$avg_m_k2_f <- so_subset$avg_m_k2/so_subset$avg_m_f

#Calculate above and below median values
so_subset$avg_c_k2_med <- ifelse(so_subset$avg_c_k2>median(so_subset$avg_c_k2,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_k2_med <- factor(so_subset$avg_c_k2_med)
so_subset$avg_c_k2_med <- relevel(so_subset$avg_c_k2_med,"Below Median")

so_subset$avg_m_k2_med <- ifelse(so_subset$avg_m_k2>median(so_subset$avg_m_k2,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_k2_med <- factor(so_subset$avg_m_k2_med)
so_subset$avg_m_k2_med <- relevel(so_subset$avg_m_k2_med,"Below Median")

so_subset$avg_c_f_med <- ifelse(so_subset$avg_c_f>median(so_subset$avg_c_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_f_med <- factor(so_subset$avg_c_f_med)
so_subset$avg_c_f_med <- relevel(so_subset$avg_c_f_med,"Below Median")

so_subset$avg_m_f_med <- ifelse(so_subset$avg_m_f>median(so_subset$avg_m_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_f_med <- factor(so_subset$avg_m_f_med)
so_subset$avg_m_f_med <- relevel(so_subset$avg_m_f_med,"Below Median")

so_subset$avg_c_k2_f_med <- ifelse(so_subset$avg_c_k2_f>median(so_subset$avg_c_k2_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_k2_f_med  <- factor(so_subset$avg_c_k2_f_med )
so_subset$avg_c_k2_f_med  <- relevel(so_subset$avg_c_k2_f_med ,"Below Median")

so_subset$avg_m_k2_f_med <- ifelse(so_subset$avg_m_k2_f>median(so_subset$avg_m_k2_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_k2_f_med <- factor(so_subset$avg_m_k2_f_med)
so_subset$avg_m_k2_f_med <- relevel(so_subset$avg_m_k2_f_med,"Below Median")

```

##a. PT Cells 
###i. Continuous 
#### TCA Cycle 
#### Unadjusted
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "Proximal Tubule Cells",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
######Adjusted
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred.formula <- as.formula(paste0("~",exposure,"+epic_sglti2_1"))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","logFC_cov1","se_Intercept","se","se_cov1","p_Intercept","p_value","p_cov1","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_adjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "Proximal Tubule Cells, Adj. SGLT2i",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_adjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
##### Ox Phos
######Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#Ox Phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "Proximal Tubule Cells",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
######Adjusted
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#OX PHOS Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred.formula <- as.formula(paste0("~",exposure,"+epic_sglti2_1"))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","logFC_cov1","se_Intercept","se","se_cov1","p_Intercept","p_value","p_cov1","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_OX_PHOS_cycle_PT_cells_PET_Variables_adjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_OX_PHOS_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "OX PHOS Cycle Genes vs. PET Variables (T2D)",
       subtitle = "Proximal Tubule Cells, Adj. SGLT2i",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_OX_PHOS_cycle_NEBULA_PT_PET_adjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```

###ii. Median Split
#### TCA Cycle 
#####Unadjusted
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()

for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset_Median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "Proximal Tubule Cells (T2)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#####Adjusted
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()

for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure,"+epic_sglti2_1"))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","logFC_cov1","se_Intercept","se","se_cov1","p_Intercept","p_value","p_cov1","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_adjusted_pooled_offset_Median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "Proximal Tubule Cells (T2D), Adj. SGLT2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_adjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#### Ox Phos
#####Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#Ox Phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "Proximal Tubule Cells (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#####Adjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# With parallelization
#Ox Phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure,"+epic_sglti2_1"))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","logFC_cov1","se_Intercept","se","se_cov1","p_Intercept","p_value","p_cov1","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "Proximal Tubule Cells (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

### ii. PT-S1/2
### a. Continuous
##### TCA Cycle 
######Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "PT-S1/S2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

##### Ox Phos
######Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "PT-S1/S2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
######Adjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure,"+epic_sglti2_1"))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "PT-S1/S2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
### b. Median Split
#### TCA Cycle 
#####Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "PT-S1/S2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#####Adjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "PT-S1/S2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#### Ox Phos
#####Unadjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "PT-S1/S2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#####Adjusted
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "PT-S1/S2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

### iii. PT-S3
####a. Continuous
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S3")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_S3_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "PT-S3",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S3")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S3_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "PT-S3",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

```
### b. Median Split
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S3")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_PT_S3_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "PT-S3 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S3")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_S3_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "PT-S3 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

### iv. aPT
###a. Continuos 
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aPT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_aPT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "aPT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aPT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_aPT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "aPT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
### b. Median Split
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aPT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_aPT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "aPT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aPT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_aPT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "aPT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
# 
# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

###i. TAL
####a. Continuous
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,TAL_celltype=="TAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_TAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "TAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,TAL_celltype=="TAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_TAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "TAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```

#### b. Median Split
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,TAL_celltype=="TAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_TAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "TAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,TAL_celltype=="TAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_TAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "TAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

###ii. C-TAL-1
####a. Continuous
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-1")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_C_TAL_1_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "C-TAL-1",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_C_TAL_1_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-1")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_C_TAL_1_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "C-TAL-1",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_C_TAL_1_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

```

#### b. Median Split
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-1")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_C_TAL_1_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "C-TAL-1 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_C_TAL_1_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-1")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_C_TAL_1_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "C-TAL-1 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_C_TAL_1_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()
```

###iii. C-TAL-2
####a. Continuous
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_C_TAL_2_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "C-TAL-2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_C_TAL_2_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_C_TAL_2_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "C-TAL-2",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_C_TAL_2_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

```
####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_C_TAL_2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "C-TAL-2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_C_TAL_2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_C_TAL_2_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "C-TAL-2 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_C_TAL_2_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

### iv. dTAL
####a. Continuous
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_dTAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "dTAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_dTAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_dTAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "dTAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_dTAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

```
####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_dTAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "dTAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_dTAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_dTAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "dTAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_dTAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

### v. aTAL
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_aTAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "aTAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_aTAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_aTAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "aTAL",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_aTAL_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_aTAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "aTAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_aTAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_aTAL_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "aTAL (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_aTAL_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

###i. DCT
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,DCT_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_DCT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "DCT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_DCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,DCT_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#ox phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_DCT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "DCT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_DCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- total_results[total_results$fdr < 0.05, ]

Genes <- length(unique(total_results$gene))
Nuclei <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
#                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- total_results[total_results$fdr3 < 0.2, ]

# Your custom facet labels
# custom_labels <- c(
#   "Average Cortical K2", "Average Medulla K2",
#   "Average Cortical F", "Average Medulla F",
#   "Average Cortical K2/F", "Average Medulla K2/F"
# )
# 
# # Ensure 'Variable' is a factor in the correct order
# custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
total_results <- total_results %>%
  group_by(Variable) %>%
  mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
  ungroup()

# Plot
dot_plot <- ggplot(total_results, aes(
  # y = reorder(gene, logFC),
  y = gene_ordered,
  x = logFC,
  color = color,
  size = abs(logFC)
)) +
  geom_point(alpha = 0.7) +
  facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(
    title = "Differentially Expressed ox phos Genes (Type 2 Diabetes)",
    subtitle = "PET Variables in DCT Cells, Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Nuclei = ", Nuclei
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )

# Print the plot
dot_plot


png(fs::path(dir.results, "DotPlot_ox_phos_NEBULA_DCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 2500, height = 3000, res = 300)
print(dot_plot)
dev.off()
```

####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,DCT_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_DCT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "DCT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_DCT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_DCT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "DCT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_DCT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

###ii. DCT1
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_DCT_1_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "DCT-1",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_DCT1_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()



```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#ox phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_DCT1_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "DCT-1",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_DCT1_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_DCT_1_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "DCT-1 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_DCT_1_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="DCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_DCT_1_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "DCT-1 (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_DCT_1_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```
###iii. dDCT
#### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dDCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_dDCT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (T2D)",
       subtitle = "dDCT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- total_results[total_results$fdr < 0.05, ]

Genes <- length(unique(total_results$gene))
Nuclei <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
#                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- total_results[total_results$fdr3 < 0.2, ]

# Your custom facet labels
# custom_labels <- c(
#   "Average Cortical K2", "Average Medulla K2",
#   "Average Cortical F", "Average Medulla F",
#   "Average Cortical K2/F", "Average Medulla K2/F"
# )
# 
# # Ensure 'Variable' is a factor in the correct order
# custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
total_results <- total_results %>%
  group_by(Variable) %>%
  mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
  ungroup()

# Plot
dot_plot <- ggplot(total_results, aes(
  # y = reorder(gene, logFC),
  y = gene_ordered,
  x = logFC,
  color = color,
  size = abs(logFC)
)) +
  geom_point(alpha = 0.7) +
  facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(
    title = "Differentially Expressed TCA Cycle Genes (Type 2 Diabetes)",
    subtitle = "PET Variables in dDCT Cells, Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Nuclei = ", Nuclei
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )

# Print the plot
dot_plot


png(fs::path(dir.results, "DotPlot_TCA_cycle_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 2500, height = 3000, res = 300)
print(dot_plot)
dev.off()
```
#### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dDCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#ox phos
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_dDCT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (T2D)",
       subtitle = "dDCT",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- total_results[total_results$fdr < 0.05, ]

Genes <- length(unique(total_results$gene))
Nuclei <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
#                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- total_results[total_results$fdr3 < 0.2, ]

# Your custom facet labels
# custom_labels <- c(
#   "Average Cortical K2", "Average Medulla K2",
#   "Average Cortical F", "Average Medulla F",
#   "Average Cortical K2/F", "Average Medulla K2/F"
# )
# 
# # Ensure 'Variable' is a factor in the correct order
# custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
total_results <- total_results %>%
  group_by(Variable) %>%
  mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
  ungroup()

# Plot
dot_plot <- ggplot(total_results, aes(
  # y = reorder(gene, logFC),
  y = gene_ordered,
  x = logFC,
  color = color,
  size = abs(logFC)
)) +
  geom_point(alpha = 0.7) +
  facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
  scale_color_identity() +
  scale_size(range = c(2, 6), name = "|LogFC|") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(
    title = "Differentially Expressed ox phos Genes (Type 2 Diabetes)",
    subtitle = "PET Variables in dDCT Cells, Unadjusted (Pooled Offset)",
    x = "Log Fold Change",
    y = "Gene",
    caption = paste0(
      "FDR < 0.05, Genes = ", Genes,
      ", Nuclei = ", Nuclei
    )
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.y = element_text(size = 8),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks.x = element_line(color = "black"),
    panel.border = element_blank(),
    panel.background = element_blank()
  )

# Print the plot
dot_plot


png(fs::path(dir.results, "DotPlot_ox_phos_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D.png"), 
    width = 2500, height = 3000, res = 300)
print(dot_plot)
dev.off()
```
####b. Median
##### TCA Cycle 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dDCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- tca_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(tca_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_TCA_cycle_dDCT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "dDCT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

#Try diff plot
heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    limits = c(-1, 1),  # Adjust these values to suit your data
    oob = scales::squish,  # Squish out-of-bounds values
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "TCA Cycle Genes vs. PET Variables (Median)",
       subtitle = "dDCT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )
heat_map_p
# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()


```
##### Ox Phos
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dDCT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells
# With parallelization
#TCA Cycle
# List of genes
genes_list <- ox_phos_genes

k2_vars <- c("avg_c_k2_med","avg_m_k2_med","avg_c_f_med","avg_m_f_med","avg_c_k2_f_med","avg_m_k2_f_med")
total_results <- data.frame()
for (exposure in k2_vars) {
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_path[g, , drop = FALSE]
      meta_gene <- so_celltype@meta.data
      pred.formula <- as.formula(paste0("~",exposure))
      pred_gene <- model.matrix(pred.formula, data = meta_gene)
      # library <- meta_gene$library_size
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  PT_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
  
  #Make dataframe of final results
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- exposure
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(ox_phos_genes)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(ox_phos_genes)-length(nonconverge_genes))/length(ox_phos_genes))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  total_results <- rbind(total_results,full_results)
}

write.csv(total_results,fs::path(dir.results,"NEBULA_ox_phos_cycle_dDCT_cells_PET_Variables_unadjusted_pooled_offset_median.csv"))
# total_results <- read.csv(fs::path(dir.results,"NEBULA_ox_phos_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Variable, logFC, signif)

custom_order <- c("avg_c_k2_med", "avg_m_k2_med", "avg_c_f_med", "avg_m_f_med", "avg_c_k2_f_med", "avg_m_k2_f_med")
heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                   "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "Ox Phos Genes vs. PET Variables (Median)",
       subtitle = "dDCT (T2D)",
       x = "Exposure",
       y = "Gene") +
  scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_ox_phos_cycle_NEBULA_dDCT_PET_unadjusted_pooled_offset_T2D_median.png"), 
    width = 1500, height = 2000, res = 300)
print(heat_map_p)
dev.off()

# 
# total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$`logFC` > 0, "darkred",
#                              ifelse(total_results$fdr < 0.05 & total_results$`logFC` < 0, "#264653", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- total_results[total_results$fdr < 0.05, ]
# 
# Genes <- length(unique(total_results$gene))
# Nuclei <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # total_results$color3 <- ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 > 0, "lightcoral",
# #                               ifelse(total_results$fdr3 < 0.2 & total_results$`logFC`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- total_results[total_results$fdr3 < 0.2, ]
# 
# # Your custom facet labels
# # custom_labels <- c(
# #   "Average Cortical K2", "Average Medulla K2",
# #   "Average Cortical F", "Average Medulla F",
# #   "Average Cortical K2/F", "Average Medulla K2/F"
# # )
# # 
# # # Ensure 'Variable' is a factor in the correct order
# # custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
# # total_results$Variable <- factor(total_results$Variable, levels = custom_order, labels = custom_labels)
# total_results <- total_results %>%
#   group_by(Variable) %>%
#   mutate(gene_ordered = fct_reorder2(gene, Variable, logFC)) %>%
#   ungroup()
# 
# # Plot
# dot_plot <- ggplot(total_results, aes(
#   # y = reorder(gene, logFC),
#   y = gene_ordered,
#   x = logFC,
#   color = color,
#   size = abs(logFC)
# )) +
#   geom_point(alpha = 0.7) +
#   facet_wrap(~Variable, scales = "free_x",ncol=2) +  # allow each facet its own x-axis range
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +
#   labs(
#     title = "Differentially Expressed Ox Phos Genes among Youth with Type 2 Diabetes",
#     subtitle = "PET Variables in PT Cells, Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# 
# # Print the plot
# dot_plot
# 
# 
# png(fs::path(dir.results, "DotPlot_ox_phos_cycle_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 2500, height = 3000, res = 300)
# print(dot_plot)
# dev.off()
```

#C. Uncoupling Analysis
```{r}
signatures <- list(
  # UCP_signaling = c("UCP2", "UCP3"),
  UCP_signaling = c("UCP2"),
  ANT_complex = c("SLC25A4", "SLC25A5", "SLC25A6"),
  Metabolic_switch = c("PDK4", "PDK2", "PDK3"),
  Mitophagy = c("PINK1", "PRKN", "BNIP3", "BNIP3L", "FUNDC1"),
  Antioxidant = c("SOD2", "CAT",  "GPX4", "PRDX3"),
  OXPHOS_Complex_I = c("NDUFB2", "NDUFB3", "NDUFA9", "NDUFS1", "NDUFV1"),
  OXPHOS_Complex_II = c("SDHA", "SDHB", "SDHC", "SDHD"),
  OXPHOS_Complex_III = c("UQCR11", "UQCR10", "UQCRB", "UQCRC1"),
  OXPHOS_Complex_IV = c("COX7A2", "COX7B", "COX4I1", "COX5A", "COX6A1"),
  OXPHOS_Complex_V = c("ATP5F1A", "ATP5F1B", "ATP5F1C", "ATP5F1D", "ATP5F1E")
)

sig_genes <- c("UCP2", "UCP3","SLC25A4", "SLC25A5", "SLC25A6","PDK4", "PDK1", "PDK2", "PDK3","PINK1", "PRKN", "BNIP3", "BNIP3L", "FUNDC1","SOD2", "CAT", "GPX1", "GPX4", "PRDX3","NDUFB2", "NDUFB3", "NDUFA9", "NDUFS1", "NDUFV1","SDHA", "SDHB", "SDHC", "SDHD","UQCR11", "UQCR10", "UQCRB", "UQCRC1","COX7A2", "COX7B", "COX4I1", "COX5A", "COX6A1","ATP5F1A", "ATP5F1B", "ATP5F1C", "ATP5F1D", "ATP5F1E")
# "UCP3" "PDK1" "GPX1"

so_subset <- subset(so_kpmp_sc,features = sig_genes)
```

##a. PT Cells 
```{r}
#Filter to PT Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="PT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_PT_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "Proximal Tubule Cells",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```
###ii. Median Split

### ii. PT-S1/2
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S1/S2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_PT_S1_S2_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "PT-S1/S2",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_PT_S1_S2_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```

### iii. PT-S3
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="PT-S3")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 2:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_PT_S3_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "PT-S3",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_PT_S3_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```

### iv. aPT
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aPT")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_aPT_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "aPT",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_aPT_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```

###i. TAL
```{r}
#Filter to TAL Cells
rm(so_celltype)
so_celltype <- subset(so_subset,celltype2=="TAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 TAL cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_TAL_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_TAL_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "Proximal Tubule Cells",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_TAL_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```

###ii. C-TAL-1
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-1")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_C_TAL_1_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "C-TAL-1",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_C_TAL_1_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```

###iii. C-TAL-2
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="C-TAL-2")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_C_TAL_2_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "C-TAL-2",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_C_TAL_2_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```
### iv. dTAL
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="dTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_dTAL_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "dTAL",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_dTAL_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```
### v. aTAL
```{r}
#Filter to PT Cells
so_celltype <- subset(so_subset,KPMP_celltype=="aTAL")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
# so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")
k2_ids <- unique(so_celltype$kit_id[which(!is.na(so_celltype$avg_c_k2))])
so_celltype <- subset(so_celltype, kit_id %in% k2_ids)
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #34 genes
ncol(so_celltype) #4926 PT cells

counts_path <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# signatures[1] <- "UCP2"
# signatures[3] <- c("PDK4","PDK2","PDK3")
# With parallelization
for (i in 1:length(signatures)) {
  genes_list <- signatures[[i]]
  pathway <- names(signatures[i])
  
  k2_vars <- c("avg_c_k2","avg_m_k2","avg_c_f","avg_m_f","avg_c_k2_f","avg_m_k2_f")
  total_results <- data.frame()
  for (exposure in k2_vars) {
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_path[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        pred.formula <- as.formula(paste0("~",exposure))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        # library <- meta_gene$library_size
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        list(gene = g, summary = NA, overdispersion = NA, convergence = NA, algorithm = NA, covariance = NA, random_effect = NA)
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    PT_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 
    
    #Make dataframe of final results
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- exposure
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(tca_genes)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(tca_genes)-length(nonconverge_genes))/length(tca_genes))*100,3),"%")
    # nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    total_results <- rbind(total_results,full_results)
  }
  
  write.csv(total_results,fs::path(dir.results,paste0("NEBULA_",pathway,"_genes_aTAL_cells_PET_Variables_unadjusted_pooled_offset.csv")))
  # total_results <- read.csv(fs::path(dir.results,"NEBULA_TCA_cycle_PT_cells_PET_Variables_unadjusted_pooled_offset.csv"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, Variable, logFC, signif)
  
  custom_order <- c("avg_c_k2", "avg_m_k2", "avg_c_f", "avg_m_f", "avg_c_k2_f", "avg_m_k2_f")
  heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
  custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
                     "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = paste0(str_replace_all(pathway,"_"," ")," Genes vs. PET Variables (T2D)"),
         subtitle = "aTAL",
         x = exposure,
         y = "Gene") +
    scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_",pathway,"_genes_NEBULA_aTAL_PET_unadjusted_pooled_offset_T2D.png")), 
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
  
}
```
