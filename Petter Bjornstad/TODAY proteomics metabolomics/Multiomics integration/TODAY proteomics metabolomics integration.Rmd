---
title: "TODAY proteomics and metabolomics integration"
author: "Laura Pyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
library(SomaDataIO)
library(limma)
library(dplyr)
library(caret)
library(purrr)
library(multtest)
library(openxlsx)
library(tableone)
library(EnhancedVolcano)
library(knitr)
library(survival)
library(broom)
library(emmeans)
library(ggvenn)
library(mixOmics)

knitr::opts_chunk$set(echo = FALSE,warning = FALSE)

knitr::opts_chunk$set(echo = FALSE)
if(Sys.info()["sysname"] == "Windows"){
  home_dir = "E:/Petter Bjornstad/TODAY subaward"
} else if (Sys.info()["sysname"] == "Linux"){
  home_dir = "~/UCD/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/TODAY subaward/"
} else if (Sys.info()["sysname"] == "Darwin"){
  home_dir = "/Volumes/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/TODAY subaward"
}
knitr::opts_knit$set(root.dir = home_dir)
```

```{r, include=FALSE}
setwd(home_dir)
# load somalogic data, with QC samples already excluded
load("./Somalogic data raw/soma.Rdata")

# load analyte info
load("./Somalogic data raw/analytes.Rdata")

# load comorbidity data
load("./Clinical data/comorb.Rdata")

# load baseline risk factors
load("./Clinical data/TODAY/baserisk.Rdata")

# take only the baseline soma samples
# can we just take the earliest or is it possible someone would have a follow-up sample but not baseline?
# probably can take the first and then check the years to make sure compatible with TODAY
base <- soma %>% arrange(releaseid,Date.Drawn) %>% dplyr::group_by(releaseid) %>% dplyr::filter(row_number()==1)
# these 3 release IDs have first sample after end of recruitment, so they must be missing the baseline visit
base <- base %>% filter(!releaseid %in% c("65-85903","65-47984","65-25901"))

# the above section of code used to work but seems to have broken....this should accomplish the same thing?
#base <- soma %>% filter(visit==1)

# merge in complication data
base <- left_join(base, comorb, by="releaseid")
# this was previously:
# base <- merge(base, comorb, by="releaseid",all.x=T, all.y=F)

# merge in baseline risk factors
base <- left_join(base, baserisk, by="releaseid")
# this was previously:
#base <- merge(base, baserisk, by="releaseid",all.x=T, all.y=F)

# log transform UAlbCreat
base$log_UAlbCreat <- log(base$UAlbCreat + 0.0000001)

# identify columns corresponding to proteins
#is_seq <- function(.x) grepl("^seq\\.[0-9]{4}", .x) # regex for analytes
is_seq <- function(.x) grepl("seq", .x)
seq <- is_seq(names(base))

# convert to numeric
base[,seq] <- apply(base[,seq],2,as.numeric)

# are there proteins with low variability?
no_var = caret::nearZeroVar(base[,seq])
# none

# log transform
base_log <- base %>% modify_if(is_seq(names(.)), log)

# will log transform but not scale - there is a scale option in the mixOmics function
# scale by SD
#base_log_scale <- base_log
#predictors <- colnames(base_log[seq])
#for (i in 1:length(predictors)) {
#  base_log_scale[,paste0(predictors[i])] <- base_log_scale[,paste0(predictors[i])]/sd(unlist(base_log[,paste0(predictors[i])]))
#}

# read in urine metabolomics
load("./Metabolomic data/urine.Rdata")
urine$Date.Drawn <- as.Date(urine$Date.Drawn,format = "%m/%d/%Y")
urine <- urine %>% arrange(releaseid,Date.Drawn) %>% group_by(releaseid) %>% filter(row_number()==1)
check_urine_vars <- function(.x) grepl("nM/mM", .x)
urine_keep <- check_urine_vars(names(urine))
urine_final <- cbind(urine$releaseid, urine[urine_keep])
urine_final[,2:ncol(urine_final)] <- log(urine_final[,2:ncol(urine_final)]) 
colnames(urine_final) <- c("releaseid",colnames(urine_final[,2:ncol(urine_final)]))

# read in plasma metabolomics
load("./Metabolomic data/plasma.Rdata")
plasma$Date.Drawn <- as.Date(plasma$Date.Drawn,format = "%m/%d/%Y")
plasma <- plasma %>% arrange(releaseid,Date.Drawn) %>% group_by(releaseid) %>% filter(row_number()==1)
check_plasma_vars <- function(.x) grepl("uM", .x)
plasma_keep <- check_plasma_vars(names(plasma))
plasma_final <- cbind(plasma$releaseid, plasma[plasma_keep])
plasma_final[,2:ncol(plasma_final)] <- log(plasma_final[,2:ncol(plasma_final)]) 
colnames(plasma_final) <- c("releaseid",colnames(plasma_final[,2:ncol(plasma_final)]))

# keep those with complete data
# there are a few people with metabolomics but not proteomics
urine_final <- urine_final %>% filter(releaseid %in% base_log$releaseid)
plasma_final <- plasma_final %>% filter(releaseid %in% base_log$releaseid)
comorb <- comorb %>% filter(releaseid %in% base_log$releaseid)
urine_final <- urine_final %>% arrange(releaseid)
plasma_final <- plasma_final %>% arrange(releaseid)
comorb <- comorb %>% arrange(releaseid)
proteins <- base_log %>% arrange(releaseid)
proteins <- cbind(base_log$releaseid, base_log[,seq])
urine_final$releaseid <- NULL
plasma_final$releaseid <- NULL
proteins$`base_log$releaseid` <- NULL

# store predictor data in lists
X <- list(proteins = proteins, urine_metabolites = urine_final, plasma_metabolites = plasma_final)
# store outcome data as Y
Y_albuminuria <- comorb$MIC.OR.MAC
Y_glycemia <- comorb$GLYC

```

# Albuminuria

## Quick model

```{r}
# First just a quick model to see if this works 
# This is not a sparse model, no variable selection performed
diablo.albuminuria.quick <- block.plsda(X, Y_albuminuria, near.zero.var = TRUE)
plotIndiv(diablo.albuminuria.quick)
plotVar(diablo.albuminuria.quick)
```

## Optimized model

### Examine number of components to retain

```{r}
# Create design matrix - weights of 1 favor extraction of correlation structure,
# while weights closer to 0 favor prediction
design <- matrix(0.1, ncol = length(X), nrow = length(X),
                 dimnames = list(names(X), names(X)))
diag(design) <- 0

# examine the number of components
# first fit a model without variable selection
diablo.albuminuria.comp <- block.plsda(X, Y_albuminuria, near.zero.var = TRUE, ncomp = 5, design = design)
perf.diablo.albuminuria.comp <- perf(diablo.albuminuria.comp, validation = "Mfold", folds = 5, nrepeat = 5)
plot(perf.diablo.albuminuria.comp)
# 2 components seems sufficient

# output optimal number of components according to prediction distance and type of error rate
perf.diablo.albuminuria.comp$choice.ncomp$WeightedVote
ncomp <- perf.diablo.albuminuria.comp$choice.ncomp$WeightedVote["Overall.ER", "max.dist"]

# choose optimal number of variables in each dataset
set.seed(3654)
test.keepX <- list(proteins = c(1:9, seq(10, 25, 5)),
                   urine_metabolites = c(1:9, seq(10, 25, 5)),
                    urine_metabolites = c(1:9, seq(10, 25, 5)))
#tune.diablo.albuminuria <- tune.block.splsda(X, Y_albuminuria, ncomp = 2,
#                                             test.keepX = test.keepX, design = design,
#                                             validation = "Mfold", folds = 5, nrepeat = 5,
#                                             dist = "max.dist", near.zero.var = TRUE)
#list.keepX <- tune.diablo.albuminuria$choice.keepX
list.keepX <- list(proteins = c(25,25),
                   urine_metabolites = c(1,20),
                    plasma_metabolites = c(1,25))
list.keepX

#> list.keepX
#$proteins
#[1] 25 25
#$urine_metabolites
#[1]  1 20
#$plasma_metabolites
#[1]  1 25

# final model
diablo.albuminuria <- block.splsda(X, Y_albuminuria, ncomp = ncomp, keepX = list.keepX,
                                   design = design, near.zero.var = TRUE)
vars.albuminuria.proteins1 <- as.data.frame(selectVar(diablo.albuminuria, block = "proteins", comp = 1))
vars.albuminuria.proteins1$AptName <- vars.albuminuria.proteins1$proteins.name
vars.albuminuria.proteins2 <- as.data.frame(selectVar(diablo.albuminuria, block = "proteins", comp = 2))
vars.albuminuria.proteins2$AptName <- vars.albuminuria.proteins2$proteins.name
seq.to.prot <- analytes %>% dplyr::select(AptName,TargetFullName,Target)
vars.albuminuria.proteins1 <- merge(vars.albuminuria.proteins1, seq.to.prot, by = "AptName")
vars.albuminuria.proteins2 <- merge(vars.albuminuria.proteins2, seq.to.prot, by = "AptName")
vars.albuminuria.urine1 <- as.data.frame(selectVar(diablo.albuminuria, block = "urine_metabolites", comp = 1))
vars.albuminuria.urine2 <- as.data.frame(selectVar(diablo.albuminuria, block = "urine_metabolites", comp = 2))
vars.albuminuria.plasma1 <- as.data.frame(selectVar(diablo.albuminuria, block = "plasma_metabolites", comp = 1))
vars.albuminuria.plasma2 <- as.data.frame(selectVar(diablo.albuminuria, block = "plasma_metabolites", comp = 2))

plotDiablo(diablo.albuminuria, ncomp = 1)
plotIndiv(diablo.albuminuria, legend = TRUE, ind.names = FALSE)
plotVar(diablo.albuminuria, var.names= FALSE, style= 'graphics', 
        legend = TRUE, pch = c(16, 17, 15), cex = c(2,2,2), 
        col= c('darkorchid', 'brown1', 'lightgreen'), title= 'TCGA, DIABLO comp 1 - 2')
circosPlot(diablo.albuminuria, cutoff = 0.7, line = TRUE, 
           color.blocks = c('darkorchid','brown1','lightgreen'),
           color.cor = c("chocolate3",'grey20'), size.labels = 1.5, size.variables = 0.3)
#network(diablo.albuminuria, blocks = c(1,2,3), cutoff = 0.3,
#        color.node = c('darkorchid','brown1','lightgreen'),
#        save = "pdf", name.save = "/Volumes/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/TODAY #subaward/Multiomics integration/DIABLO/Plots/network_albuminuria.pdf")
plotLoadings(diablo.albuminuria, comp = 1, contrib = "max", method = "median")

cimDiablo(diablo.albuminuria, color.blocks = c('darkorchid','brown1','lightgreen'),
          comp = 1, legend.position = "right", save = "png",
          name.save = '/Volumes/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/TODAY subaward/Multiomics integration/DIABLO/Plots/cim_albuminuria')

perf.diablo.albuminuria <- perf(diablo.albuminuria, validation = 'Mfold', folds = 5, 
                                nrepeat = 1, dist = "max.dist")
perf.diablo.albuminuria$MajorityVote.error.rate
perf.diablo.albuminuria$WeightedVote.error.rate
auc.diablo.albuminuria.proteins <- auroc(diablo.albuminuria, roc.block = "proteins", roc.comp = 2)
auc.diablo.albuminuria.urine <- auroc(diablo.albuminuria, roc.block = "urine_metabolites", roc.comp = 2)
auc.diablo.albuminuria.plasma <- auroc(diablo.albuminuria, roc.block = "plasma_metabolites", roc.comp = 2)
```
