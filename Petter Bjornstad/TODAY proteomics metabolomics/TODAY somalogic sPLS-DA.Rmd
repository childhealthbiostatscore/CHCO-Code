---
title: "TODAY Somalogic baseline analyses"
author: "Laura Pyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    number_sections: yes
    theme: readable
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
library(SomaDataIO)
library(limma)
library(dplyr)
library(caret)
library(purrr)
library(multtest)
library(openxlsx)
library(tableone)
library(EnhancedVolcano)
library(knitr)
library(survival)
library(broom)
library(mixOmics)

knitr::opts_chunk$set(echo = FALSE,warning = FALSE)

knitr::opts_chunk$set(echo = FALSE)
if(Sys.info()["sysname"] == "Windows"){
  home_dir = "E:/Petter Bjornstad/TODAY subaward"
} else if (Sys.info()["sysname"] == "Linux"){
  home_dir = "~/UCD/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/TODAY subaward/"
} else if (Sys.info()["sysname"] == "Darwin"){
  home_dir = ""
}
knitr::opts_knit$set(root.dir = home_dir)
```

```{r, include=FALSE}
# load somalogic data, with QC samples already excluded
load("./Somalogic data raw/soma.Rdata")

# load analyte info
load("./Somalogic data raw/analytes.Rdata")

# load comorbidity data
load("./Clinical data/comorb.Rdata")

# take only the baseline soma samples
# can we just take the earliest or is it possible someone would have a follow-up sample but not baseline?
# probably can take the first and then check the years to make sure compatible with TODAY
base <- soma %>% arrange(releaseid,Date.Drawn) %>% group_by(releaseid) %>% filter(row_number()==1)

# these 3 release IDs have first sample after end of recruitment, so they must be missing the baseline visit
base <- base %>% filter(!releaseid %in% c("65-85903","65-47984","65-25901"))

# merge in nephropathy data
base <- merge(base, comorb, by="releaseid",all.x=T, all.y=F)

# identify columns corresponding to proteins
#is_seq <- function(.x) grepl("^seq\\.[0-9]{4}", .x) # regex for analytes
is_seq <- function(.x) grepl("seq", .x)
seq <- is_seq(names(base))

# convert to numeric
base[,seq] <- apply(base[,seq],2,as.numeric)

# are there proteins with low variability?
no_var = caret::nearZeroVar(base[,seq])
# none

# log transform
base_log <- base %>% modify_if(is_seq(names(.)), log)

```

# Results

## Microalbuminuria

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log$MIC
X <- base_log[,seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by microalbuminuria status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$MIC),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")

```

## Macroalbuminuria

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log$MAC
X <- base_log[,seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by macroalbuminuria status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$MAC),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```

## Hyperfiltration

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log[!is.na(base_log$HYP),]$HYP
X <- base_log[!is.na(base_log$HYP),seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by hyperfiltration status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$HYP),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```

## Rapid eGFR decline

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log[!is.na(base_log$RAPID),]$RAPID
X <- base_log[!is.na(base_log$RAPID),seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by rapid eGFR decline status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$RAPID),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```

## Hypertension

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log$HTN
X <- base_log[,seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by hypertension status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$HTN),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```

## Neuropathy

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log$NEURO
X <- base_log[,seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by neuropathy status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$NEURO),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```

## Retinopathy

```{r echo=FALSE, include=TRUE, cache=TRUE}
Y <- base_log[!is.na(base_log$RETINO),]$RETINO
X <- base_log[!is.na(base_log$RETINO),seq]
tune.splsda <- tune.splsda(X, Y, ncomp = 5) 
choice.keepX <- tune.splsda$choice.keepX[1:2] 
## sPLS-DA function
splsda.utm <- splsda(X, Y, ncomp = 2, keepX = choice.keepX)
plotIndiv(splsda.utm,title = "sPLS-DA by retinopathy status",
          pch = 20,ind.names = F,ellipse = T,legend = T)

top_1 <- selectVar(splsda.utm,comp=1)
top_2 <- selectVar(splsda.utm,comp=2)
top_1d <- data.frame(top_1$value)
top_1d$AptName <- row.names(top_1d)
top_1d <- merge(top_1d,analytes,by="AptName",all.x = T, all.y = F)
top_1d <- top_1d[order(-abs(top_1d$value.var)),] 
top_2d <- data.frame(top_2$value)
top_2d$AptName <- row.names(top_2d)
top_2d <- merge(top_2d,analytes,by="AptName",all.x = T, all.y = F)
top_2d <- top_2d[order(-abs(top_2d$value.var)),] 
top_1d
top_2d

set.seed(3654)
plsda.perf = perf(splsda.utm,validation = "Mfold",folds = 5,auc = T)
auc_true <- as.numeric(plsda.perf$auc$comp1[1])
# Permutation testing - takes forever (even in parallel), make sure to cache
n_perm <- 1000
cl = makeForkCluster(detectCores()*0.5)
aucs = parSapply(cl,1:n_perm, function(i){
  Y <- sample(as.factor(base_log$RETINO),replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda = perf(plsda_res,validation = "Mfold",folds = 5,auc = T)
  return(as.numeric(perf_plsda$auc$comp1[1]))
})
stopCluster(cl)
ggplot(as.data.frame(aucs),aes(x=aucs)) +
  geom_histogram(bins = 10) +
  geom_vline(aes(xintercept=auc_true),color="red") +
  theme_bw() + xlab("AUC")
```