---
title: "Liver Proteomics"
author: "Hailey E. Hampson"
date: "2025-11-29"
output: html_document
---

# 1. Set up Libraries & Directores
```{r libraries, echo=F, include = F}
#Load Libraries
library(reticulate)
use_python("/home/hhampson/miniconda3/bin/python", required = TRUE)
source("Lambda_Libraries_Liver_Proteomics.R")

#Load functions
source("Lambda_Liver_Proteomics_Functions.R")
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")

# install.packages("PGEE")
library(PGEE)
# install.packages("glmnet")
library(glmnet)
library(lme4)
library(lmerTest)  # For p-values in mixed models
library(dplyr)

```


# 2. Set up Cyberduck to load data
```{r, Cyberduck setup}
## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/home/hhampson/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")

```

#3. TODAY
## a. Load Data & Format
```{r}
#Load in Proteomics in Today - baseline and follow up & alt ast
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "today_proteomics_longitudinal_log2.rds", temp_file)
prot <- readRDS(temp_file)
gc()

# which(colnames(prot)=="AGEBASE") #7406
# which(colnames(prot)=="releaseid") #7326
# which(colnames(prot)=="sex") #7399
# which(colnames(prot)=="time")  #na
# which(colnames(prot)=="visit") #7334
# prot <- prot[c(7334,7326,7406,7399,which(grepl("seq.",colnames(prot))))] #length(unique(prot$releaseid)) - 376 unique ids
proteins <- colnames(prot)[which(grepl("seq.",colnames(prot)))] #7728 aptamers

#Participants with proteomics
prot_IDs <- unique(prot$releaseid)

#Load gene protein key
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".RDS") # need to create a temporary file
s3$download_file(bucket, "analytes.RDS", temp_file)
analytes <- readRDS(temp_file)
gc()
analytes <- analytes %>% 
  dplyr::select(all_of(c("AptName","EntrezGeneSymbol"))) #7288 aptamers


#Load ALT/AST longitudinal data
#Need to figure out which timeponts we have ALT/AST for and where that data is and then merge it into prot dataframe. 
#Proteins at baseline & 10 years
#ALT/AST at baseline & additional timepoints up to 10 years?

#Research Question: Or impact of change ALT/AST levels on changing proteins over time?Impact of protein changes on ALT/AST Changes over time? 

#Baseline - M00
#Year 10 - P120

#Spaghetti plot of peoples ALT and AST trajectories over time - pick a trajectory type (linear,sline, quadradic) 
#Then get a slope for each pewrsons ALT trajectory
#Slope variable ALT/AST - single value as the outcome
#longitudinal proteins for the PGEE 
#Load in ALT/AST data
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".RDS") # need to create a temporary file
s3$download_file(bucket, "clinical_data_long.RDS", temp_file)
clinical <- readRDS(temp_file)
gc()

```
##b. Explore the Data 
```{r}
#Select only those with proteomics
clinical <- clinical %>% 
  filter(releaseid %in% prot_IDs)
#Order of visits 
clinical$visit <- as.factor(clinical$visit)
unique(clinical$releaseid)

#ALT
alt <- ggplot(clinical,aes(x=visit,y=alt,color=releaseid))+
  # Individual trajectories (spaghetti lines)
  geom_line(aes(group = releaseid), alpha = 0.2) +
  # Mean line
  stat_summary(aes(group = 1), fun = median, geom = "line", 
               color = "grey2", linewidth = 1) +
  labs(x = "Visit",
       y = "ALT (U/L)",
       title = "Longitudinal ALT Trajectories",
       subtitle = "Median ALT Levels (Black Line)")+
  # Vertical lines
  geom_vline(xintercept = "P027", linetype = "dashed", 
             color = "blue", linewidth = 1) +
  geom_vline(xintercept = "M00", linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  geom_vline(xintercept = "P120", linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  # Labels for vertical lines
  annotate("text", x = "P027", y = Inf, label = "Start of TODAY2", 
           vjust = 1.5, hjust = -0.1, color = "blue", size = 3, angle = 0) +
  annotate("text", x = "M00", y = Inf, label = "Baseline\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  annotate("text", x = "P120", y = Inf, label = "Follow-Up\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

#AST
ast <- ggplot(clinical,aes(x=visit,y=ast,color=releaseid))+
  # Individual trajectories (spaghetti lines)
  geom_line(aes(group = releaseid), alpha = 0.2) +
  # Mean line
  stat_summary(aes(group = 1), fun = median, geom = "line", 
               color = "grey2", linewidth = 1) +
  labs(x = "Visit",
       y = "ALT (U/L)",
       title = "Longitudinal AST Trajectories in TODAY & TODAY2",
       subtitle = "Median AST Levels (Black Line)")+
  # Vertical lines
  geom_vline(xintercept = "P027", linetype = "dashed", 
             color = "blue", linewidth = 1) +
  geom_vline(xintercept = "M00", linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  geom_vline(xintercept = "P120", linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  # Labels for vertical lines
  annotate("text", x = "P027", y = Inf, label = "Start of TODAY2", 
           vjust = 1.5, hjust = -0.1, color = "blue", size = 3, angle = 0) +
  annotate("text", x = "M00", y = Inf, label = "Baseline\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  annotate("text", x = "P120", y = Inf, label = "Follow-Up\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
plot <- alt/ast
png("/home/hhampson/Results/ALT_AST_Overtime_TODAY.png",res=300,width=3050,height=2100)
print(plot)
dev.off()

#Visit -> Numeric variable
clinical$visit_num
# clinical$visit_numeric <- as.numeric(clinical$visit)

#ALT
alt <- ggplot(clinical,aes(x=visit_num,y=alt,color=releaseid))+
  # Individual trajectories (spaghetti lines)
  geom_line(aes(group = releaseid), alpha = 0.2) +
  # Mean line
  stat_summary(aes(group = 1), fun = median, geom = "line", 
               color = "grey2", linewidth = 1) +
  labs(x = "Visit (Months)",
       y = "ALT (U/L)",
       title = "Longitudinal ALT Trajectories",
       subtitle = "Median ALT Levels (Black Line)")+
  # Vertical lines
  geom_vline(xintercept =  27, linetype = "dashed", 
             color = "blue", linewidth = 1) +
  geom_vline(xintercept = 0, linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  geom_vline(xintercept = 60, linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  # Labels for vertical lines
  annotate("text", x = 27, y = Inf, label = "Start of TODAY2", 
           vjust = 1.5, hjust = -0.1, color = "blue", size = 3, angle = 0) +
  annotate("text", x = 0, y = Inf, label = "Baseline\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  annotate("text", x = 60, y = Inf, label = "Follow-Up\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

#AST
ast <- ggplot(clinical,aes(x=visit_num,y=ast,color=releaseid))+
  # Individual trajectories (spaghetti lines)
  geom_line(aes(group = releaseid), alpha = 0.2) +
  # Mean line
  stat_summary(aes(group = 1), fun = median, geom = "line", 
               color = "grey2", linewidth = 1) +
  labs(x = "Visit (Months)",
       y = "ALT (U/L)",
       title = "Longitudinal AST Trajectories in TODAY & TODAY2",
       subtitle = "Median AST Levels (Black Line)")+
  # Vertical lines
  geom_vline(xintercept =  27, linetype = "dashed", 
             color = "blue", linewidth = 1) +
  geom_vline(xintercept = 0, linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  geom_vline(xintercept = 60, linetype = "dashed", 
             color = "grey50", linewidth = 0.8) +
  # Labels for vertical lines
  annotate("text", x = 27, y = Inf, label = "Start of TODAY2", 
           vjust = 1.5, hjust = -0.1, color = "blue", size = 3, angle = 0) +
  annotate("text", x = 0, y = Inf, label = "Baseline\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  annotate("text", x = 60, y = Inf, label = "Follow-Up\nProteomics", 
           vjust = 1.2, hjust = -0.1, color = "grey30", size = 3, angle = 0) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
plot <- alt/ast
png("/home/hhampson/Results/ALT_AST_Overtime_TODAY_Months.png",res=300,width=3050,height=2100)
print(plot)
dev.off()
```
##c. Prepare Data for Analysis
```{r}

# Calculate all three summary measures for each person
individual_summaries <- clinical %>%
  group_by(releaseid) %>%
  filter(n() >= 2) %>%  # Need at least 3 visits for meaningful summaries, keep one person with only 2 for now (ID: 65-84560)
  summarise(
    # 1. MEAN SUMMARY - overall ALT/AST level
    mean_alt = mean(alt, na.rm = TRUE),
    mean_ast = mean(ast, na.rm = TRUE),
    
    # 2. VARIABILITY SUMMARY - within-person SD
    sd_alt = sd(alt, na.rm = TRUE),
    sd_ast = sd(ast, na.rm = TRUE),
    
    # Number of visits used
    n_visits = n()
  ) %>%
  ungroup() #N = 379 

# 3. SLOPE TRAJECTORY - fit linear model for each person
individual_slopes <- clinical %>%
  group_by(releaseid) %>%
  filter(n() >= 2) %>%
  do({
    # Fit linear models
    alt_model <- lm(alt ~ visit_num, data = .)
    ast_model <- lm(ast ~ visit_num, data = .)
    
    data.frame(
      releaseid = unique(.$releaseid),
      alt_slope = coef(alt_model)[2],
      alt_intercept = coef(alt_model)[1],
      alt_r_squared = summary(alt_model)$r.squared,
      ast_slope = coef(ast_model)[2],
      ast_intercept = coef(ast_model)[1],
      ast_r_squared = summary(ast_model)$r.squared
    )
  }) %>%
  ungroup()

# Combine all summaries into one dataset
all_summaries <- individual_summaries %>%
  left_join(individual_slopes, by = "releaseid")

# Check the results
head(all_summaries)
summary(all_summaries)

#Prepare change in proteomics
# Get baseline proteomics (M00)
proteomics_baseline <- prot %>%
  filter(visit == 1) %>%
  dplyr::select(-visit) %>% 
  dplyr::select(c("releaseid",starts_with("seq.")))

# Get follow-up proteomics (P120)
proteomics_followup <- prot %>%
  filter(visit == 2) %>%
  dplyr::select(-visit) %>% 
  dplyr::select(c("releaseid",starts_with("seq.")))

# Calculate protein CHANGES (P120 - M00)
proteomics_change <- proteomics_baseline %>%
  inner_join(proteomics_followup, by = "releaseid", suffix = c("_baseline", "_followup")) %>%
  mutate(across(starts_with("seq.") & ends_with("_baseline"), 
                ~get(sub("_baseline", "_followup", cur_column())) - .x,
                .names = "{sub('_baseline', '_change', .col)}")) %>%
  # Keep only the change variables
  dplyr::select(releaseid, ends_with("_change"))

# Combine baseline + change proteomics
proteomics_full <- proteomics_baseline %>%
  inner_join(proteomics_change, by = "releaseid")
# Now you have: seq.XXXX (baseline) and seq.XXXX_change for each protein

# Now merge with change in proteomics for analysis
analysis_data <- proteomics_full %>%
  inner_join(all_summaries, by = "releaseid")

```
##d. Analysis #1 - Summary Values
###i. Prepare Datasets
```{r}
# Identify protein column names
baseline_proteins <- proteins #7288, number of baseline proteins
change_proteins <- paste0(baseline_proteins, "_change")  # seq.XXXX_change

# Define outcome columns
outcomes <- c("mean_alt", "sd_alt", "alt_slope", 
              "mean_ast", "sd_ast", "ast_slope", "n_visits",
              "alt_intercept", "alt_r_squared",
              "ast_intercept", "ast_r_squared")

# Analysis A: Baseline proteins only
data_baseline <- analysis_data %>%
  dplyr::select(releaseid, all_of(outcomes), all_of(baseline_proteins))

# Analysis B: Protein changes only
data_change <- analysis_data %>%
  dplyr::select(releaseid, all_of(outcomes), all_of(change_proteins))

# Analysis C: Combined (baseline + change)
data_combined <- analysis_data %>%
  dplyr::select(releaseid, all_of(outcomes), all_of(baseline_proteins), all_of(change_proteins))

# Summary
cat("\nDataset dimensions:\n")
cat("Analysis A (baseline proteins):", nrow(data_baseline), "people x", 
    length(baseline_proteins), "proteins\n")
#Analysis A (baseline proteins): 265 people x 7288 proteins
cat("Analysis B (protein changes):", nrow(data_change), "people x", 
    length(change_proteins), "protein changes\n")
#Analysis B (protein changes): 265 people x 7288 protein changes
cat("Analysis C (combined):", nrow(data_combined), "people x", 
    length(baseline_proteins) + length(change_proteins), "total features\n")
#Analysis C (combined): 265 people x 14576 total features

```
###ii. Feature Selection - Elastic Net
```{r}
# Function to run elastic net feature selection
run_elastic_net <- function(data, outcome_var, protein_cols, alpha = 0.5, seed = 123) {
  
  # Prepare data
  X <- as.matrix(data[, protein_cols])
  y <- data[[outcome_var]]
  
  # Remove any rows with missing outcome
  complete_cases <- complete.cases(y)
  X <- X[complete_cases, ]
  y <- y[complete_cases]
  
  cat("\n===", outcome_var, "===\n")
  cat("Sample size:", length(y), "\n")
  cat("Number of predictors:", ncol(X), "\n")
  
  # Run cross-validated elastic net
  set.seed(seed)
  cv_fit <- cv.glmnet(X, y, 
                      alpha = alpha,  # 0.5 = elastic net
                      nfolds = 10,
                      standardize = TRUE)
  
  # Extract coefficients at lambda.min (best CV performance)
  coef_min <- coef(cv_fit, s = "lambda.min")
  selected_min <- rownames(coef_min)[coef_min[,1] != 0][-1]  # Remove intercept
  
  # Extract coefficients at lambda.1se (more regularized, more stable)
  coef_1se <- coef(cv_fit, s = "lambda.1se")
  selected_1se <- rownames(coef_1se)[coef_1se[,1] != 0][-1]  # Remove intercept
  
  cat("Selected proteins (lambda.min):", length(selected_min), "\n")
  cat("Selected proteins (lambda.1se):", length(selected_1se), "\n")
  
  # Performance metrics
  r2_min <- cv_fit$glmnet.fit$dev.ratio[which(cv_fit$glmnet.fit$lambda == cv_fit$lambda.min)]
  r2_1se <- cv_fit$glmnet.fit$dev.ratio[which(cv_fit$glmnet.fit$lambda == cv_fit$lambda.1se)]
  
  cat("R-squared (lambda.min):", round(r2_min, 3), "\n")
  cat("R-squared (lambda.1se):", round(r2_1se, 3), "\n")
  
  # Return results
  list(
    cv_fit = cv_fit,
    selected_proteins_min = selected_min,
    selected_proteins_1se = selected_1se,
    coefficients_min = coef_min[coef_min[,1] != 0, ],
    coefficients_1se = coef_1se[coef_1se[,1] != 0, ],
    r2_min = r2_min,
    r2_1se = r2_1se,
    n_samples = length(y),
    outcome = outcome_var
  )
}

# Outcomes to test (start with main 6)
outcomes_to_test <- c("mean_alt", "sd_alt", "alt_slope", 
                      "mean_ast", "sd_ast", "ast_slope")

# Storage for results
results_baseline <- list()
results_change <- list()
results_combined <- list()

# Analysis A: Baseline proteins
cat("\n#############################################\n")
cat("ANALYSIS A: BASELINE PROTEINS\n")
cat("#############################################\n")

for(outcome in outcomes_to_test) {
  results_baseline[[outcome]] <- run_elastic_net(
    data = data_baseline,
    outcome_var = outcome,
    protein_cols = baseline_proteins,
    alpha = 0.5  # elastic net
  )
}

# Analysis B: Protein changes
cat("\n#############################################\n")
cat("ANALYSIS B: PROTEIN CHANGES\n")
cat("#############################################\n")

for(outcome in outcomes_to_test) {
  results_change[[outcome]] <- run_elastic_net(
    data = data_change,
    outcome_var = outcome,
    protein_cols = change_proteins,
    alpha = 0.5
  )
}

# Analysis C: Combined (baseline + change)
cat("\n#############################################\n")
cat("ANALYSIS C: COMBINED (BASELINE + CHANGE)\n")
cat("#############################################\n")

for(outcome in outcomes_to_test) {
  results_combined[[outcome]] <- run_elastic_net(
    data = data_combined,
    outcome_var = outcome,
    protein_cols = c(baseline_proteins, change_proteins),
    alpha = 0.5
  )
}

# Create summary table (using lambda.min results only)
summary_table <- data.frame()

for(outcome in outcomes_to_test) {
  summary_table <- rbind(summary_table,
                         data.frame(
                           outcome = outcome,
                           analysis = "Baseline",
                           n_proteins = length(results_baseline[[outcome]]$selected_proteins_min),
                           r2 = results_baseline[[outcome]]$r2_min
                         ),
                         data.frame(
                           outcome = outcome,
                           analysis = "Change",
                           n_proteins = length(results_change[[outcome]]$selected_proteins_min),
                           r2 = results_change[[outcome]]$r2_min
                         ),
                         data.frame(
                           outcome = outcome,
                           analysis = "Combined",
                           n_proteins = length(results_combined[[outcome]]$selected_proteins_min),
                           r2 = results_combined[[outcome]]$r2_min
                         )
  )
}

# View summary
print(summary_table)

# 1. Bar plot: Number of proteins selected
summary_table %>%
  mutate(outcome_type = ifelse(grepl("alt", outcome), "ALT", "AST"),
         outcome = factor(outcome, levels = c("mean_alt", "sd_alt", "alt_slope", 
                                              "mean_ast", "sd_ast", "ast_slope"))) %>%
  ggplot(aes(x = outcome, y = n_proteins, fill = analysis)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", linewidth = 0.3) +
  geom_text(aes(label = n_proteins), position = position_dodge(width = 0.9), 
            vjust = -0.5, size = 3) +
  facet_wrap(~outcome_type, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  labs(x = "Outcome", 
       y = "Number of Selected Proteins",
       title = "Protein Selection Across Analysis Types",
       fill = "Analysis") +
  scale_fill_manual(values = c("Baseline" = "#E69F00", 
                               "Change" = "#56B4E9", 
                               "Combined" = "#009E73"))

ggsave("~/Results/n_proteins_selected.png", width = 10, height = 6, dpi = 300)

# 2. Bar plot: R-squared performance
summary_table %>%
  mutate(outcome_type = ifelse(grepl("alt", outcome), "ALT", "AST"),
         outcome = factor(outcome, levels = c("mean_alt", "sd_alt", "alt_slope", 
                                              "mean_ast", "sd_ast", "ast_slope"))) %>%
  ggplot(aes(x = outcome, y = r2, fill = analysis)) +
  geom_bar(stat = "identity", position = "dodge", color = "black", linewidth = 0.3) +
  geom_text(aes(label = round(r2, 2)), position = position_dodge(width = 0.9), 
            vjust = -0.5, size = 3) +
  facet_wrap(~outcome_type, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  labs(x = "Outcome", 
       y = "R-squared",
       title = "Prediction Performance Across Analysis Types",
       fill = "Analysis") +
  scale_fill_manual(values = c("Baseline" = "#E69F00", 
                               "Change" = "#56B4E9", 
                               "Combined" = "#009E73")) +
  ylim(0, 1)

ggsave("~/Results/r2_performance.png", width = 10, height = 6, dpi = 300)

# 3. Heatmap of R-squared values
summary_table %>%
  mutate(outcome = factor(outcome, levels = c("mean_alt", "sd_alt", "alt_slope", 
                                              "mean_ast", "sd_ast", "ast_slope"))) %>%
  ggplot(aes(x = outcome, y = analysis, fill = r2)) +
  geom_tile(color = "white", linewidth = 1) +
  geom_text(aes(label = round(r2, 2)), color = "white", fontface = "bold", size = 5) +
  scale_fill_gradient2(low = "darkred", mid = "orange", high = "darkgreen", 
                       midpoint = 0.5, limits = c(0, 1)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid = element_blank()) +
  labs(x = "Outcome", 
       y = "Analysis Type",
       fill = "R²",
       title = "Prediction Performance Heatmap")

ggsave("~/Results/r2_heatmap.png", width = 10, height = 6, dpi = 300)

# 4. Compare baseline vs change: which matters more?
summary_table %>%
  filter(analysis != "Combined") %>%
  mutate(outcome = factor(outcome, levels = c("mean_alt", "sd_alt", "alt_slope", 
                                              "mean_ast", "sd_ast", "ast_slope"))) %>%
  ggplot(aes(x = outcome, y = r2, group = analysis, color = analysis)) +
  geom_line(linewidth = 1.5) +
  geom_point(size = 4) +
  geom_text(aes(label = round(r2, 2)), vjust = -1, size = 3) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  labs(x = "Outcome", 
       y = "R-squared",
       title = "Baseline vs Change: Which Predicts Better?",
       color = "Analysis") +
  scale_color_manual(values = c("Baseline" = "#E69F00", "Change" = "#56B4E9")) +
  ylim(0, 1)

# ggsave("~/Results/baseline_vs_change.png", width = 10, height = 6, dpi = 300)

# Keep only Combined and Baseline results
summary_table_final <- summary_table %>%
  filter(analysis %in% c("Baseline", "Combined"))

# Print
print(summary_table_final)

# Save
write.csv(summary_table_final, "~/Results/feature_selection_summary_final.csv", row.names = FALSE)

# Save selected proteins and coefficients for both approaches
outcomes_to_save <- c("mean_alt", "sd_alt", "alt_slope", 
                      "mean_ast", "sd_ast", "ast_slope")

for(outcome in outcomes_to_save) {
  
  # BASELINE approach
  baseline_results <- data.frame(
    protein = results_baseline[[outcome]]$selected_proteins_min,
    coefficient = results_baseline[[outcome]]$coefficients_min[-1],  # Remove intercept
    approach = "Baseline"
  )
  
  write.csv(baseline_results,
            paste0("~/Results/selected_baseline_", outcome, ".csv"),
            row.names = FALSE)
  
  # COMBINED approach
  combined_results <- data.frame(
    protein = results_combined[[outcome]]$selected_proteins_min,
    coefficient = results_combined[[outcome]]$coefficients_min[-1],
    approach = "Combined"
  )
  
  # Add indicator for whether it's baseline or change protein
  combined_results <- combined_results %>%
    mutate(feature_type = ifelse(grepl("_change$", protein), "Change", "Baseline"))
  
  write.csv(combined_results,
            paste0("~/Results/selected_combined_", outcome, ".csv"),
            row.names = FALSE)
}

# For each outcome, see which baseline proteins are also in combined
overlap_summary <- data.frame()

for(outcome in outcomes_to_save) {
  baseline_prots <- results_baseline[[outcome]]$selected_proteins_min
  combined_prots <- results_combined[[outcome]]$selected_proteins_min
  
  # Remove "_change" suffix from combined to compare
  combined_baseline_prots <- combined_prots[!grepl("_change$", combined_prots)]
  combined_change_prots <- gsub("_change$", "", combined_prots[grepl("_change$", combined_prots)])
  
  # Overlap
  both_baseline <- intersect(baseline_prots, combined_baseline_prots)
  only_baseline_model <- setdiff(baseline_prots, combined_baseline_prots)
  only_combined_model <- setdiff(combined_baseline_prots, baseline_prots)
  change_features <- length(combined_change_prots)
  
  overlap_summary <- rbind(overlap_summary, data.frame(
    outcome = outcome,
    baseline_model_total = length(baseline_prots),
    combined_model_total = length(combined_prots),
    combined_baseline_features = length(combined_baseline_prots),
    combined_change_features = change_features,
    overlap_baseline_proteins = length(both_baseline),
    unique_to_baseline_model = length(only_baseline_model),
    unique_to_combined_model = length(only_combined_model)
  ))
}

print(overlap_summary)
write.csv(overlap_summary, "~/Results/protein_overlap_summary.csv", row.names = FALSE)


```

###iii. Mixed Model
####A. Mean ALT  & Baseline Proteomics
```{r}
# Choose which outcome and approach to start with
outcome_choice <- "mean_alt"
approach_choice <- "baseline"  # or "combined"

# Get selected proteins
if(approach_choice == "baseline") {
  selected_proteins <- results_baseline[[outcome_choice]]$selected_proteins_min
} else if(approach_choice == "combined") {
  selected_proteins <- results_combined[[outcome_choice]]$selected_proteins_min
}

cat("Number of selected proteins:", length(selected_proteins), "\n")

# Prepare longitudinal dataset
# Merge clinical data with proteomics (long format)
mixed_model_data <- clinical %>%
  # Join with proteomics at baseline (M00)
  left_join(
    proteomics_baseline %>% 
      dplyr::select(releaseid, all_of(selected_proteins)),
    by = "releaseid"
  )

# If using combined approach, also add change features
if(approach_choice == "combined") {
  # Separate baseline and change proteins
  baseline_prots <- selected_proteins[!grepl("_change$", selected_proteins)]
  change_prots <- selected_proteins[grepl("_change$", selected_proteins)]
  
  # Add change proteins
  mixed_model_data <- mixed_model_data %>%
    left_join(
      proteomics_change %>% select(releaseid, all_of(change_prots)),
      by = "releaseid"
    )
}

# Scale the selected proteins
cat("\nScaling", length(selected_proteins), "proteins...\n")

mixed_model_data <- mixed_model_data %>%
  mutate(across(all_of(selected_proteins), 
                ~scale(.)[,1],  # scale() returns a matrix, extract vector
                .names = "{.col}"))

# Verify scaling worked
cat("\nVerifying scaling:\n")
protein_check_scaled <- mixed_model_data %>%
  dplyr::select(all_of(selected_proteins[1:5])) %>%
  summarise(across(everything(), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE)
  )))

print(t(protein_check_scaled))

# Should now see means ≈ 0 and SDs ≈ 1
cat("\n✓ Proteins are now scaled!\n")

#Run analysis with scaled values
# Build mixed model formula
cat("\nBuilding mixed model with", length(selected_proteins), "scaled baseline proteins\n")

# Create formula string
protein_formula <- paste(selected_proteins, collapse = " + ")
formula_str <- paste0("alt ~ visit_num + ", protein_formula, " + (1 + visit_num | releaseid)")

cat("Formula: alt ~ visit_num + [65 proteins] + (1 + visit_num | releaseid)\n")

# Fit the model
cat("\nFitting model... this may take a few minutes with 65 proteins\n")
start_time <- Sys.time()

model_baseline_alt <- lmer(
  as.formula(formula_str), 
  data = mixed_model_data, 
  REML = TRUE,
  control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))
)

end_time <- Sys.time()
cat("Model fitting time:", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Check convergence
if(model_baseline_alt@optinfo$conv$opt == 0) {
  cat("\n✓ Model converged successfully!\n")
} else {
  cat("\n⚠ Warning: Model convergence issue\n")
  print(model_baseline_alt@optinfo$conv$lme4$messages)
}

# Extract fixed effects for proteins
cat("\nExtracting protein effects...\n")
fixed_effects <- summary(model_baseline_alt)$coefficients
protein_effects <- fixed_effects[grepl("^seq\\.", rownames(fixed_effects)), , drop = FALSE]

# Convert to dataframe
protein_effects_df <- as.data.frame(protein_effects) %>%
  tibble::rownames_to_column("protein") %>%
  rename(
    estimate = Estimate,
    se = `Std. Error`,
    df = df,
    t_value = `t value`,
    p_value = `Pr(>|t|)`
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "fdr"),
    sig_p = ifelse(p_value < 0.05, "**", ""),
    sig_fdr = ifelse(fdr < 0.05, "**", ifelse(fdr < 0.1, "*", ""))
  ) %>%
  arrange(p_value)

# Summary
cat("\n=== RESULTS SUMMARY ===\n")
cat("Total proteins tested:", nrow(protein_effects_df), "\n")
cat("Significant (p < 0.05):", sum(protein_effects_df$p_value < 0.05), "\n")
cat("Significant (p < 0.01):", sum(protein_effects_df$p_value < 0.01), "\n")
cat("Significant (FDR < 0.05):", sum(protein_effects_df$fdr < 0.05), "\n")
cat("Significant (FDR < 0.1):", sum(protein_effects_df$fdr < 0.1), "\n")

# Show top 20
cat("\n=== TOP 20 PROTEINS ===\n")
print(protein_effects_df[1:20, c("protein", "estimate", "se", "t_value", "p_value", "fdr")])

# Map protein aptamer IDs to gene symbols
protein_effects_annotated <- protein_effects_df %>%
  left_join(
    analytes %>% dplyr::select(AptName, EntrezGeneSymbol),
    by = c("protein" = "AptName")
  ) %>%
  dplyr::select(protein, EntrezGeneSymbol, estimate, se, t_value, p_value, fdr, sig_p, sig_fdr, everything())

# Check how many mapped
cat("\nProteins mapped to gene symbols:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol)), "/", nrow(protein_effects_annotated), "\n")

# Show top 20 with gene names
cat("\n=== TOP 20 PROTEINS (with gene symbols) ===\n")
print(protein_effects_annotated[1:20, c("protein", "EntrezGeneSymbol", "estimate", "se", "t_value", "p_value", "fdr")])

# Save annotated results
write.csv(protein_effects_annotated, 
          "~/Results/mixed_model_baseline_mean_alt_annotated.csv",
          row.names = FALSE)

cat("\n✓ Annotated results saved to ~/Results/mixed_model_baseline_mean_alt_annotated.csv\n")

# Also create a summary of top hits
top_hits <- protein_effects_annotated %>%
  filter(fdr < 0.1) %>%
  arrange(p_value) %>%
  dplyr::select(EntrezGeneSymbol, protein, estimate, se, p_value, fdr)

cat("\n=== SIGNIFICANT PROTEINS (FDR < 0.1) ===\n")
print(top_hits)

write.csv(top_hits,
          "~/Results/mixed_model_baseline_mean_alt_top_hits.csv",
          row.names = FALSE)

cat("\n✓ Top hits saved to ~/Results/mixed_model_baseline_mean_alt_top_hits.csv\n")

# Save results
write.csv(protein_effects_df, 
          "~/Results/mixed_model_baseline_mean_alt.csv",
          row.names = FALSE)

cat("\n✓ Results saved to ~/Results/mixed_model_baseline_mean_alt.csv\n")

# Visualize results
# Prepare data for volcano plot
volcano_data <- protein_effects_annotated %>%
  mutate(
    # For volcano plot, use estimate as coefficient
    log_fc = estimate,
    neg_log10_p = -log10(p_value),
    # Color by significance and direction
    significance = case_when(
      fdr < 0.05 & estimate > 0 ~ "Positive (FDR < 0.05)",
      fdr < 0.05 & estimate < 0 ~ "Negative (FDR < 0.05)",
      TRUE ~ "Not Significant"
    ),
    # Label only FDR < 0.05
    label = ifelse(fdr < 0.05, EntrezGeneSymbol, "")
  )

# Count significant proteins
n_pos <- sum(volcano_data$significance == "Positive (FDR < 0.05)")
n_neg <- sum(volcano_data$significance == "Negative (FDR < 0.05)")

cat("Positive associations (FDR < 0.05):", n_pos, "\n")
cat("Negative associations (FDR < 0.05):", n_neg, "\n")

# Find the p-value threshold that corresponds to FDR = 0.05
fdr_threshold_pvalue <- max(volcano_data$p_value[volcano_data$fdr < 0.05], na.rm = TRUE)

# If no proteins pass FDR < 0.05, use placeholder
if(is.infinite(fdr_threshold_pvalue) | length(fdr_threshold_pvalue) == 0) {
  fdr_threshold_pvalue <- 0.05
  cat("No proteins pass FDR < 0.05\n")
} else {
  cat("FDR < 0.05 corresponds to p-value <", signif(fdr_threshold_pvalue, 3), "\n")
}

# Create volcano plot
volcano_plot <- ggplot(volcano_data, aes(x = log_fc, y = neg_log10_p)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.5) +
  # Grey points for non-significant
  geom_point(data = volcano_data %>% filter(significance == "Not Significant"),
             color = "grey70", alpha = 0.5, size = 2) +
  # Red for positive associations
  geom_point(data = volcano_data %>% filter(significance == "Positive (FDR < 0.05)"),
             color = "darkred", size = 3) +
  # Blue for negative associations
  geom_point(data = volcano_data %>% filter(significance == "Negative (FDR < 0.05)"),
             color = "darkblue", size = 3) +
  # Add labels for significant proteins
  geom_text_repel(data = volcano_data %>% filter(fdr < 0.05),
                  aes(label = label),
                  size = 3.5,
                  max.overlaps = 20,
                  box.padding = 0.5,
                  point.padding = 0.3,
                  segment.color = "grey50",
                  segment.size = 0.3) +
  # # Add FDR threshold line (the correct one!)
  # geom_hline(yintercept = -log10(fdr_threshold_pvalue), 
  #            linetype = "dashed", color = "gray", linewidth = 0.5) +
  # annotate("text", x = min(volcano_data$log_fc, na.rm = TRUE) * 0.8, 
  #          y = -log10(fdr_threshold_pvalue) + 0.3,
  #          label = "FDR = 0.05", color = "red", size = 3.5, hjust = 0) +
  # Optional: raw p = 0.05 reference line
  # geom_hline(yintercept = -log10(0.05), linetype = "dotted", 
  #            color = "grey50", alpha = 0.5, linewidth = 0.5) +
  # Labels and theme
  labs(x = "Coefficient (Effect Size)",
       y = "-log10(p-value)",
       title = "Volcano Plot of Baseline Proteins Associated with Mean Longitudinal ALT",
       subtitle = paste0("Red: Positive associations (n=", n_pos, ") | Blue: Negative associations (n=", n_neg, ") | FDR < 0.05")) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

print(volcano_plot)

# Save plot
ggsave("~/Results/volcano_baseline_mean_alt.png", 
       volcano_plot, 
       width = 9, height = 7, dpi = 300)

```

####B. Mean AST & Baseline Proteomics
```{r}
# Choose which outcome and approach to start with
outcome_choice <- "mean_ast"
approach_choice <- "baseline"  # or "combined"

# Get selected proteins
if(approach_choice == "baseline") {
  selected_proteins <- results_baseline[[outcome_choice]]$selected_proteins_min
} else if(approach_choice == "combined") {
  selected_proteins <- results_combined[[outcome_choice]]$selected_proteins_min
}

cat("Number of selected proteins:", length(selected_proteins), "\n")

# Prepare longitudinal dataset
# Merge clinical data with proteomics (long format)
mixed_model_data <- clinical %>%
  # Join with proteomics at baseline (M00)
  left_join(
    proteomics_baseline %>% 
      dplyr::select(releaseid, all_of(selected_proteins)),
    by = "releaseid"
  )

# If using combined approach, also add change features
if(approach_choice == "combined") {
  # Separate baseline and change proteins
  baseline_prots <- selected_proteins[!grepl("_change$", selected_proteins)]
  change_prots <- selected_proteins[grepl("_change$", selected_proteins)]
  
  # Add change proteins
  mixed_model_data <- mixed_model_data %>%
    left_join(
      proteomics_change %>% select(releaseid, all_of(change_prots)),
      by = "releaseid"
    )
}

# Scale the selected proteins
cat("\nScaling", length(selected_proteins), "proteins...\n")

mixed_model_data <- mixed_model_data %>%
  mutate(across(all_of(selected_proteins), 
                ~scale(.)[,1],  # scale() returns a matrix, extract vector
                .names = "{.col}"))

# Verify scaling worked
cat("\nVerifying scaling:\n")
protein_check_scaled <- mixed_model_data %>%
  dplyr::select(all_of(selected_proteins[1:5])) %>%
  summarise(across(everything(), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE)
  )))

print(t(protein_check_scaled))

# Should now see means ≈ 0 and SDs ≈ 1
cat("\n✓ Proteins are now scaled!\n")

#Run analysis with scaled values
# Build mixed model formula
cat("\nBuilding mixed model with", length(selected_proteins), "scaled baseline proteins\n")

# Create formula string
protein_formula <- paste(selected_proteins, collapse = " + ")
formula_str <- paste0("ast ~ visit_num + ", protein_formula, " + (1 + visit_num | releaseid)")

# cat("Formula: ast ~ visit_num + [65 proteins] + (1 + visit_num | releaseid)\n")

# Fit the model
# cat("\nFitting model... this may take a few minutes with 65 proteins\n")
start_time <- Sys.time()

model_baseline_ast <- lmer(
  as.formula(formula_str), 
  data = mixed_model_data, 
  REML = TRUE,
  control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))
)

end_time <- Sys.time()
cat("Model fitting time:", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Check convergence
if(model_baseline_ast@optinfo$conv$opt == 0) {
  cat("\n✓ Model converged successfully!\n")
} else {
  cat("\n⚠ Warning: Model convergence issue\n")
  print(model_baseline_ast@optinfo$conv$lme4$messages)
}

# Extract fixed effects for proteins
cat("\nExtracting protein effects...\n")
fixed_effects <- summary(model_baseline_ast)$coefficients
protein_effects <- fixed_effects[grepl("^seq\\.", rownames(fixed_effects)), , drop = FALSE]

# Convert to dataframe
protein_effects_df <- as.data.frame(protein_effects) %>%
  tibble::rownames_to_column("protein") %>%
  rename(
    estimate = Estimate,
    se = `Std. Error`,
    df = df,
    t_value = `t value`,
    p_value = `Pr(>|t|)`
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "fdr"),
    sig_p = ifelse(p_value < 0.05, "**", ""),
    sig_fdr = ifelse(fdr < 0.05, "**", ifelse(fdr < 0.1, "*", ""))
  ) %>%
  arrange(p_value)

# Summary
cat("\n=== RESULTS SUMMARY ===\n")
cat("Total proteins tested:", nrow(protein_effects_df), "\n")
cat("Significant (p < 0.05):", sum(protein_effects_df$p_value < 0.05), "\n")
cat("Significant (p < 0.01):", sum(protein_effects_df$p_value < 0.01), "\n")
cat("Significant (FDR < 0.05):", sum(protein_effects_df$fdr < 0.05), "\n")
cat("Significant (FDR < 0.1):", sum(protein_effects_df$fdr < 0.1), "\n")

# Show top 20
cat("\n=== TOP 20 PROTEINS ===\n")
print(protein_effects_df[1:20, c("protein", "estimate", "se", "t_value", "p_value", "fdr")])

# Map protein aptamer IDs to gene symbols
protein_effects_annotated <- protein_effects_df %>%
  left_join(
    analytes %>% dplyr::select(AptName, EntrezGeneSymbol),
    by = c("protein" = "AptName")
  ) %>%
  dplyr::select(protein, EntrezGeneSymbol, estimate, se, t_value, p_value, fdr, sig_p, sig_fdr, everything())

# Check how many mapped
cat("\nProteins mapped to gene symbols:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol)), "/", nrow(protein_effects_annotated), "\n")

# Show top 20 with gene names
cat("\n=== TOP 20 PROTEINS (with gene symbols) ===\n")
print(protein_effects_annotated[1:20, c("protein", "EntrezGeneSymbol", "estimate", "se", "t_value", "p_value", "fdr")])

# Save annotated results
write.csv(protein_effects_annotated, 
          "~/Results/mixed_model_baseline_mean_ast_annotated.csv",
          row.names = FALSE)

cat("\n✓ Annotated results saved to ~/Results/mixed_model_baseline_mean_ast_annotated.csv\n")

# Also create a summary of top hits
top_hits <- protein_effects_annotated %>%
  filter(fdr < 0.1) %>%
  arrange(p_value) %>%
  dplyr::select(EntrezGeneSymbol, protein, estimate, se, p_value, fdr)

cat("\n=== SIGNIFICANT PROTEINS (FDR < 0.1) ===\n")
print(top_hits)

write.csv(top_hits,
          "~/Results/mixed_model_baseline_mean_ast_top_hits.csv",
          row.names = FALSE)

cat("\n✓ Top hits saved to ~/Results/mixed_model_baseline_mean_ast_top_hits.csv\n")

# Save results
write.csv(protein_effects_df, 
          "~/Results/mixed_model_baseline_mean_ast.csv",
          row.names = FALSE)

cat("\n✓ Results saved to ~/Results/mixed_model_baseline_mean_ast.csv\n")

# Visualize results
# Prepare data for volcano plot
volcano_data <- protein_effects_annotated %>%
  mutate(
    # For volcano plot, use estimate as coefficient
    log_fc = estimate,
    neg_log10_p = -log10(p_value),
    # Color by significance and direction
    significance = case_when(
      fdr < 0.05 & estimate > 0 ~ "Positive (FDR < 0.05)",
      fdr < 0.05 & estimate < 0 ~ "Negative (FDR < 0.05)",
      TRUE ~ "Not Significant"
    ),
    # Label only FDR < 0.05
    label = ifelse(fdr < 0.05, EntrezGeneSymbol, "")
  )

# Count significant proteins
n_pos <- sum(volcano_data$significance == "Positive (FDR < 0.05)")
n_neg <- sum(volcano_data$significance == "Negative (FDR < 0.05)")

cat("Positive associations (FDR < 0.05):", n_pos, "\n")
cat("Negative associations (FDR < 0.05):", n_neg, "\n")

# Find the p-value threshold that corresponds to FDR = 0.05
fdr_threshold_pvalue <- max(volcano_data$p_value[volcano_data$fdr < 0.05], na.rm = TRUE)

# If no proteins pass FDR < 0.05, use placeholder
if(is.infinite(fdr_threshold_pvalue) | length(fdr_threshold_pvalue) == 0) {
  fdr_threshold_pvalue <- 0.05
  cat("No proteins pass FDR < 0.05\n")
} else {
  cat("FDR < 0.05 corresponds to p-value <", signif(fdr_threshold_pvalue, 3), "\n")
}

# Create volcano plot
volcano_plot <- ggplot(volcano_data, aes(x = log_fc, y = neg_log10_p)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.5) +
  # Grey points for non-significant
  geom_point(data = volcano_data %>% filter(significance == "Not Significant"),
             color = "grey70", alpha = 0.5, size = 2) +
  # Red for positive associations
  geom_point(data = volcano_data %>% filter(significance == "Positive (FDR < 0.05)"),
             color = "darkred", size = 3) +
  # Blue for negative associations
  geom_point(data = volcano_data %>% filter(significance == "Negative (FDR < 0.05)"),
             color = "darkblue", size = 3) +
  # Add labels for significant proteins
  geom_text_repel(data = volcano_data %>% filter(fdr < 0.05),
                  aes(label = label),
                  size = 3.5,
                  max.overlaps = 20,
                  box.padding = 0.5,
                  point.padding = 0.3,
                  segment.color = "grey50",
                  segment.size = 0.3) +
  # # Add FDR threshold line (the correct one!)
  # geom_hline(yintercept = -log10(fdr_threshold_pvalue), 
  #            linetype = "dashed", color = "gray", linewidth = 0.5) +
  # annotate("text", x = min(volcano_data$log_fc, na.rm = TRUE) * 0.8, 
  #          y = -log10(fdr_threshold_pvalue) + 0.3,
  #          label = "FDR = 0.05", color = "red", size = 3.5, hjust = 0) +
  # Optional: raw p = 0.05 reference line
  # geom_hline(yintercept = -log10(0.05), linetype = "dotted", 
  #            color = "grey50", alpha = 0.5, linewidth = 0.5) +
  # Labels and theme
  labs(x = "Coefficient (Effect Size)",
       y = "-log10(p-value)",
       title = "Volcano Plot of Baseline Proteins Associated with Mean Longitudinal AST",
       subtitle = paste0("Red: Positive associations (n=", n_pos, ") | Blue: Negative associations (n=", n_neg, ") | FDR < 0.05")) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

print(volcano_plot)

# Save plot
ggsave("~/Results/volcano_baseline_mean_ast.png", 
       volcano_plot, 
       width = 9, height = 7, dpi = 300)

```
####C. Mean ALT  & Combined Proteomics
```{r}
# Choose which outcome and approach to start with
outcome_choice <- "mean_alt"
approach_choice <- "combined"  # or "baseline"

# Get selected proteins from COMBINED elastic net results
selected_proteins <- results_combined[[outcome_choice]]$selected_proteins_min

cat("Number of selected proteins:", length(selected_proteins), "\n")

# Separate baseline and change features
baseline_prots <- selected_proteins[!grepl("_change$", selected_proteins)]
change_prots <- selected_proteins[grepl("_change$", selected_proteins)]

cat("Baseline features:", length(baseline_prots), "\n")
cat("Change features:", length(change_prots), "\n")

# Prepare longitudinal dataset
# Merge clinical data with proteomics (long format)
mixed_model_data <- clinical %>%
  # Join with BASELINE proteins from proteomics_baseline
  left_join(
    proteomics_baseline %>% dplyr::select(releaseid, all_of(baseline_prots)),
    by = "releaseid"
  ) %>%
  # Join with CHANGE proteins from proteomics_change
  left_join(
    proteomics_change %>% dplyr::select(releaseid, all_of(change_prots)),
    by = "releaseid"
  )

# Check dimensions
cat("Dataset dimensions:", nrow(mixed_model_data), "rows x", ncol(mixed_model_data), "columns\n")
cat("Unique individuals:", length(unique(mixed_model_data$releaseid)), "\n")

# Remove rows with missing outcome
mixed_model_data <- mixed_model_data %>%
  filter(!is.na(alt))

cat("After removing missing ALT:", nrow(mixed_model_data), "rows\n")

# Scale ALL selected proteins (both baseline and change)
cat("\nScaling", length(selected_proteins), "proteins...\n")

mixed_model_data <- mixed_model_data %>%
  mutate(across(all_of(selected_proteins), 
                ~scale(.)[,1],
                .names = "{.col}"))

# Verify scaling
cat("\nVerifying scaling:\n")
protein_check_scaled <- mixed_model_data %>%
  dplyr::select(all_of(selected_proteins[1:5])) %>%
  summarise(across(everything(), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE)
  )))

print(t(protein_check_scaled))
cat("\n✓ Proteins are now scaled!\n")

# Build mixed model formula
cat("\nBuilding mixed model with", length(selected_proteins), "features (baseline + change)\n")

# Create formula string with ALL selected proteins
protein_formula <- paste(selected_proteins, collapse = " + ")
formula_str <- paste0("alt ~ visit_num + ", protein_formula, " + (1 + visit_num | releaseid)")

cat("Formula: alt ~ visit_num + [", length(baseline_prots), "baseline +", length(change_prots), "change features] + (1 + visit_num | releaseid)\n")

# Fit the model
cat("\nFitting model... this may take longer with", length(selected_proteins), "features\n")
start_time <- Sys.time()

model_combined_alt <- lmer(
  as.formula(formula_str), 
  data = mixed_model_data, 
  REML = TRUE,
  control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))
)

end_time <- Sys.time()
cat("Model fitting time:", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Check convergence
if(model_combined_alt@optinfo$conv$opt == 0) {
  cat("\n✓ Model converged successfully!\n")
} else {
  cat("\n⚠ Warning: Model convergence issue\n")
  print(model_combined_alt@optinfo$conv$lme4$messages)
}

# Extract results (rest is same as before)
fixed_effects <- summary(model_combined_alt)$coefficients
protein_effects <- fixed_effects[grepl("^seq\\.", rownames(fixed_effects)), , drop = FALSE]

protein_effects_df <- as.data.frame(protein_effects) %>%
  tibble::rownames_to_column("protein") %>%
  rename(
    estimate = Estimate,
    se = `Std. Error`,
    df = df,
    t_value = `t value`,
    p_value = `Pr(>|t|)`
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "fdr"),
    # Add feature type indicator
    feature_type = ifelse(grepl("_change$", protein), "Change", "Baseline")
  ) %>%
  arrange(p_value)

# Summary
cat("\n=== RESULTS SUMMARY ===\n")
cat("Total features tested:", nrow(protein_effects_df), "\n")
cat("Significant (p < 0.05):", sum(protein_effects_df$p_value < 0.05), "\n")
cat("Significant (FDR < 0.05):", sum(protein_effects_df$fdr < 0.05), "\n")
cat("  - Baseline features:", sum(protein_effects_df$fdr < 0.05 & protein_effects_df$feature_type == "Baseline"), "\n")
cat("  - Change features:", sum(protein_effects_df$fdr < 0.05 & protein_effects_df$feature_type == "Change"), "\n")

# Add gene symbols - need to handle _change suffix
protein_effects_annotated <- protein_effects_df %>%
  mutate(
    # Remove _change suffix for matching with analytes
    protein_base = gsub("_change$", "", protein)
  ) %>%
  left_join(
    analytes %>% dplyr::select(AptName, EntrezGeneSymbol),
    by = c("protein_base" = "AptName")
  ) %>%
  dplyr::select(protein, EntrezGeneSymbol, feature_type, estimate, se, t_value, p_value, fdr, everything(), -protein_base)

# Check mapping success
cat("\nProteins mapped to gene symbols:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol)), "/", nrow(protein_effects_annotated), "\n")
cat("Baseline features mapped:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol) & protein_effects_annotated$feature_type == "Baseline"), "\n")
cat("Change features mapped:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol) & protein_effects_annotated$feature_type == "Change"), "\n")

# Show top hits
top_hits <- protein_effects_annotated %>%
  filter(fdr < 0.1) %>%
  arrange(p_value) %>%
  dplyr::select(EntrezGeneSymbol, feature_type, protein, estimate, se, p_value, fdr)

cat("\n=== SIGNIFICANT FEATURES (FDR < 0.1) ===\n")
print(top_hits)

# Save results
write.csv(protein_effects_annotated,
          "~/Results/mixed_model_combined_mean_alt_annotated.csv",
          row.names = FALSE)

write.csv(top_hits,
          "~/Results/mixed_model_combined_mean_alt_top_hits.csv",
          row.names = FALSE)

cat("\n✓ Results saved\n")
# Check if it's really bad
max(abs(summary(model_combined_alt)$coefficients[, "Std. Error"]))
# If SEs are huge (>100), model is unstable
# ============================================
# VOLCANO PLOT: COMBINED MODEL RESULTS
# ============================================

# Prepare volcano plot data with unique labels
volcano_data_combined <- protein_effects_annotated %>%
  mutate(
    log_fc = estimate,
    neg_log10_p = -log10(p_value),
    # Color by feature type AND significance
    significance = case_when(
      fdr < 0.05 & feature_type == "Baseline" & estimate > 0 ~ "Baseline Positive",
      fdr < 0.05 & feature_type == "Baseline" & estimate < 0 ~ "Baseline Negative",
      fdr < 0.05 & feature_type == "Change" & estimate > 0 ~ "Change Positive",
      fdr < 0.05 & feature_type == "Change" & estimate < 0 ~ "Change Negative",
      TRUE ~ "Not Significant"
    )
  ) %>%
  # Create unique labels for duplicates
  group_by(EntrezGeneSymbol) %>%
  mutate(
    n_duplicates = n(),
    duplicate_id = row_number(),
    label = case_when(
      fdr >= 0.05 ~ "",  # No label for non-significant
      is.na(EntrezGeneSymbol) ~ protein,  # Use aptamer ID if no gene symbol
      n_duplicates > 1 ~ paste0(EntrezGeneSymbol, "_apt", duplicate_id),  # Add suffix for duplicates
      TRUE ~ EntrezGeneSymbol  # Use gene symbol for unique ones
    )
  ) %>%
  ungroup()

# Count significant features
sig_counts <- volcano_data_combined %>%
  filter(fdr < 0.05) %>%
  count(significance)

cat("\n=== SIGNIFICANT FEATURES (FDR < 0.05) ===\n")
print(sig_counts)

# Check for any missing labels
missing_labels <- volcano_data_combined %>%
  filter(fdr < 0.05, label == "")
if(nrow(missing_labels) > 0) {
  cat("\n⚠ WARNING:", nrow(missing_labels), "significant features have no gene symbol\n")
  print(missing_labels %>% dplyr::select(protein, EntrezGeneSymbol, fdr))
}

# Find FDR threshold
fdr_threshold_pvalue <- max(volcano_data_combined$p_value[volcano_data_combined$fdr < 0.05], na.rm = TRUE)
if(is.infinite(fdr_threshold_pvalue) | length(fdr_threshold_pvalue) == 0) {
  fdr_threshold_pvalue <- 0.05
}

# Create volcano plot with legend
volcano_plot <- ggplot(volcano_data_combined, aes(x = log_fc, y = neg_log10_p)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.5) +
  
  # Plot all points with color and shape mapping
  geom_point(aes(color = significance, shape = significance, size = significance, alpha = significance)) +
  
  # Manual scales
  scale_color_manual(
    values = c(
      "Baseline Positive" = "darkred",
      "Baseline Negative" = "darkblue",
      "Change Positive" = "darkorange",
      "Change Negative" = "cyan3",
      "Not Significant" = "grey70"
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_shape_manual(
    values = c(
      "Baseline Positive" = 16,    # circle
      "Baseline Negative" = 16,    # circle
      "Change Positive" = 17,      # triangle
      "Change Negative" = 17,      # triangle
      "Not Significant" = 16       # circle
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_size_manual(
    values = c(
      "Baseline Positive" = 3.5,
      "Baseline Negative" = 3.5,
      "Change Positive" = 4,
      "Change Negative" = 4,
      "Not Significant" = 2
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_alpha_manual(
    values = c(
      "Baseline Positive" = 1,
      "Baseline Negative" = 1,
      "Change Positive" = 1,
      "Change Negative" = 1,
      "Not Significant" = 0.5
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  
  # Labels for ALL significant features
  geom_text_repel(
    data = volcano_data_combined %>% filter(fdr < 0.05),
    aes(label = label),
    size = 3,
    max.overlaps = Inf,  # Show all labels
    box.padding = 0.5,
    point.padding = 0.3,
    segment.size = 0.3,
    segment.color = "grey50",
    min.segment.length = 0,
    show.legend = FALSE
  ) +
  
  # Labels and theme
  labs(
    x = "Coefficient: Change in ALT (U/L) per SD",
    y = "-log10(p-value)",
    title = "Volcano Plot of Combined Model: Baseline + Change Features",
    color = "Feature Type",
    shape = "Feature Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(size = 13, face = "bold"),
    axis.title = element_text(size = 11),
    legend.position = "right",
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9)
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 4)),
    shape = guide_legend(override.aes = list(size = 4)),
    size = "none",
    alpha = "none"
  )

print(volcano_plot)

# Save
ggsave("~/Results/volcano_combined_mean_alt.png",
       volcano_plot, 
       width = 12, height = 9, dpi = 300)



```

####D. Mean AST  & Combined Proteomics
```{r}
# Choose which outcome and approach to start with
outcome_choice <- "mean_ast"
approach_choice <- "combined"  # or "baseline"

# Get selected proteins from COMBINED elastic net results
selected_proteins <- results_combined[[outcome_choice]]$selected_proteins_min

cat("Number of selected proteins:", length(selected_proteins), "\n")

# Separate baseline and change features
baseline_prots <- selected_proteins[!grepl("_change$", selected_proteins)]
change_prots <- selected_proteins[grepl("_change$", selected_proteins)]

cat("Baseline features:", length(baseline_prots), "\n")
cat("Change features:", length(change_prots), "\n")

# Prepare longitudinal dataset
# Merge clinical data with proteomics (long format)
mixed_model_data <- clinical %>%
  # Join with BASELINE proteins from proteomics_baseline
  left_join(
    proteomics_baseline %>% dplyr::select(releaseid, all_of(baseline_prots)),
    by = "releaseid"
  ) %>%
  # Join with CHANGE proteins from proteomics_change
  left_join(
    proteomics_change %>% dplyr::select(releaseid, all_of(change_prots)),
    by = "releaseid"
  )

# Check dimensions
cat("Dataset dimensions:", nrow(mixed_model_data), "rows x", ncol(mixed_model_data), "columns\n")
cat("Unique individuals:", length(unique(mixed_model_data$releaseid)), "\n")

# Remove rows with missing outcome
mixed_model_data <- mixed_model_data %>%
  filter(!is.na(ast))

cat("After removing missing AST:", nrow(mixed_model_data), "rows\n")

# Scale ALL selected proteins (both baseline and change)
cat("\nScaling", length(selected_proteins), "proteins...\n")

mixed_model_data <- mixed_model_data %>%
  mutate(across(all_of(selected_proteins), 
                ~scale(.)[,1],
                .names = "{.col}"))

# Verify scaling
cat("\nVerifying scaling:\n")
protein_check_scaled <- mixed_model_data %>%
  dplyr::select(all_of(selected_proteins[1:5])) %>%
  summarise(across(everything(), list(
    mean = ~mean(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE)
  )))

print(t(protein_check_scaled))
cat("\n✓ Proteins are now scaled!\n")

# Build mixed model formula
cat("\nBuilding mixed model with", length(selected_proteins), "features (baseline + change)\n")

# Create formula string with ALL selected proteins
protein_formula <- paste(selected_proteins, collapse = " + ")
formula_str <- paste0("ast ~ visit_num + ", protein_formula, " + (1 + visit_num | releaseid)")

cat("Formula: ast ~ visit_num + [", length(baseline_prots), "baseline +", length(change_prots), "change features] + (1 + visit_num | releaseid)\n")

# Fit the model
cat("\nFitting model... this may take longer with", length(selected_proteins), "features\n")
start_time <- Sys.time()

model_combined_ast <- lmer(
  as.formula(formula_str), 
  data = mixed_model_data, 
  REML = TRUE,
  control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))
)

end_time <- Sys.time()
cat("Model fitting time:", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Check convergence
if(model_combined_ast@optinfo$conv$opt == 0) {
  cat("\n✓ Model converged successfully!\n")
} else {
  cat("\n⚠ Warning: Model convergence issue\n")
  print(model_combined_ast@optinfo$conv$lme4$messages)
}

# Extract results (rest is same as before)
fixed_effects <- summary(model_combined_ast)$coefficients
protein_effects <- fixed_effects[grepl("^seq\\.", rownames(fixed_effects)), , drop = FALSE]

protein_effects_df <- as.data.frame(protein_effects) %>%
  tibble::rownames_to_column("protein") %>%
  rename(
    estimate = Estimate,
    se = `Std. Error`,
    df = df,
    t_value = `t value`,
    p_value = `Pr(>|t|)`
  ) %>%
  mutate(
    fdr = p.adjust(p_value, method = "fdr"),
    # Add feature type indicator
    feature_type = ifelse(grepl("_change$", protein), "Change", "Baseline")
  ) %>%
  arrange(p_value)

# Summary
cat("\n=== RESULTS SUMMARY ===\n")
cat("Total features tested:", nrow(protein_effects_df), "\n")
cat("Significant (p < 0.05):", sum(protein_effects_df$p_value < 0.05), "\n")
cat("Significant (FDR < 0.05):", sum(protein_effects_df$fdr < 0.05), "\n")
cat("  - Baseline features:", sum(protein_effects_df$fdr < 0.05 & protein_effects_df$feature_type == "Baseline"), "\n")
cat("  - Change features:", sum(protein_effects_df$fdr < 0.05 & protein_effects_df$feature_type == "Change"), "\n")

# Add gene symbols - need to handle _change suffix
protein_effects_annotated <- protein_effects_df %>%
  mutate(
    # Remove _change suffix for matching with analytes
    protein_base = gsub("_change$", "", protein)
  ) %>%
  left_join(
    analytes %>% dplyr::select(AptName, EntrezGeneSymbol),
    by = c("protein_base" = "AptName")
  ) %>%
  dplyr::select(protein, EntrezGeneSymbol, feature_type, estimate, se, t_value, p_value, fdr, everything(), -protein_base)

# Check mapping success
cat("\nProteins mapped to gene symbols:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol)), "/", nrow(protein_effects_annotated), "\n")
cat("Baseline features mapped:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol) & protein_effects_annotated$feature_type == "Baseline"), "\n")
cat("Change features mapped:", sum(!is.na(protein_effects_annotated$EntrezGeneSymbol) & protein_effects_annotated$feature_type == "Change"), "\n")

# Show top hits
top_hits <- protein_effects_annotated %>%
  filter(fdr < 0.1) %>%
  arrange(p_value) %>%
  dplyr::select(EntrezGeneSymbol, feature_type, protein, estimate, se, p_value, fdr)

cat("\n=== SIGNIFICANT FEATURES (FDR < 0.1) ===\n")
print(top_hits)

# Save results
write.csv(protein_effects_annotated,
          "~/Results/mixed_model_combined_mean_ast_annotated.csv",
          row.names = FALSE)

write.csv(top_hits,
          "~/Results/mixed_model_combined_mean_ast_top_hits.csv",
          row.names = FALSE)

cat("\n✓ Results saved\n")
# Check if it's really bad
max(abs(summary(model_combined_ast)$coefficients[, "Std. Error"]))
# If SEs are huge (>100), model is unstable
# ============================================
# VOLCANO PLOT: COMBINED MODEL RESULTS
# ============================================

# Prepare volcano plot data with unique labels
volcano_data_combined <- protein_effects_annotated %>%
  mutate(
    log_fc = estimate,
    neg_log10_p = -log10(p_value),
    # Color by feature type AND significance
    significance = case_when(
      fdr < 0.05 & feature_type == "Baseline" & estimate > 0 ~ "Baseline Positive",
      fdr < 0.05 & feature_type == "Baseline" & estimate < 0 ~ "Baseline Negative",
      fdr < 0.05 & feature_type == "Change" & estimate > 0 ~ "Change Positive",
      fdr < 0.05 & feature_type == "Change" & estimate < 0 ~ "Change Negative",
      TRUE ~ "Not Significant"
    )
  ) %>%
  # Create unique labels for duplicates
  group_by(EntrezGeneSymbol) %>%
  mutate(
    n_duplicates = n(),
    duplicate_id = row_number(),
    label = case_when(
      fdr >= 0.05 ~ "",  # No label for non-significant
      is.na(EntrezGeneSymbol) ~ protein,  # Use aptamer ID if no gene symbol
      n_duplicates > 1 ~ paste0(EntrezGeneSymbol, "_apt", duplicate_id),  # Add suffix for duplicates
      TRUE ~ EntrezGeneSymbol  # Use gene symbol for unique ones
    )
  ) %>%
  ungroup()

# Count significant features
sig_counts <- volcano_data_combined %>%
  filter(fdr < 0.05) %>%
  count(significance)

cat("\n=== SIGNIFICANT FEATURES (FDR < 0.05) ===\n")
print(sig_counts)

# Check for any missing labels
missing_labels <- volcano_data_combined %>%
  filter(fdr < 0.05, label == "")
if(nrow(missing_labels) > 0) {
  cat("\n⚠ WARNING:", nrow(missing_labels), "significant features have no gene symbol\n")
  print(missing_labels %>% dplyr::select(protein, EntrezGeneSymbol, fdr))
}

# Find FDR threshold
fdr_threshold_pvalue <- max(volcano_data_combined$p_value[volcano_data_combined$fdr < 0.05], na.rm = TRUE)
if(is.infinite(fdr_threshold_pvalue) | length(fdr_threshold_pvalue) == 0) {
  fdr_threshold_pvalue <- 0.05
}

# Create volcano plot with legend
volcano_plot <- ggplot(volcano_data_combined, aes(x = log_fc, y = neg_log10_p)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", alpha = 0.5) +
  
  # Plot all points with color and shape mapping
  geom_point(aes(color = significance, shape = significance, size = significance, alpha = significance)) +
  
  # Manual scales
  scale_color_manual(
    values = c(
      "Baseline Positive" = "darkred",
      "Baseline Negative" = "darkblue",
      "Change Positive" = "darkorange",
      "Change Negative" = "cyan3",
      "Not Significant" = "grey70"
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_shape_manual(
    values = c(
      "Baseline Positive" = 16,    # circle
      "Baseline Negative" = 16,    # circle
      "Change Positive" = 17,      # triangle
      "Change Negative" = 17,      # triangle
      "Not Significant" = 16       # circle
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_size_manual(
    values = c(
      "Baseline Positive" = 3.5,
      "Baseline Negative" = 3.5,
      "Change Positive" = 4,
      "Change Negative" = 4,
      "Not Significant" = 2
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  scale_alpha_manual(
    values = c(
      "Baseline Positive" = 1,
      "Baseline Negative" = 1,
      "Change Positive" = 1,
      "Change Negative" = 1,
      "Not Significant" = 0.5
    ),
    breaks = c("Baseline Positive", "Baseline Negative", "Change Positive", "Change Negative")
  ) +
  
  # Labels for ALL significant features
  geom_text_repel(
    data = volcano_data_combined %>% filter(fdr < 0.05),
    aes(label = label),
    size = 3,
    max.overlaps = Inf,  # Show all labels
    box.padding = 0.5,
    point.padding = 0.3,
    segment.size = 0.3,
    segment.color = "grey50",
    min.segment.length = 0,
    show.legend = FALSE
  ) +
  
  # Labels and theme
  labs(
    x = "Coefficient: Change in AST (U/L) per SD",
    y = "-log10(p-value)",
    title = "Volcano Plot of Combined Model: Baseline + Change Features",
    color = "Feature Type",
    shape = "Feature Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(size = 13, face = "bold"),
    axis.title = element_text(size = 11),
    legend.position = "right",
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9)
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 4)),
    shape = guide_legend(override.aes = list(size = 4)),
    size = "none",
    alpha = "none"
  )

print(volcano_plot)

# Save
ggsave("~/Results/volcano_combined_mean_ast.png",
       volcano_plot, 
       width = 12, height = 9, dpi = 300)



```

##e. Longitudinal Elastic Net Feature Selection
###i. Process and Prepare Data
```{r}
# Order data by subject and visit (REQUIRED for PGEE)
prot <- prot[order(prot$releaseid, prot$visit), ]

#Check for NAs before scaling the log2 transformed proteins
# Total NAs in entire dataframe
sum(is.na(prot[proteins])) #0 NAs
# Summary of NAs by column 
colSums(is.na(prot[proteins])) #all 0 NAs

# Scale proteins
prot[proteins] <- scale(prot[proteins])

# Check structure
length(unique(prot$releaseid))  # Number of subjects, 379
table(prot$visit)                # Visits per timepoint
#  1   2 
# 376 268 

# =============================================================================
# CHECK DATA COMPLETENESS
# =============================================================================

# 1. How many subjects have BOTH visits?
visits_per_subject <- table(prot$releaseid)
table(visits_per_subject)  # How many have 1 visit vs 2 visits

subjects_both_visits <- names(visits_per_subject[visits_per_subject == 2])
subjects_one_visit <- names(visits_per_subject[visits_per_subject == 1])

cat("Subjects with both visits:", length(subjects_both_visits), "\n")
cat("Subjects with only one visit:", length(subjects_one_visit), "\n")

# 2. Check ALT completeness
cat("\n--- ALT ---\n")
cat("Total NAs in ALT:", sum(is.na(prot$ALT)), "\n")
cat("Complete ALT at visit 1:", sum(!is.na(prot$ALT[prot$visit == 1])), "\n")
cat("Complete ALT at visit 2:", sum(!is.na(prot$ALT[prot$visit == 2])), "\n")

# 3. Check AST completeness
cat("\n--- AST ---\n")
cat("Total NAs in AST:", sum(is.na(prot$AST)), "\n")
cat("Complete AST at visit 1:", sum(!is.na(prot$AST[prot$visit == 1])), "\n")
cat("Complete AST at visit 2:", sum(!is.na(prot$AST[prot$visit == 2])), "\n")

# 4. Check proteins completeness
cat("\n--- Proteins ---\n")
protein_na_count <- colSums(is.na(prot[proteins]))
cat("Proteins with any NA:", sum(protein_na_count > 0), "\n")
cat("Total protein NAs:", sum(protein_na_count), "\n")

# 5. Subjects with complete data for ALT analysis
complete_ALT <- complete.cases(prot[, c("releaseid", "visit", "ALT", proteins)])
cat("\n--- Complete cases for ALT ---\n")
cat("Total complete rows:", sum(complete_ALT), "\n")
cat("Subjects with at least one complete ALT row:", length(unique(prot$releaseid[complete_ALT])), "\n")

# 6. Subjects with complete data for AST analysis
complete_AST <- complete.cases(prot[, c("releaseid", "visit", "AST", proteins)])
cat("\n--- Complete cases for AST ---\n")
cat("Total complete rows:", sum(complete_AST), "\n")
cat("Subjects with at least one complete AST row:", length(unique(prot$releaseid[complete_AST])), "\n")

# 7. Detailed breakdown by visit
cat("\n--- Breakdown by visit ---\n")
for (v in unique(prot$visit)) {
  subset_v <- prot[prot$visit == v, ]
  cat("\nVisit", v, ":\n")
  cat("  Total rows:", nrow(subset_v), "\n")
  cat("  Complete ALT:", sum(!is.na(subset_v$ALT)), "\n")
  cat("  Complete AST:", sum(!is.na(subset_v$AST)), "\n")
  cat("  Complete proteins (all):", sum(complete.cases(subset_v[proteins])), "\n")
}

# 8. Subjects with complete data at BOTH visits
cat("\n--- Subjects complete at BOTH visits ---\n")
complete_both <- prot %>%
  group_by(releaseid) %>%
  summarise(
    n_visits = n(),
    n_complete_ALT = sum(!is.na(ALT)),
    n_complete_AST = sum(!is.na(AST)),
    n_complete_proteins = sum(complete.cases(across(all_of(proteins))))
  )

cat("Subjects with 2 visits AND complete ALT at both:", 
    sum(complete_both$n_visits == 2 & complete_both$n_complete_ALT == 2), "\n")
cat("Subjects with 2 visits AND complete AST at both:", 
    sum(complete_both$n_visits == 2 & complete_both$n_complete_AST == 2), "\n")
cat("Subjects with 2 visits AND complete proteins at both:", 
    sum(complete_both$n_visits == 2 & complete_both$n_complete_proteins == 2), "\n")


```


```{r}
#Load in AST and ALT in today 
# today <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","CBL.csv"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "CBL.csv", temp_file)
today <- read.csv(temp_file)
gc()
length(unique(today$releaseid)) # 699 ids
today <- today %>%
  filter(mvisit!="R")

#Load in Proteomics in Today
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "today_proteomics_log2.rds", temp_file)
prot <- readRDS(temp_file)
gc()

which(colnames(prot)=="AGEBASE") #7406
which(colnames(prot)=="releaseid") #7326
which(colnames(prot)=="sex") #7399
prot <- prot[c(7326,7406,7399,which(grepl("seq.",colnames(prot))))] #length(unique(prot$releaseid)) - 376 unique ids
proteins <- colnames(prot)[which(grepl("seq.",colnames(prot)))]

#Load gene protein key
# key <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/Data/gene_prot.RDS")
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".RDS") # need to create a temporary file
s3$download_file(bucket, "gene_prot.RDS", temp_file)
key <- readRDS(temp_file)
gc()

genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)]
prot <- prot[c("releaseid","AGEBASE","sex",gene_proteins)]
prot_id <- unique(prot$releaseid)

#Filter to IDs that have proteomics 
today_sub <- today %>% 
  filter(releaseid %in% prot_id)

#Create a dataset for longitudinal proteomics


# Basic spaghetti plot
ggplot(today_sub, aes(x = mvisit, y = ALT, group = releaseid)) +
  geom_line(alpha = 0.5, color = "gray40") +
  geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
  labs(title = "ALT Values Over Time by Individual",
       x = "mvisit",
       y = "ALT") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate mean ALT for each mvisit
mean_data <- today_sub %>%
  group_by(mvisit) %>%
  summarise(mean_ALT = mean(ALT, na.rm = TRUE))

# Create plot with individual lines and mean trend
ggplot(today_sub, aes(x = mvisit, y = ALT)) +
  geom_line(aes(group = releaseid), alpha = 0.3, color = "gray60") +
  geom_point(aes(group = releaseid), alpha = 0.3, size = 1, color = "gray60") +
  geom_line(data = mean_data, aes(x = mvisit, y = mean_ALT, group = 1), 
            color = "red", size = 2) +
  geom_point(data = mean_data, aes(x = mvisit, y = mean_ALT), 
             color = "red", size = 3) +
  labs(title = "ALT Values Over Time by Individual",
       subtitle = "Red line shows mean trend",
       x = "mvisit",
       y = "ALT") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(today_sub, aes(x = mvisit, y = ALT, group = releaseid, color = factor(releaseid))) +
  geom_line(alpha = 0.7, size = 1) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "ALT Values Over Time by Individual",
       x = "mvisit",
       y = "ALT",
       color = "Individual ID") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
  theme(legend.position = "none")

# Basic spaghetti plot
ggplot(today_sub, aes(x = mvisit, y = AST, group = releaseid)) +
  geom_line(alpha = 0.5, color = "gray40") +
  geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
  labs(title = "AST Values Over Time by Individual",
       x = "mvisit",
       y = "AST") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate mean AST for each mvisit
mean_data <- today_sub %>%
  group_by(mvisit) %>%
  summarise(mean_AST = mean(AST, na.rm = TRUE))

# Create plot with individual lines and mean trend
ggplot(today_sub, aes(x = mvisit, y = AST)) +
  geom_line(aes(group = releaseid), alpha = 0.3, color = "gray60") +
  geom_point(aes(group = releaseid), alpha = 0.3, size = 1, color = "gray60") +
  geom_line(data = mean_data, aes(x = mvisit, y = mean_AST, group = 1), 
            color = "red", size = 2) +
  geom_point(data = mean_data, aes(x = mvisit, y = mean_AST), 
             color = "red", size = 3) +
  labs(title = "AST Values Over Time by Individual",
       subtitle = "Red line shows mean trend",
       x = "mvisit",
       y = "AST") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(today_sub, aes(x = mvisit, y = AST, group = releaseid, color = factor(releaseid))) +
  geom_line(alpha = 0.7, size = 1) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "AST Values Over Time by Individual",
       x = "mvisit",
       y = "AST",
       color = "Individual ID") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
  theme(legend.position = "none")

missing_counts <- today_sub %>%
  group_by(releaseid) %>%
  summarise(
    total_timepoints = n(),
    missing_ALT = sum(is.na(ALT)),
    missing_AST = sum(is.na(AST)),
    complete_ALT = sum(!is.na(ALT)),
    complete_AST = sum(!is.na(AST))
  )

print(missing_counts)

# # Calculate percentages for ALT
# ALT_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_ALT = sum(missing_ALT >= 1),
#     participants_missing_more_than_5_ALT = sum(missing_ALT > 5),
#     percent_missing_at_least_one_ALT = round(100 * participants_missing_at_least_one_ALT / total_participants, 2),
#     percent_missing_more_than_5_ALT = round(100 * participants_missing_more_than_5_ALT / total_participants, 2)
#   )
# 
# # Calculate percentages for AST
# AST_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_AST = sum(missing_AST >= 1),
#     participants_missing_more_than_5_AST = sum(missing_AST > 5),
#     percent_missing_at_least_one_AST = round(100 * participants_missing_at_least_one_AST / total_participants, 2),
#     percent_missing_more_than_5_AST = round(100 * participants_missing_more_than_5_AST / total_participants, 2)
#   )

#Calculate sensoring and time to event
baseline <- today %>% 
  filter(mvisit=="M00") %>% 
  mutate(baseline_alt=ALT,
         baseline_ast=AST) %>% 
  dplyr::select(all_of(c("releaseid","baseline_alt","baseline_ast"))) 
dat <- tidylog::left_join(today,baseline,by="releaseid")
dat <- dat %>% 
  mutate(ratio = AST/ALT) %>% 
  mutate(event_alt=ifelse(ALT>=2*(baseline_alt),1,0)) %>% 
  mutate(event_ast=ifelse(AST>=2*(baseline_ast),1,0)) %>% 
  mutate(event_ratio=ifelse(ratio>=1.5,1,0)) %>% 
  mutate(days=ifelse(mvisit=="M00",0,days))
#Calculate time to event & censoring
dat_alt <- dat %>% 
  group_by(releaseid) %>%
  summarize(
    event_status_alt = ifelse(any(event_alt == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
    time_to_event_alt = ifelse(
      any(event_alt == 1, na.rm = TRUE), 
      min(days[event_alt == 1], na.rm = TRUE), # Time of first event
      max(days, na.rm = TRUE)                 # Time of last observation (censoring)
    )) %>% 
  ungroup()
dat_ast <- dat %>% 
  group_by(releaseid) %>%
  summarize(
    event_status_ast = ifelse(any(event_ast == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
    time_to_event_ast = ifelse(
      any(event_ast == 1, na.rm = TRUE), 
      min(days[event_ast == 1], na.rm = TRUE), # Time of first event
      max(days, na.rm = TRUE)                 # Time of last observation (censoring)
    )) %>% 
  ungroup()

# dat_ratio <- dat %>% 
#   group_by(releaseid) %>%
#   summarize(
#     event_status_ratio = ifelse(any(event_ratio == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
#     time_to_event_ratio = ifelse(
#       any(event_ratio == 1, na.rm = TRUE), 
#       min(days[event_ratio == 1], na.rm = TRUE), # Time of first event
#       max(days, na.rm = TRUE)                 # Time of last observation (censoring)
#     )) %>% 
#   ungroup()

dat_covs <- today %>%
  filter(mvisit=="M00") %>%
  dplyr::select(all_of(c("releaseid","HbA1c")))
#Merge proteins in
dat <- tidylog::right_join(dat_covs,prot,by="releaseid")
dat <- tidylog::right_join(dat_alt,dat,by="releaseid")
dat <- tidylog::right_join(dat_ast,dat,by="releaseid")
# dat <- tidylog::right_join(dat_ratio,dat,by="releaseid")
rm(baseline,dat_alt,dat_ast,dat_covs,prot,today)

# length(colnames(dat))
# length(unique(colnames(dat)))
# length(hvg_proteins)
# length(unique(hvg_proteins))
# 
#Examine descrptive statostics
# data_covariates <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","BASELINE.csv"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "BASELINE.csv", temp_file)
data_covariates <- read.csv(temp_file)
gc()

data_covariates <- data_covariates %>%
  filter(days==0) %>%
  filter(releaseid %in% dat$releaseid)
dat <- tidylog::left_join(dat,data_covariates,by="releaseid")
length(unique(dat$releaseid)) #376
# dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
# dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)
#
label(dat$AGEBASE)      <- "Age (y)"
label(dat$sex)      <- "Sex (Male or Female)"
dat$sex <- factor(dat$sex)
# label(dat$sglt2_exclusive) <- "SGLT2 Inhibitors (Yes/No)"
# label(dat$glp1agonist) <- "GLP-1 Receptor Agonists (Yes/No)"
table1(~sex+HbA1c+AGEBASE+bmi,data=dat)
dat$obese <- ifelse(dat$bmi>=30,"Obesity","No Obesity")
label(dat$AGEBASE)      <- "Age (y)"
label(dat$sex)      <- "Sex (Male or Female)"
label(dat$obese)      <- "Obesity (BMI > 30: Yes vs. No)"
dat$obese <- factor(dat$obese)
dat$event_status_alt <- factor(dat$event_status_alt)
dat$event_status_ast <- factor(dat$event_status_ast)
# table1(~sex+HbA1c+AGEBASE+obese+time_to_event_alt+event_status_alt+time_to_event_ast+event_status_ast+time_to_event_ratio+event_status_ratio,data=dat)
table1(~sex+HbA1c+AGEBASE+obese+time_to_event_alt+event_status_alt+time_to_event_ast+event_status_ast,data=dat)
dat$obese <- factor(dat$obese)
table1(~sex+HbA1c+AGEBASE+obese,data=dat)

```

### Analysis Crude
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,5]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

results_total <- rbind(results_ast,results_alt)
results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

sig_results <- results_total %>% 
  filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$fdr < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$fdr < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "Log2HR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ratio %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
### Analysis Adjusted
#### FDR < 0.05
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_adj.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_adj.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio_adj.csv"))

# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$fdr < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$fdr < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_adj.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.05) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
#### p < 0.05
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  # mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_alt <- results_alt %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  #   mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_ast <- results_ast %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  #   mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_ratio <- results_ratio %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_adj.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_adj.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio_adj.csv"))

# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

#ALT
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$Pvalue < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$Pvalue < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_alt %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("P-value < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$Pvalue < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$Pvalue < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ast %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$Pvalue < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$Pvalue < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ratio %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
#### FDR < 0.1
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")


# write.csv(results_ast,"/home/hhampson/Results/today_proteomics_AST_adj_fdr_01.csv")
# write.csv(results_alt,"/home/hhampson/Results/today_proteomics_ALT_adj_fdr_01.csv")
# write.csv(results_ratio,"/home/hhampson/Results/today_proteomics_AST_ALT_ratio_adj_fdr_01.csv")

# # write file
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# write.csv(results_ast, temp_file, row.names = FALSE) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, bucket, 'Log2_today_proteomics_AST_adj_fdr_01.csv')



# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr<0.1 & results_alt$LogHR > 0, "#990000",
                            ifelse(results_alt$fdr<0.1 & results_alt$LogHR < 0, "#003366", "lightgray"))

# # Identify significant points (fdr<0.1)
# significant_df <- results_alt[results_alt$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.1) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_alt[results_alt$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png("/home/hhampson/Results/Plot_ALT_Proteomics_TODAY_Adjusted_fdr_01_log2.png", 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr<0.1 & results_ast$LogHR > 0, "#990000",
                            ifelse(results_ast$fdr<0.1 & results_ast$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ast[results_ast$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.1) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ast[results_ast$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_Adjusted_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png("/home/hhampson/Results/Plot_AST_Proteomics_TODAY_Adjusted_fdr_01_log2.png", 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)
results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR > 0, "#990000",
                              ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ratio[results_ratio$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.1) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ratio[results_ratio$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png(fs::path("/home/hhampson/Results/Plot_AST_ALT_Ratio_Proteomics_TODAY_fdr_01_log2.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
### GSEA Crude
```{r echo = F}
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

full_results <- read.csv(fs::path(dir.results,"today_proteomics_AST.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=entrez_gene_symbol,LogHR=log_hr)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
# gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_dHep <- full_results$LogHR
names(rankings_dHep) <- full_results$Gene
rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
plot(rankings_dHep)
min(rankings_dHep)
max(rankings_dHep)


set.seed(1234)

kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                              stats = rankings_dHep,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_dHep <- fgsea(pathways = reactome,
                           stats = rankings_dHep,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_dHep <- fgsea(pathways = go,
                     stats = rankings_dHep,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                         "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
rownames(dHep_fgsea) <- c("adj.pval", "p.val")
dHep_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"dHep_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_dHep, title = "dHep Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"dHep_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_dHep, title = "dHep Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"dHep_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

###ii. Old
```{r}
#Load in AST and ALT in today 
today <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","CBL.csv"))
# length(unique(today$releaseid)) - 699 ids
# today_M0 <- today %>%
#   filter(mvisit=="M00")
#dplyr::select(c("releaseid","ALT","AST"))
#Load in Proteomics in Today
prot <- readRDS(fs::path(dir.dat,"Liver project","today_subeomics.rds"))
prot <- prot[c(7326,7404,7397,which(grepl("seq.",colnames(prot))))] #length(unique(prot$releaseid)) - 376 unique ids
proteins <- colnames(prot)[which(grepl("seq.",colnames(prot)))]

#rm(today,today_M0,prot)

# #Determine which proteins correlate with genes associated with alt and ast
# #AST
# ast_genes <- read.xlsx(fs::path(dir.dat,"Liver project","Results","Bulk_Results_for_Ast Di (High vs. Low).xlsx"))
# ast_genes_pos <- ast_genes %>%
#   filter(p_val_adj<0.05) %>%
#   filter(avg_log2FC>0) %>%
#   arrange(desc(avg_log2FC)) %>%
#   dplyr::slice(1:200) 
# ast_genes_pos <- ast_genes_pos$Gene
# ast_genes_neg <- ast_genes %>%
#   filter(p_val_adj<0.05) %>%
#   filter(avg_log2FC<0) %>%
#   arrange(avg_log2FC) %>%
#   dplyr::slice(1:200) 
# ast_genes_neg <- ast_genes_neg$Gene
# ast_genes <- c(ast_genes_pos,ast_genes_neg)

#Key Protein Gene
key <- readRDS(fs::path(dir.dat,"Liver project","gene_prot.RDS"))
sens_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% sens_genes)]
prot_sens <- prot[c("releaseid","AGEBASE","sex",sens_proteins)]
data <- tidylog::right_join(today,prot_sens,by="releaseid")
data <- data %>% #filter out recruitment visits
  filter(mvisit!="R")

# Compute baseline ALT for each participant
data <- data %>%
  group_by(releaseid) %>%
  mutate(baseline_alt = first(ALT)) %>% 
  mutate(baseline_ast = first(AST)) %>% 
  ungroup()

#Check if ALT has doubled at each visit
data <- data %>%
  mutate(event_alt = ifelse(ALT >= 2 * baseline_alt, 1, 0)) %>% 
  mutate(event_ast = ifelse(AST >= 2 * baseline_ast, 1, 0))

# Ensure the event persists after it occurs
data <- data %>%
  group_by(releaseid) %>%
  mutate(event_alt = cummax(event_alt)) %>%  # Marks 1 for all visits after doubling occurs
  mutate(event_ast = cummax(event_ast)) %>% 
  ungroup() %>% 
  mutate(days_to_alt = ifelse(event_alt==1,days,))

#Censor individuals who didnt develop event


#Create loop for cox proportional hazards
#ALT
results_alt <- data.frame()
for (protein in sens_proteins){
  # formula <- as.formula(paste0("Surv(days, event_alt) ~ ", protein))
  formula <- as.formula(paste0("Surv(days, event_alt) ~ ", protein,"+AGEBASE+sex+HbA1c"))
  # Fit the Cox model
  cox_model <- coxph(formula, data = data)
  
  # Store the summary or model output
  LogHR <- summary(cox_model)$coef[1,1]
  Risk <- ifelse(LogHR>0,"Increased",
                 ifelse(LogHR<0,"Decreased","No Effect"))
  Pvalue <- summary(cox_model)$coef[1,5]
  results_data_alt <- data.frame(Protein=protein,Outcome="ALT",LogHazardRatio=LogHR,Risk=Risk,Pvalue=Pvalue)
  results_alt <- rbind(results_alt,results_data_alt)
}
rm(results_data_alt)
results_alt <- results_alt %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr")) %>% 
  mutate(sig=case_when(fdr<0.05 & Risk=="Increased" ~ "Significant Positive",
                       fdr<0.05 & Risk=="Decreased" ~"Significant Negative",
                       fdr>0.05~"Not Significant"))

#AST
results_ast <- data.frame()
for (protein in sens_proteins){
  # formula <- as.formula(paste0("Surv(days, event_ast) ~ ", protein))
  formula <- as.formula(paste0("Surv(days, event_ast) ~ ", protein,"+AGEBASE+sex+HbA1c"))
  # Fit the Cox model
  cox_model <- coxph(formula, data = data)
  
  # Store the summary or model output
  LogHR <- summary(cox_model)$coef[1,1]
  Risk <- ifelse(LogHR>0,"Increased",
                 ifelse(LogHR<0,"Decreased","No Effect"))
  Pvalue <- summary(cox_model)$coef[1,5]
  results_data_ast <- data.frame(Protein=protein,Outcome="AST",LogHazardRatio=LogHR,Risk=Risk,Pvalue=Pvalue)
  results_ast <- rbind(results_ast,results_data_ast)
}
rm(results_data_ast)
results_ast <- results_ast %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr")) %>% 
  mutate(sig=case_when(fdr<0.05 & Risk=="Increased" ~ "Significant Positive",
                       fdr<0.05 & Risk=="Decreased" ~"Significant Negative",
                       fdr>0.05~"Not Significant"))

#Combine Results
results <- rbind(results_ast,results_alt)
results <- results %>% 
  dplyr::rename(AptName=Protein)
results <- tidylog::left_join(results,key,by="AptName")
results <- results %>% 
  mutate(Gene_Name=paste0(EntrezGeneSymbol,"_",SeqId))
results_alt <- results %>% 
  filter(Outcome=="ALT") 
results_ast <- results %>% 
  filter(Outcome=="AST") 

#Save results
# write.csv(results_alt,fs::path(dir.results,"ALT_cox_results_unadjusted.csv"))
# write.csv(results_ast,fs::path(dir.results,"AST_cox_results_unadjusted.csv"))
write.csv(results_alt,fs::path(dir.results,"ALT_cox_results_adjusted.csv"))
write.csv(results_ast,fs::path(dir.results,"AST_cox_results_adjusted.csv"))

# Create the volcano plot
volcano_plot_alt <- ggplot(results_alt, aes(x = LogHazardRatio, y = -log10(fdr), color = sig)) +
  geom_point(alpha = 0.8, size = 2) +  # Points with transparency
  # scale_color_manual(values = c("grey", "red")) +  # Custom colors for significance
  scale_color_manual(values = c("Not Significant" = "grey", 
                                "Significant Positive" = "red", 
                                "Significant Negative" = "blue")) +
  theme_minimal() +  # Clean theme
  labs(
    title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of ALT (U/L), adjusted for Age, Sex, and HbA1c",
    # title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of ALT (U/L)",
    x = "Log Hazard Ratio",
    y = "-log10(FDR)"
  ) +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Highlight top significant genes (optional)
top_genes_alt <- subset(results_alt, sig== "Significant Positive" | sig=="Significant Negative")
if (nrow(top_genes_alt) > 0) {
  volcano_plot_alt <- volcano_plot_alt +
    # geom_text(data = top_genes_alt, aes(label = EntrezGeneSymbol), 
    #           vjust = 1.5, size = 5, color = "black")
    geom_text_repel(data = top_genes_alt, aes(label = Gene_Name), 
                    box.padding = 0.35, 
                    point.padding = 0.5, 
                    max.overlaps = Inf,  # Prevent overlap
                    size = 3, 
                    color = "black", 
                    segment.size = 0.5)
}
plot(volcano_plot_alt)

# Create the volcano plot
volcano_plot_ast <- ggplot(results_ast, aes(x = LogHazardRatio, y = -log10(fdr), color = sig)) +
  geom_point(alpha = 0.8, size = 2) +  # Points with transparency
  # scale_color_manual(values = c("grey", "red")) +  # Custom colors for significance
  scale_color_manual(values = c("Not Significant" = "grey", 
                                "Significant Positive" = "red", 
                                "Significant Negative" = "blue")) +
  theme_minimal() +  # Clean theme
  labs(
    title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of AST (U/L), adjusted for Age, Sex, and HbA1c",
    # title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of AST (U/L)",
    x = "Log Hazard Ratio",
    y = "-log10(FDR)"
  ) +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Highlight top significant genes (optional)
top_genes_ast <- subset(results_ast, sig== "Significant Positive" | sig=="Significant Negative")
if (nrow(top_genes_ast) > 0) {
  volcano_plot_ast <- volcano_plot_ast +
    # geom_text(data = top_genes_ast, aes(label = EntrezGeneSymbol), 
    #           vjust = 1.5, size = 5, color = "black")
    geom_text_repel(data = top_genes_ast, aes(label = Gene_Name), 
                    box.padding = 0.35, 
                    point.padding = 0.5, 
                    max.overlaps = Inf,  # Prevent overlap
                    size = 3, 
                    color = "black", 
                    segment.size = 0.5)
}
plot(volcano_plot_ast)

#Make barchart of significant with alt/ast & proteins


#Compare significant results from alt/ast to transcriptomics alt/ast 


```

#b. TEEN-LABs
```{r}
#Proteomics teen labs 
# load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "analyte_info_log2.rds", temp_file)
analyte_info <- readRDS(temp_file)
gc()

gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "df_log2.rds", temp_file)
df <- readRDS(temp_file)
gc()

#Remove na values for visit
df <- df %>% 
  filter(!is.na(visit))
# dat_baseline <- df %>% 
#   filter(visit=="Month 1")
# dat_followup <- df %>% 
#   filter(visit=="Month 6") 
# dat <- df %>% 
#   filter(visit=="Month 1" | visit=="Month 6")

#Protein key
key <- analyte_info %>% 
  dplyr::select(all_of(c("AptName","SeqId","EntrezGeneSymbol")))

#Gene Proteins
genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)] #3770 proteins
length(gene_proteins) #3770
# prot <- df[c("ID","visit",gene_proteins)]
# protein <- colnames(prot)[-c(1,2)] #3770
# prot_baseline <- prot %>% 
#   filter(visit=="Month 1")
# prot_followup <- prot %>% 
#   filter(visit=="Month 6")
# #Name proteins baseline or followup 
# colnames(prot_baseline)[-c(1,2)] <- paste0(colnames(prot_baseline)[-c(1,2)],"_baseline")
# colnames(prot_followup)[-c(1,2)] <- paste0(colnames(prot_followup)[-c(1,2)],"_followup")
# prot_baseline <- prot_baseline %>% 
#   dplyr::select(-visit)
# prot_baseline_dat <- prot_baseline
# prot_followup <- prot_followup %>% 
#   dplyr::select(-visit)

# prot <- tidylog::left_join(prot_baseline,prot_followup,by="ID")
# prot_id <- unique(prot$ID) #64 unique participants with multiple timepoints of data

# #Merge alt and protein data togeth
# df <- df %>% 
#   dplyr::select(c("ID","visit","age","SEX","ETHN","bmi","HBA1C","NAFLD0","NAFLD1",
#                   "NAFLD2","NAFLD3","NAFLD4","NAFLD5","NAFLD6","ALT","AST",all_of(gene_proteins)))
#Merge alt and protein data togeth
df <- df %>% 
  dplyr::select(c("ID","visit","age","SEX","ETHN","bmi","HBA1C","ALT","AST",all_of(gene_proteins)))

# # Scatter plot with individual trajectories
# p3 <- ggplot(df, aes(x = seq.10001.7, y = ALT)) +
#   geom_point(aes(color = factor(visit)), alpha = 0.6) +
#   geom_path(aes(group = ID), alpha = 0.2) +
#   geom_smooth(method = "lm", color = "black", linewidth= 0.5,se=F) +
#   scale_color_viridis_d(name = "Time") +
#   theme_minimal() +
#   labs(title = "ALT vs Protein Levels",
#        subtitle = "Lines connect same subject over time",
#        x = "Protein Level",
#        y = "ALT Level") +
#   theme(plot.title = element_text(face = "bold"))
# 
# print(p3)
# 
# # # Basic spaghetti plot
# ggplot(df, aes(x = visit, y = ALT, group = ID)) +
#   geom_line(alpha = 0.5, aes(color=ID)) +
#   geom_point(alpha = 0.5, size = 1.5,color="gray40") +
#   labs(title = "ALT Values Over Time by Individual",
#        x = "Visit",
#        y = "ALT") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

# library(lme4)
# library(lmerTest)

# First, ensure time is numeric for random slopes
# Convert visit to numeric (assuming ordered visits)
df$time_numeric <- as.numeric(factor(df$visit)) - 1  # Start at 0 for baseline

```
###i. Unadjusted
```{r}
# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
key <- key %>% 
  dplyr::rename(Protein=AptName)
alt_results <- tidylog::left_join(alt_results,key,by="Protein")
alt_results <- alt_results %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Crude_Results_Proteomics.csv"))

alt_results$color <- ifelse(alt_results$fdr < 0.05 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr < 0.05 & alt_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- alt_results[alt_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_alt
png(fs::path(dir.results,"ALT_Proteins_TeenLabs.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))


```
###ii. Adjusted
```{r}
#Proteomics teen labs 
load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
#Remove na values for visit
df <- df %>% 
  filter(!is.na(visit))

#Protein key
key <- analyte_info %>% 
  dplyr::select(all_of(c("AptName","SeqId","EntrezGeneSymbol")))

#Gene Proteins
genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)] #3770 proteins


#Merge alt and protein data togeth
df <- df %>% 
  dplyr::select(c("ID","visit","age","SEX","ETHN","bmi","HBA1C","NAFLD0","NAFLD1",
                  "NAFLD2","NAFLD3","NAFLD4","NAFLD5","NAFLD6","ALT","AST",all_of(gene_proteins)))

# First, ensure time is numeric for random slopes
# Convert visit to numeric (assuming ordered visits)
df$time_numeric <- as.numeric(factor(df$visit)) - 1  # Start at 0 for baseline

# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
# alt_results <- tidylog::left_join(alt_results,key,by="Protein")
# alt_results <- alt_results %>% 
#   dplyr::rename(Gene=EntrezGeneSymbol)
write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Adj_Results_Proteomics.csv"))

alt_results$color <- ifelse(alt_results$fdr < 0.05 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr < 0.05 & alt_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- alt_results[alt_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_alt
png(fs::path(dir.results,"ALT_Proteins_TeenLabs_Adjusted.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))

# Model with random intercept for time
ast_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ AST + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  ast_results <- rbind(ast_results,results)
}
ast_results <- ast_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


ast_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ AST + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    ast_results <<- rbind(ast_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
ast_results <- ast_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
ast_results <- ast_results %>% 
  filter(Singular=="FALSE")

ast_results <- ast_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
ast_results <- tidylog::left_join(ast_results,key,by="Protein")
ast_results <- ast_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
write.csv(alt_results,fs::path(dir.results,"TeenLABS_AST_Adj_Results_Proteomics.csv"))

ast_results$color <- ifelse(ast_results$fdr < 0.05 & ast_results$Beta > 0, "#990000",
                            ifelse(ast_results$fdr < 0.05 & ast_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- ast_results[ast_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(ast_results$Protein))
ast_results$Outcome <- "AST"

volcano_plot <- ggplot(ast_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. AST (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_ast
png(fs::path(dir.results,"AST_Proteins_TeenLabs_Adjusted.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()

results_ratio$color <- ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR > 0, "#990000",
                              ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ratio[results_ratio$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.1) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ratio[results_ratio$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
```
###iii. FDR<0.1
```{r}
# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.1,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr<0.1, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.1 & Beta>0 ~ "Significant Positive",
                       fdr<0.1 & Beta<0 ~"Significant Negative",
                       fdr>0.1~"Not Significant"))
#Convert protein names to gene names
key <- key %>%
  dplyr::rename(Protein=AptName)
alt_results <- tidylog::left_join(alt_results,key,by="Protein")
alt_results <- alt_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Adj_Results_Proteomics_FDR_01.csv"))
write.csv(alt_results,"/home/hhampson/Results/TeenLABS_ALT_Adj_Results_Proteomics_FDR_01_Log2.csv")


alt_results$color <- ifelse(alt_results$fdr<0.1 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr<0.1 & alt_results$Beta < 0, "#003366", "lightgray"))


# Identify significant points (fdr<0.1)
significant_df <- alt_results[alt_results$fdr<0.1, ]

# Select top 20 positive and top 20 negative Beta genes from significant results
top_labels <- significant_df %>%
  arrange(desc(Beta)) %>%
  slice_head(n = 20) %>%
  bind_rows(
    significant_df %>%
      arrange(Beta) %>%
      slice_head(n = 20)
  )

# Set variables
N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

# Create volcano plot
volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  theme_bw() +
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("fdr<0.1, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # # Add labels for top positive and negative significant points
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = -0.5, hjust = 0.5, size = 3, check_overlap = TRUE, color = "black") +
  # Add labels with lines pointing to points
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  facet_wrap(~Outcome)

volcano_plot

# volcano_plot_alt
png("/home/hhampson/Results/ALT_Proteins_TeenLabs_Adjusted_FDR_01_log2.png", width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))

# Model with random intercept for time
ast_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ AST + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  ast_results <- rbind(ast_results,results)
}
ast_results <- ast_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.1,"*",""))


ast_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ AST + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    ast_results <<- rbind(ast_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
ast_results <- ast_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr<0.1, "*", ""))
ast_results <- ast_results %>% 
  filter(Singular=="FALSE")

ast_results <- ast_results %>% 
  mutate(sig=case_when(fdr<0.1 & Beta>0 ~ "Significant Positive",
                       fdr<0.1 & Beta<0 ~"Significant Negative",
                       fdr>0.1~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
ast_results <- tidylog::left_join(ast_results,key,by="Protein")
ast_results <- ast_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(ast_results,"/home/hhampson/Results/TeenLABS_AST_Adj_Results_Proteomics_FDR_01_log2.csv")

# Identify significant points (fdr<0.1)
# significant_df <- ast_results[ast_results$fdr<0.1, ]
ast_results$color <- ifelse(ast_results$fdr<0.1 & ast_results$Beta > 0, "#990000",
                            ifelse(ast_results$fdr<0.1 & ast_results$Beta < 0, "#003366", "lightgray"))


# Identify significant points (fdr<0.1)
significant_df <- ast_results[ast_results$fdr<0.1, ]

# Select top 20 positive and top 20 negative Beta genes from significant results
top_labels <- significant_df %>%
  arrange(desc(Beta)) %>%
  slice_head(n = 20) %>%
  bind_rows(
    significant_df %>%
      arrange(Beta) %>%
      slice_head(n = 20)
  )

# Set variables
N <- length(unique(df$ID))
num_proteins <- length(unique(ast_results$Protein))
ast_results$Outcome <- "AST"

# Create volcano plot
volcano_plot <- ggplot(ast_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  theme_bw() +
  labs(
    title = "Mixed-Effect Model for Proteins vs. AST (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("fdr<0.1, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # # Add labels for top positive and negative significant points
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = -0.5, hjust = 0.5, size = 3, check_overlap = TRUE, color = "black") +
  # Add labels with lines pointing to points
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  facet_wrap(~Outcome)

volcano_plot

# volcano_plot_ast
png("/home/hhampson/Results/AST_Proteins_TeenLabs_Adjusted_FDR_01_log2.png", width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(ast_results,fs::path(dir.results,"AST_Proteins_Teenlabs.csv"))
```

### Other outcomes
```{r}
#NAFLD
NAFLD1_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ NAFLD1 + time_numeric + (1|ID)"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    NAFLD1_results <- rbind(NAFLD1_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    NAFLD1_results <- rbind(NAFLD1_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    NAFLD1_results <<- rbind(NAFLD1_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
NAFLD1_results <- NAFLD1_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
NAFLD1_results <- NAFLD1_results %>% 
  filter(Singular=="FALSE")

NAFLD1_results <- NAFLD1_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
key <- key %>% 
  dplyr::rename(Protein=AptName)
NAFLD1_results <- tidylog::left_join(NAFLD1_results,key,by="Protein")
NAFLD1_results <- NAFLD1_results %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

NAFLD1_results$color <- ifelse(NAFLD1_results$fdr < 0.05 & NAFLD1_results$Beta > 0, "#990000",
                               ifelse(NAFLD1_results$fdr < 0.05 & NAFLD1_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- NAFLD1_results[NAFLD1_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(NAFLD1_results$Protein))

volcano_plot <- ggplot(NAFLD1_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. NAFLD1 (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")

# volcano_plot_NAFLD1
png(fs::path(dir.results,"NAFLD1_Proteins_TeenLabs.png"),width=4000,height=4000,res=300)
print(volcano_plot)
dev.off()
```

```{r}
# 
# # Calculate mean ALT for each visit
# mean_data <- df_sub %>%
#   group_by(visit) %>%
#   summarise(mean_ALT = mean(ALT, na.rm = TRUE))
# 
# # Create plot with individual lines and mean trend
# ggplot(df_sub, aes(x = visit, y = ALT)) +
#   geom_line(aes(group = ID), alpha = 0.3, color = "gray60") +
#   geom_point(aes(group = ID), alpha = 0.3, size = 1, color = "gray60") +
#   geom_line(data = mean_data, aes(x = visit, y = mean_ALT, group = 1), 
#             color = "red", size = 2) +
#   geom_point(data = mean_data, aes(x = visit, y = mean_ALT), 
#              color = "red", size = 3) +
#   labs(title = "ALT Values Over Time by Individual",
#        subtitle = "Red line shows mean trend",
#        x = "Visit",
#        y = "ALT") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggplot(df_sub, aes(x = visit, y = ALT, group = ID, color = factor(ID))) +
#   geom_line(alpha = 0.7, size = 1) +
#   geom_point(alpha = 0.7, size = 2) +
#   labs(title = "ALT Values Over Time by Individual",
#        x = "Visit",
#        y = "ALT",
#        color = "Individual ID") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
#   theme(legend.position = "none")
# 
# # Basic spaghetti plot
# ggplot(df_sub, aes(x = visit, y = AST, group = ID)) +
#   geom_line(alpha = 0.5, color = "gray40") +
#   geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
#   labs(title = "AST Values Over Time by Individual",
#        x = "Visit",
#        y = "AST") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# # Calculate mean AST for each visit
# mean_data <- df_sub %>%
#   group_by(visit) %>%
#   summarise(mean_AST = mean(AST, na.rm = TRUE))
# 
# # Create plot with individual lines and mean trend
# ggplot(df_sub, aes(x = visit, y = AST)) +
#   geom_line(aes(group = ID), alpha = 0.3, color = "gray60") +
#   geom_point(aes(group = ID), alpha = 0.3, size = 1, color = "gray60") +
#   geom_line(data = mean_data, aes(x = visit, y = mean_AST, group = 1), 
#             color = "red", size = 2) +
#   geom_point(data = mean_data, aes(x = visit, y = mean_AST), 
#              color = "red", size = 3) +
#   labs(title = "AST Values Over Time by Individual",
#        subtitle = "Red line shows mean trend",
#        x = "Visit",
#        y = "AST") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggplot(df_sub, aes(x = visit, y = AST, group = ID, color = factor(ID))) +
#   geom_line(alpha = 0.7, size = 1) +
#   geom_point(alpha = 0.7, size = 2) +
#   labs(title = "AST Values Over Time by Individual",
#        x = "Visit",
#        y = "AST",
#        color = "Individual ID") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
#   theme(legend.position = "none")
# 
# missing_counts <- df_sub %>%
#   group_by(ID) %>%
#   summarise(
#     total_timepoints = n(),
#     missing_ALT = sum(is.na(ALT)),
#     missing_AST = sum(is.na(AST)),
#     complete_ALT = sum(!is.na(ALT)),
#     complete_AST = sum(!is.na(AST))
#   )
# 
# print(missing_counts)
# 
# # Calculate percentages for ALT
# ALT_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_ALT = sum(missing_ALT >= 1),
#     participants_missing_more_than_5_ALT = sum(missing_ALT > 5),
#     percent_missing_at_least_one_ALT = round(100 * participants_missing_at_least_one_ALT / total_participants, 2),
#     percent_missing_more_than_5_ALT = round(100 * participants_missing_more_than_5_ALT / total_participants, 2)
#   )
# 
# # Calculate percentages for AST
# AST_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_AST = sum(missing_AST >= 1),
#     participants_missing_more_than_5_AST = sum(missing_AST > 5),
#     percent_missing_at_least_one_AST = round(100 * participants_missing_at_least_one_AST / total_participants, 2),
#     percent_missing_more_than_5_AST = round(100 * participants_missing_more_than_5_AST / total_participants, 2)
#   )

# # Find columns with "baseline" and "followup"
# baseline_cols <- grep("_baseline$", colnames(prot), value = TRUE)
# followup_cols <- grep("_followup$", colnames(prot), value = TRUE)
# 
# # Sort to ensure matching order
# baseline_cols <- sort(baseline_cols)
# followup_cols <- sort(followup_cols)
# 
# # Create new columns for differences
# for (i in seq_along(baseline_cols)) {
#   protein_name <- sub("_baseline$", "", baseline_cols[i])  # Get protein name (e.g., "protein1")
#   diff_col <- paste0(protein_name, "_diff")               # Create a difference column name
#   prot[[diff_col]] <- prot[[followup_cols[i]]] - prot[[baseline_cols[i]]]
# }
# 
# #Covariates at baseline
# dat_cov <- dat %>% 
#   filter(visit=="Month 1") %>% 
#   dplyr::select(all_of(c("ID","SEX","HBA1C","age"))) 
# 
# rm(df,analyte_info)
# 
#ALT/AST
# liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
liv <- liv %>%
  dplyr::rename(visit=Visit) %>%
  # filter(visit==1 | visit==6) %>%
  # mutate(visit=case_when(visit==1~"Month 1",
  #                        visit==6~"Month 6")) %>%
  mutate(across(everything(),~ifelse(.==-5,NA,.))) %>%
  mutate(across(everything(),~ifelse(.==-7,1,.))) %>% 
  filter(!is.na(ALT) & !is.na(AST))
#201 have alt and/or ast

# liv_baseline <- liv %>% 
#   filter(visit=="Month 1") %>% 
#   dplyr::select(-visit) %>% 
#   dplyr::rename(ALT_baseline=ALT,
#                 AST_baseline=AST)
# liv_followup <- liv %>% 
#   filter(visit=="Month 6") %>% 
#   dplyr::select(-visit) %>% 
#   dplyr::rename(ALT_followup=ALT,
#                 AST_followup=AST)
# liv <- tidylog::left_join(liv_baseline,liv_followup,by="ID")
# liv <- liv %>% 
#   mutate(ALT_diff = ALT_followup-ALT_baseline,
#          AST_diff = AST_followup-AST_baseline) 
# 
# 
# dat_cov$ID <- as.character(dat_cov$ID)
prot$ID<- as.character(prot$ID)
# 
# #Baseline proteins & baseline covariates and baseline and followup alt/ast
# dat_all <- tidylog::right_join(dat_cov,liv,by=c("ID"))
# dat_all <- tidylog::left_join(dat_all,prot,by=c("ID"))
dat_all <- tidylog::left_join(liv,prot,by=c("ID"))
# 
# #Run linear mixed effect model & difference model 
# protein_diff <- paste0(protein,"_diff")
# results <- data.frame()
# covs <- c("age","SEX","HBA1C")
# for (x in protein_diff) {
#   for (y in c("AST_diff","ALT_diff")) {
#     M0_crude <- as.formula(paste0(y,"~",x))
#     M0_adj <- as.formula(paste0(y,"~",x,"+",paste(covs, collapse = "+")))
#     M1_crude <- lm(M0_crude,data=dat_all)
#     M1_adj <- lm(M0_adj,data=dat_all)
#     coef_crude <- summary(M1_crude)$coef[2,1]
#     coef_adj <- summary(M1_adj)$coef[2,1]
#     p_crude <- summary(M1_crude)$coef[2,4]
#     p_adj <- summary(M1_adj)$coef[2,4]
#     diff_results <- data.frame(Protein=x,Enzyme=y,Coef=coef_adj,PValue=p_adj)
#     results <- rbind(results,diff_results)
#   }
# }
# r_alt <- results %>% 
#   filter(Enzyme=="ALT_diff") %>% 
#   mutate(fdr=p.adjust(PValue,method="fdr"))
# r_ast <- results %>% 
#   filter(Enzyme=="AST_diff") %>% 
#   mutate(fdr=p.adjust(PValue,method="fdr"))
# results <- rbind(r_alt,r_ast)
# results <- results %>% 
#   mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results,fs::path(dir.results,"Diff_Results_Liver_Teenlabs_Imputed.csv"))
# 
# #Baseline protein with change in ALT/AST pre and post surgery
# liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
# liv <- liv %>% 
#   dplyr::rename(visit=Visit) %>% 
#   filter(visit==1 | visit==6) %>% 
#   mutate(visit=case_when(visit==1~"Month 1",
#                          visit==6~"Month 6")) %>% 
#   mutate(across(everything(),~ifelse(.==-5,NA,.))) %>% 
#   mutate(across(everything(),~ifelse(.==-7,NA,.)))
# prot_baseline_dat$ID <- as.character(prot_baseline_dat$ID)
# dat_baseline <- tidylog::left_join(liv,prot_baseline_dat,by=c("ID"))
# dat_baseline <- tidylog::left_join(dat_cov,dat_baseline,by="ID")
# dat_baseline <- dat_baseline %>% 
#   mutate(time=case_when(visit=="Month 1"~1,
#                         visit=="Month 6"~6))
# 
# #Linear Mixed Effects Model
# protein_baseline <- paste0(protein,"_baseline")
# covs <- c("age","SEX","HBA1C")
# 
# results <- data.frame()
# for (x in c("AST","ALT")) {
#   for (y in protein_baseline) {
#     M0_crude <- as.formula(paste0(y,"~",x,"+time+(1|ID)"))
#     M0_adj <- as.formula(paste0(y,"~",x,"*time+",paste(covs, collapse = "+"),"+(1|ID)"))
#     M1_crude <- lmer(M0_crude,data=dat_baseline)
#     M1_adj <- lmer(M0_adj,data=dat_baseline)
#     Main <- summary(M1_adj)$coef[2,1]
#     Main_p <- summary(M1_adj)$coef[2,5]
#     Time <- summary(M1_adj)$coef[3,1]
#     Time_p <- summary(M1_adj)$coef[3,5]
#     Int <- summary(M1_adj)$coef[7,1]
#     Int_p <- summary(M1_adj)$coef[7,5]
#     results_int <- data.frame(Protein=x,Enzyme=y,Main,Main_p,Time,Time_p,Int,Int_p)
#     results <- rbind(results,results_int)
#   }
# }
# r_alt <- results %>% 
#   filter(Enzyme=="ALT") %>% 
#   mutate(Main_fdr=p.adjust(Main_p,method="fdr")) %>% 
#   mutate(Int_fdr=p.adjust(Int_p,method="fdr"))
# r_ast <- results %>% 
#   filter(Enzyme=="AST") %>% 
#   mutate(Main_fdr=p.adjust(Main_p,method="fdr")) %>% 
#   mutate(Int_fdr=p.adjust(Int_p,method="fdr"))
# results <- rbind(r_alt,r_ast)
# results <- results %>% 
#   mutate(Main_sig=ifelse(Main_fdr<0.05,"*","")) %>% 
#   mutate(Int_sig=ifelse(Int_fdr<0.05,"*",""))
# results$AptName <- str_remove(results$Protein,"_baseline")
# results <- tidylog::left_join(results,key,by="AptName")
# write.csv(results,fs::path(dir.results,"LMEM_TeenLabs_Liver_Results_Imputed.csv"))
```
###ii. Old
```{r}
#Proteomics teen labs 
load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
#Senescence Proteins
sens_proteins <- analyte_info$AptName[which(analyte_info$EntrezGeneSymbol %in% sens_genes)]

alt_ast <- read.csv(fs::path(dir.dat,"Liver Project","Teen-LABS_AST_ALT.csv")) %>% 
  filter(Visit==1|Visit==6) %>% 
  mutate(Visit=ifelse(Visit==1,"PreSurgery","PostSurgery"))
df_baseline <- df %>% 
  filter(visit=="Month 1") %>% 
  dplyr::rename(Visit=visit) %>% 
  mutate(Visit="PreSurgery") %>% 
  mutate(ID=as.character(ID)) %>% 
  dplyr::select(all_of(c("ID",sens_proteins)))
# df_followup <- df %>% 
#   filter(visit=="Month 6") %>% 
#   dplyr::rename(Visit=visit) %>% 
#   mutate(Visit="PostSurgery") %>% 
#   mutate(ID=as.character(ID)) %>% 
#   dplyr::select(all_of(c("ID","Visit",sens_proteins)))

#Prepare data
dat_baseline <- tidylog::left_join(alt_ast,df_baseline,by=c("ID"))
dat <- dat_baseline
rm(dat_baseline)
# dat_followup <- tidylog::left_join(dat,df_followup,by=c("ID"))
# dat_all <- tidylog::left_join(dat,df,by=c("ID","Visit"))

hist(dat$AST)
hist(dat$ALT)
#Log transform alt and ast
dat$ALT_log <- log(dat$ALT)
dat$AST_log <- log(dat$AST)
dat$Visit <- factor(dat$Visit)
dat$Visit <- relevel(dat$Visit, ref = "PreSurgery")

# #Make sure everyone has baseline proteins
# prot <- df %>% 
#   dplyr::select(c("ID","Visit",sens_proteins))

#Linear Mixed Effects Model
#ALT
plot_list <- list()
results <- data.frame()
for (protein in sens_proteins) {
  gene_name <- paste0(analyte_info$EntrezGeneSymbol[which(analyte_info$AptName %in% protein)],"_",analyte_info$SeqId[which(analyte_info$AptName %in% protein)])
  M0 <- as.formula(paste0("ALT_log ~ ",protein,"*Visit + (1 | ID)"))
  M1 <- lmer(M0, data = dat)
  main_effect <- summary(M1)$coef[2,1]
  main_p <- summary(M1)$coef[2,5]
  time_effect <- summary(M1)$coef[3,1]
  time_p <- summary(M1)$coef[3,5]
  int_effect <- summary(M1)$coef[4,1]
  int_p <- summary(M1)$coef[4,5]
  results_dat <- data.frame(Apt=gene_name,Outcome="ALT_log",MainEffect=main_effect,MainPVal=main_p,TimeEffect=time_effect,TimePVal=time_p,Interaction=int_effect,IntPVal=int_p)
  results <- rbind(results,results_dat)
  
  int_plot <- ggplot(dat, aes(x = !!sym(protein), y = ALT_log, color = Visit)) +
    geom_point() +
    geom_smooth(method = "lm", se = TRUE) +
    labs(title = paste0("Interaction between ",gene_name," and Visit on ALT_log"))+
    theme_minimal()
  
  # Create the spaghetti plot
  spaghetti_plot <- ggplot(dat, aes(x = Visit, y = ALT_log, group = ID, color = !!sym(protein))) +
    geom_line() +  # Connect ALT levels for each individual
    geom_point() +  # Add points for ALT levels at each time point
    # scale_color_viridis_d(guide = "none") +  # Optional: Viridis color palette, hide legend
    # scale_color_viridis_c(guide = "colorbar", name = "Protein") +
    scale_color_gradient(low = "blue", high = "red", name = gene_name) +
    # scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(dat[[protein]],na.rm=T), name = "Protein") +
    labs(
      title = paste0("Spaghetti Plot of ALT Levels Pre- and Post-Surgery by ",gene_name),
      x = "Visit",
      y = "ALT Levels"
    ) +
    theme_minimal() +
    theme(panel.grid.major = element_line(color = "gray85")) 
  
  # Combine the two plots
  combined_plot <- plot_grid(int_plot, spaghetti_plot, ncol = 1, labels = c("A", "B"))
  
  # Add to the list
  plot_list[[protein]] <- combined_plot
}

write.csv(results,fs::path(dir.results,paste0("Interaction between ",gene_name," and Visit on ALT_log.csv")))
# # Save all combined plots to a single PDF
# pdf("combined_interaction_and_spaghetti_plots.pdf", width = 10, height = 14)
# for (combined_plot in plot_list) {
#   plot(combined_plot)
# }
# dev.off()

#AST
plot_list <- list()
results <- data.frame()
for (protein in sens_proteins) {
  gene_name <- paste0(analyte_info$EntrezGeneSymbol[which(analyte_info$AptName %in% protein)],"_",analyte_info$SeqId[which(analyte_info$AptName %in% protein)])
  M0 <- as.formula(paste0("AST_log ~ ",protein,"*Visit + (1 | ID)"))
  M1 <- lmer(M0, data = dat)
  main_effect <- summary(M1)$coef[2,1]
  main_p <- summary(M1)$coef[2,5]
  time_effect <- summary(M1)$coef[3,1]
  time_p <- summary(M1)$coef[3,5]
  int_effect <- summary(M1)$coef[4,1]
  int_p <- summary(M1)$coef[4,5]
  results_dat <- data.frame(Apt=gene_name,Outcome="AST_log",MainEffect=main_effect,MainPVal=main_p,TimeEffect=time_effect,TimePVal=time_p,Interaction=int_effect,IntPVal=int_p)
  results <- rbind(results,results_dat)
  
  int_plot <- ggplot(dat, aes(x = !!sym(protein), y = ALT_log, color = Visit)) +
    geom_point() +
    geom_smooth(method = "lm", se = TRUE) +
    labs(title = paste0("Interaction between ",gene_name," and Visit on AST_log"))+
    theme_minimal()
  
  # Create the spaghetti plot
  spaghetti_plot <- ggplot(dat, aes(x = Visit, y = ALT_log, group = ID, color = !!sym(protein))) +
    geom_line() +  # Connect ALT levels for each individual
    geom_point() +  # Add points for ALT levels at each time point
    # scale_color_viridis_d(guide = "none") +  # Optional: Viridis color palette, hide legend
    # scale_color_viridis_c(guide = "colorbar", name = "Protein") +
    scale_color_gradient(low = "blue", high = "red", name = gene_name) +
    # scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(dat[[protein]],na.rm=T), name = "Protein") +
    labs(
      title = paste0("Spaghetti Plot of AST Levels Pre- and Post-Surgery by ",gene_name),
      x = "Visit",
      y = "ALT Levels"
    ) +
    theme_minimal() +
    theme(panel.grid.major = element_line(color = "gray85")) 
  
  # Combine the two plots
  combined_plot <- plot_grid(int_plot, spaghetti_plot, ncol = 1, labels = c("A", "B"))
  
  # Add to the list
  plot_list[[protein]] <- combined_plot
}

write.csv(results,fs::path(dir.results,paste0("Interaction between ",gene_name," and Visit on AST_log.csv")))
# # Save all combined plots to a single PDF
# pdf("combined_interaction_and_spaghetti_plots.pdf", width = 10, height = 14)
# for (combined_plot in plot_list) {
#   plot(combined_plot)
# }
# dev.off()
```
