---
title: "Liver_snRNAseq_Lambda"
output: html_document
date: "2025-04-23"
---

# 1. Set up Libraries & Directores
```{r libraries, echo=F, include = F}
#Load Libraries
library(reticulate)
use_python("/home/hhampson/miniconda3/bin/python", required = TRUE)
source("Lambda_Libraries.R")

#Local file path
# dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
# dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
# dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
# dir.results <- c("/Users/hhampson/Documents/UW/1_Ongoing Projects/Liver scRNAseq/2_Results")

#Lambda file path
# dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
# dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
# dir.results <- c(fs::path(dir.dat,"Liver project/Results"))

# #Mac Studio File Path
# dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
# dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver Project/NEBULA Results")
# # # dir.ipa <- c("/Users/hhampson/Documents/IPA/Results")

#Laura's Mac Studio File Path
# dir.dat <- c("/Users/haileyhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
# dir.results <- c("/Users/haileyhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver Project/NEBULA Results")

#Load functions
source("Lambda_Liver_Functions.R")
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")

# knitr::opts_knit$set(root.dir = dir.results)
```


# 2. Load Data, Pre-Processing & Qualtiy Control
```{r, Cyberduck setup}
# install.packages("reticulate")
# library(reticulate)
# reticulate::use_python("/home/hhampson/miniconda3/bin/python") # replace with your username

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/home/hhampson/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")

# read file
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket,"Liver transcriptomics/Single nucleus RNA seq/NoRef_PetterLiver_ClinData_Labels_Char_041924.rds", temp_file)
so_liver_sn <- readRDS(temp_file)

DefaultAssay(so_liver_sn) <- "RNA"
dim(so_liver_sn)#36601 130124
nrow(so_liver_sn) #36,601 genes
ncol(so_liver_sn) # 130,124 nuceli
invisible(gc())

#Load metadata
gc()
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "Liver transcriptomics/liver_biopsy_metadata_PN.csv", temp_file)
meta_liver_raw <- read.csv(temp_file)
gc()
```

## c. Load MetaData, Clean and Merge
```{r}
#Format
unique(meta_liver_raw$Kit_Lot)
unique(meta_liver_raw$StudyID)
meta_liver_raw <- meta_liver_raw %>%
  filter(StudyID!="IT2D-18") %>%
  filter(StudyID!="IT2D-16")

#Create Liver Status Variables
meta_liver_raw <- meta_liver_raw %>%
  mutate(steatosis_cat = ifelse((steatosis_grade==0 | steatosis_grade==1),"Low Steatosis (0+1)","High Steatosis (2+3)")) %>%
  mutate(fibrosis_cat = case_when(steatosis_grade==0 & fibrosis_stage==0 ~ "No Steatosis, No Fibrosis",
                                  steatosis_grade>0 & fibrosis_stage==0 ~ "Any Steatosis, No Fibrosis",
                                  steatosis_grade>0 & fibrosis_stage>0 ~ "Any Fibrosis & Any Steatosis"))

#Create Liver Status Variables
meta_liver_raw <- meta_liver_raw %>%
  # mutate(steatosis_cat = ifelse((steatosis_grade==0 | steatosis_grade==1),"Low Steatosis (0+1)","High Steatosis (2+3)")) %>%
  mutate(ballooning_category = case_when(hepatocyte_ballooning_score == 0 | hepatocyte_ballooning_score == 1 ~ "Low Hepatocyte Ballooning (0+1)",
                                         hepatocyte_ballooning_score == 2 ~ "High Hepatocyte Ballooning (2)")) %>% 
  mutate(ballooning_steatosis_cat = case_when(steatosis_grade==0 & hepatocyte_ballooning_score==0 ~ "No Steatosis, No Ballooning",
                                              steatosis_grade>0 & hepatocyte_ballooning_score>0 ~ "Any Steatosis, Any Ballooning",
                                              steatosis_grade>0 & hepatocyte_ballooning_score==0 ~ "Any Steatosis, No Ballooning")) %>% 
  mutate(disease_cat = case_when(ballooning_steatosis_cat=="No Steatosis, No Ballooning" ~ "Low",
                                 ballooning_steatosis_cat=="Any Steatosis, Any Ballooning" ~ "High",
                                 ballooning_steatosis_cat=="Any Steatosis, No Ballooning" ~ "Medium"))

#Merge liver sn metadata with meta liver raw metadata
meta_liver_sn <-  so_liver_sn@meta.data[,1:11] %>%
  dplyr::mutate(RNAlater_ID = SampleID) %>%
  left_join(meta_liver_raw)
#Merge into seurat object
rownames(meta_liver_sn) <- rownames(so_liver_sn@meta.data)
so_liver_sn <- AddMetaData(so_liver_sn, meta_liver_sn)
rm(meta_liver_sn,meta_liver_raw)

#Switch default assay in seurat object to RNA
DefaultAssay(so_liver_sn) <- "RNA"
invisible(gc())

dim(so_liver_sn) #36601 130124
ncol(so_liver_sn) #130124 nuclei 
nrow(so_liver_sn) # 36601 genes

#YE JI's filtering code for percent expression 
#Filter out rare genes expressed in less than "gene_pct" of cells
expr_matrix <- as.matrix(GetAssayData(so_liver_sn, layer = "counts"))
# expr_matrix <- as.matrix(GetAssayData(so_liver_sn, assay = "RNA", layer = "counts"))
expr_matrix <- so_liver_sn@assays$RNA@counts
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.01])
so_liver_sn <- subset(so_liver_sn, features = genes_to_keep)
ncol(so_liver_sn) #130,124 nuclei
nrow(so_liver_sn) # 11313 genes

#Save a seurat object with mitochondrial genes in it for oroboros analysis
so_oro <- so_liver_sn

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_liver_sn), value = TRUE)
so_liver_sn <- subset(so_liver_sn, features = setdiff(rownames(so_liver_sn@assays$RNA@counts), mito_genes))
dim(so_liver_sn@assays$RNA@counts) #9276 186125
dim(so_liver_sn@assays$RNA@data) #9276 186125
dim(so_liver_sn@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_liver_sn@assays$RNA@counts))) #0
ncol(so_liver_sn) #130124 cells
nrow(so_liver_sn) #11300 genes

#Check oro so
ncol(so_oro) #130124 cells
nrow(so_oro) #11313 genes

#Step 3: Remove ribosomal Genes
# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
)
so_liver_sn <- subset(so_liver_sn, features = setdiff(rownames(so_liver_sn), ribo_genes))
# sum(grepl("^MT-", rownames(so_liver_sn))) #0
length(which(rownames(so_liver_sn) %in% ribo_genes)) #0
ncol(so_liver_sn) #130,124 cells
nrow(so_liver_sn) #11224 genes

#Also perform to oro so
so_oro <- subset(so_oro, features = setdiff(rownames(so_oro), ribo_genes))
# sum(grepl("^MT-", rownames(so_oro))) #0
length(which(rownames(so_oro) %in% ribo_genes)) #0
ncol(so_oro) #130,124 cells
nrow(so_oro) #11237 genes

so_liver_sn <- NormalizeData(so_liver_sn)
so_liver_sn <- ScaleData(so_liver_sn, features = VariableFeatures(so_liver_sn))

#Create general hepatocyte cell type variable
so_liver_sn$celltype2 <- ifelse(grepl("Hep-",so_liver_sn$celltype) | grepl("dHep",so_liver_sn$celltype) | grepl("Hep/Immune",so_liver_sn$celltype),"Hep","Non-Hep")
# so_liver_sn$celltype2 <- ifelse(grepl("Hep-",so_liver_sn$celltype),"Hep","Non-Hep")

# table(so_liver_sn$celltype,so_liver_sn$celltype2)

# rm(expression_data)
DefaultAssay(so_liver_sn) <- "RNA" 

#Oro
# rm(gene_expression_matrix)
so_oro <- NormalizeData(so_oro)
so_oro <- ScaleData(so_oro, features = VariableFeatures(so_oro))

#Create general hepatocyte cell type variable
so_oro$celltype2 <- ifelse(grepl("Hep-",so_oro$celltype) | grepl("dHep",so_oro$celltype) | grepl("Hep/Immune",so_oro$celltype),"Hep","Non-Hep")
# so_oro$celltype2 <- ifelse(grepl("Hep-",so_oro$celltype),"Hep","Non-Hep")

# table(so_oro$celltype,so_oro$celltype2)

# rm(expression_data)
DefaultAssay(so_oro) <- "RNA" 


# Calculate cell library size for offset in NEBULA --------------------------------------
counts_layer <- round(GetAssayData(so_liver_sn, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
so_liver_sn$library_size <- library_size
# View(so_liver_sn@meta.data)
#Oro
counts_layer <- round(GetAssayData(so_oro, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
so_oro$library_size <- library_size
# View(so_oro@meta.data)

# # TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- log(dge$samples$lib.size) + log(dge$samples$norm.factors)
# so_liver_sn$tmm_offset <- tmm_offset

# Pooled offset
# Check available cores
# library(parallel)
cores <- detectCores() -1 
bp <- MulticoreParam(workers = cores)
# bp <- SnowParam(workers = 59,
#                 packages = c("scran", "SingleCellExperiment", "stats", "Matrix"))
# future::plan("sequential")
counts_layer <- round(GetAssayData(so_liver_sn, layer = "counts"))
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
sce <- computeSumFactors(sce, BPPARAM = bp)
pooled_offset <- sizeFactors(sce)
so_liver_sn$pooled_offset <- pooled_offset
hist(so_liver_sn$pooled_offset)

#Oro
counts_layer <- round(GetAssayData(so_oro, layer = "counts"))
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
sce <- computeSumFactors(sce, BPPARAM = bp)
pooled_offset <- sizeFactors(sce)
so_oro$pooled_offset <- pooled_offset
hist(so_oro$pooled_offset)

# #Calculate cell library size for offset
# counts_layer <- round(GetAssayData(so_liver_sn, layer = "counts")) # load counts and round
# library_size <- Matrix::colSums(counts_layer) #calculate the column sums aka the sum of all genes in each cell
# so_liver_sn$library_size <- library_size #Put into the seurat object
# #Check that it is accessible in the metadata
# meta <- so_liver_sn@meta.data #It should be in the dataframe, delete meta data check df
# rm(meta,counts_layer)
# # hist(so_liver_sn$library_size)
so_liver_sn$celltype_LR <- ifelse(grepl("Hep-",so_liver_sn$celltype) | grepl("dHep",so_liver_sn$celltype) | grepl("Hep/Immune",so_liver_sn$celltype),"Hep",
                                  ifelse(so_liver_sn$celltype=="EC-1" | so_liver_sn$celltype=="EC-2","EC",
                                         ifelse(so_liver_sn$celltype=="Stellate-1" | so_liver_sn$celltype=="Stellate-2","Stellate",
                                                ifelse(so_liver_sn$celltype=="Cholang","Cholang",
                                                       ifelse(so_liver_sn$celltype=="B/Plasma" | so_liver_sn$celltype=="cFIB/cImmune" | so_liver_sn$celltype=="Kup/MAC"|so_liver_sn$celltype=="Kup/MON" | so_liver_sn$celltype=="NKC/NKT","Immune","Unknown")))))
unique(so_liver_sn$celltype_LR)

so_oro$celltype_LR <- ifelse(grepl("Hep-",so_oro$celltype) | grepl("dHep",so_oro$celltype) | grepl("Hep/Immune",so_oro$celltype),"Hep",
                             ifelse(so_oro$celltype=="EC-1" | so_oro$celltype=="EC-2","EC",
                                    ifelse(so_oro$celltype=="Stellate-1" | so_oro$celltype=="Stellate-2","Stellate",
                                           ifelse(so_oro$celltype=="Cholang","Cholang",
                                                  ifelse(so_oro$celltype=="B/Plasma" | so_oro$celltype=="cFIB/cImmune" | so_oro$celltype=="Kup/MAC"|so_oro$celltype=="Kup/MON" | so_oro$celltype=="NKC/NKT","Immune","Unknown")))))
unique(so_oro$celltype_LR)
```

## d. Visualize
###i. All Cells
```{r}
so_liver_sn <- FindVariableFeatures(object = so_liver_sn)
so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn),assay="RNA")
ElbowPlot(so_liver_sn)

# # Find neighbors and clusters (again using integrated data)
so_liver_sn <- FindNeighbors(so_liver_sn, assay = "RNA", dims = 1:20)
so_liver_sn <- FindClusters(so_liver_sn, resolution = 0.5)

# Perform UMAP 
#Print plot
png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/UMAP_by_celltype_ratio1.png",
    width = 2500, height = 2500, res = 300)
p <- DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype",raster = T, label = TRUE, label.size = 4)+
  coord_fixed(ratio = 1)
print(p)
dev.off()

png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/UMAP_by_celltype_ratio1_2.png",
    width = 2500, height = 2500, res = 300)

p <- DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", raster = T, 
             label = TRUE, label.size = 4) +
  coord_fixed(ratio = 1) +
  scale_x_continuous(expand = c(0.01, 0.01)) +  # Minimal expansion
  scale_y_continuous(expand = c(0.01, 0.01)) +  # Minimal expansion
  theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"))

print(p)
dev.off()

#Print PCA plot
png(fs::path(dir.results, "PCA_by_celltype_ratio1.png"),
    width = 3000, height = 3000, res = 300)
p <- DimPlot(so_liver_sn, reduction = "pca", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  coord_fixed(ratio = 1)+
  ggtitle("PCA Plot by Cell Type")
print(p)
dev.off()


#Print plot
png(fs::path(dir.results, "UMAP_by_Steatosis.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_liver_sn,
  reduction = "umap",
  group.by = "steatosis_cat",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("darkblue","lightgray")) +
  ggtitle("UMAP by Steatosis Status")
print(p)
dev.off()

#Barcharts of proportions
cellcount <- so_liver_sn@meta.data
celltype_order <- c("Hep-1", "Hep-2", "Hep-3", "Hep-4", "Hep-5", "dHep","Hep/Immune", "Stellate-1","Stellate-2", "EC-1","EC-2", "Cholang", "NKC/NKT", "Kup/MON", "Kup/MAC","B/Plasma","cFIB/cImmune")  
cellcount$celltype <- factor(cellcount$celltype, levels = celltype_order)

prop_plot <- ggplot(data=cellcount,aes(StudyID, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  scale_fill_manual(values=c(
    "#001219",  # Dark blue-black
    "#003446",  # Deep teal (new)
    "#005F73",  # Dark teal
    "#087984",  # Medium teal (new)
    "#0A9396",  # Teal
    "#4FB3A9",  # Light teal (new)
    "#94D2BD",  # Mint
    "#C1E5DD",  # Pale mint (new)
    "#E9D8A6",  # Cream
    "#EBB753",  # Golden yellow (new)
    "#EE9B00",  # Yellow-orange
    "#CA6702",  # Orange
    "#C25103",  # Burnt orange (new)
    "#BB3E03",  # Dark orange-red
    "#B52F0B",  # Red-orange (new)
    "#AE2012",  # Red
    "#9B2226"   # Dark red
  ))
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
# png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
# print(prop_plot)
# dev.off()
png("/home/hhampson/Results/Barchart_All_Participants_All_Cells.png",width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20))+
  scale_fill_manual(values=c(
    "#001219",  # Dark blue-black
    "#003446",  # Deep teal (new)
    "#005F73",  # Dark teal
    "#087984",  # Medium teal (new)
    "#0A9396",  # Teal
    "#4FB3A9",  # Light teal (new)
    "#94D2BD",  # Mint
    "#C1E5DD",  # Pale mint (new)
    "#E9D8A6",  # Cream
    "#EBB753",  # Golden yellow (new)
    "#EE9B00",  # Yellow-orange
    "#CA6702",  # Orange
    "#C25103",  # Burnt orange (new)
    "#BB3E03",  # Dark orange-red
    "#B52F0B",  # Red-orange (new)
    "#AE2012",  # Red
    "#9B2226"   # Dark red
  ))
# png(fs::path(dir.results, "Barchart_Steatosis_Cat_All_Cells.png"),width = 3000, height = 3000, res = 300)
# print(prop_plot)
# dev.off()
png("/home/hhampson/Results/Barchart_Steatosis_Cat_All_Cells.png",width = 3000, height = 3000, res = 300)
print(prop_plot)
dev.off()


celltype_order_LR <- c("Hep","Immune","EC","Stellate","Cholang")  
cellcount$celltype_LR <- factor(cellcount$celltype_LR, levels = celltype_order_LR)


prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype_LR)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20))+
  scale_fill_manual(values=c(
    "#003446",  # Dark blue-black
    "#0A9396",  # Teal
    "#E9D8A6",  # Mint
    "#CA6702",  # Yellow-orange
    "#AE2012"   # Red
  ))
png("/home/hhampson/Results/Barchart_Steatosis_Cat_All_Cells_LR.png",width = 2500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(steatosis_grade, fill = celltype_LR)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20))+
  scale_fill_manual(values=c(
    "#003446",  # Dark blue-black
    "#0A9396",  # Teal
    "#E9D8A6",  # Mint
    "#CA6702",  # Yellow-orange
    "#AE2012"   # Red
  ))
png("/home/hhampson/Results/Barchart_Steatosis_Grade_All_Cells_LR.png",width = 2500, height = 3000, res = 300)
print(prop_plot)
dev.off()

cellcount$fibrosis_stage <- factor(cellcount$fibrosis_stage)
cellcount$fibrosis_stage <- ifelse(cellcount$fibrosis_stage==0,"F0","F1")
prop_plot <- ggplot(data=cellcount,aes(fibrosis_stage, fill = celltype_LR)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20))+
  scale_fill_manual(values=c(
    "#003446",  # Dark blue-black
    "#0A9396",  # Teal
    "#E9D8A6",  # Mint
    "#CA6702",  # Yellow-orange
    "#AE2012"   # Red
  ))
png("/home/hhampson/Results/Barchart_Fib_Stage_All_Cells_LR.png",width = 2500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(fibrosis_cat, fill = celltype_LR)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20))+
  scale_fill_manual(values=c(
    "#003446",  # Dark blue-black
    "#0A9396",  # Teal
    "#E9D8A6",  # Mint
    "#CA6702",  # Yellow-orange
    "#AE2012"   # Red
  ))
png("/home/hhampson/Results/Barchart_Fib_Cat_All_Cells_LR.png",width = 3000, height = 3000, res = 300)
print(prop_plot)
dev.off()

#Test all celltype differences
cellcount <- so_liver_sn@meta.data
propeller(clusters = cellcount$celltype, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_cat)

propeller(clusters = cellcount$celltype_LR, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_cat)

propeller(clusters = cellcount$celltype_LR, sample = cellcount$Kit_Lot, 
          group = cellcount$fibrosis_stage)

propeller(clusters = cellcount$celltype_LR, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_grade)

propeller(clusters = cellcount$celltype_LR, sample = cellcount$Kit_Lot, 
          group = cellcount$fibrosis_cat)
propeller(clusters = cellcount$celltype, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_cat)

propeller(clusters = cellcount$celltype, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_grade)

#By major celltypes (Immune/Hepatocytes at least)
cellcount <- so_liver_sn@meta.data
cellcount <- cellcount %>% 
  filter(celltype_LR=="Immune")
cellcount$celltype2 <- factor(cellcount$celltype)

prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
  labs(x = NULL,
       y = "Proportion of Immune Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Cat_Immune_Cells.png",width = 2000, height = 2500, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(steatosis_grade, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
  labs(x = NULL,
       y = "Proportion of Immune Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Grade_Immune_Cells.png",width = 3000, height = 3000, res = 300)
print(prop_plot)
dev.off()


#Test differences in proportions using propeller
# Run propeller testing for cell type proportion differences between the two 
# groups
propeller(clusters = cellcount$celltype2, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_cat)
plotCellTypeProps(clusters = cellcount$celltype2, 
                  sample = cellcount$steatosis_cat)
tab <- propeller(clusters = cellcount$celltype2, sample = cellcount$Kit_Lot, 
                 group = cellcount$steatosis_cat)

# Run propeller and save results to a variable
propeller_results <- propeller(clusters = cellcount$celltype2, 
                               sample = cellcount$Kit_Lot, 
                               group = cellcount$steatosis_cat)

# Save to CSV
write.csv(propeller_results, "propeller_results.csv", row.names = FALSE)

#Hepatocytes
#By major celltypes (Immune/Hepatocytes at least)
cellcount <- so_liver_sn@meta.data
cellcount <- cellcount %>% 
  filter(celltype_LR=="Hep")
cellcount$celltype2 <- factor(cellcount$celltype)

prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","#a01a50","darkred"))+
  labs(x = NULL,
       y = "Proportion of Hepatocytes",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Cat_Hepatocytes_Cells.png",width = 2000, height = 2500, res = 300)
print(prop_plot)
dev.off()

# prop_plot <- ggplot(data=cellcount,aes(steatosis_grade, fill = celltype2)) + 
#   geom_bar(stat = "count", position = "fill") +
#   theme_classic() +
#   scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","#a01a50","darkred"))+
#   labs(x = NULL,
#        y = "Proportion of Hepatocytes",
#        fill = "Cell Type") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
#   theme(plot.title = element_text(hjust=0.5, face="bold"),
#         text = element_text(size = 20)) 
# png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Grade_Immune_Cells.png",width = 3000, height = 3000, res = 300)
# print(prop_plot)
# dev.off()


#Test differences in proportions using propeller
# Run propeller testing for cell type proportion differences between the two 
# groups
propeller(clusters = cellcount$celltype2, sample = cellcount$Kit_Lot, 
          group = cellcount$steatosis_cat)
plotCellTypeProps(clusters = cellcount$celltype2, 
                  sample = cellcount$steatosis_cat)

# Run propeller and save results to a variable
propeller_results <- propeller(clusters = cellcount$celltype2, 
                               sample = cellcount$Kit_Lot, 
                               group = cellcount$steatosis_cat)

# Save to CSV
write.csv(propeller_results, "propeller_results.csv", row.names = FALSE)



# Combined plot for Immune and Hepatocytes
cellcount <- so_liver_sn@meta.data
cellcount <- cellcount %>% 
  filter(celltype_LR %in% c("Immune", "Hep"))  # Filter for both

# cellcount$celltype2 <- factor(cellcount$celltype)
cellcount$celltype2 <- factor(cellcount$celltype, 
                              levels = c("Hep-1", "Hep-2", "Hep-3", "Hep-4", "Hep-5", 
                                         "dHep", "Hep/Immune",  # Hep/Immune with other Hep types
                                         "NKC/NKT", "Kup/MON", "Kup/MAC", 
                                         "B/Plasma", "cFIB/cImmune"))

# Create faceted plot
prop_plot <- ggplot(data=cellcount, aes(steatosis_cat, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  facet_wrap(~ celltype_LR, scales = "free", ncol = 2) +  # Add facet_wrap
  theme_classic() +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", 
                               "#e76f51", "#a01a50", "darkred", "#6b8e23",
                               "#4682b4", "#daa520", "#8b4513", "#708090")) + # Extended palette
  labs(x = NULL,
       y = "Proportion of Cells",  # Generic label for both types
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20),
        strip.text = element_text(size = 18, face = "bold"))  # Facet labels



# Combined plot for Immune and Hepatocytes with flipped axes
cellcount <- so_liver_sn@meta.data
cellcount <- cellcount %>% 
  filter(celltype_LR %in% c("Immune", "Hep"))

cellcount$celltype2 <- factor(cellcount$celltype)

# Define a cohesive color palette - using a gradient approach
colors_palette <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", 
                    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
                    "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5")

# Create faceted plot with flipped coordinates
prop_plot <- ggplot(data=cellcount, aes(steatosis_cat, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  coord_flip() +  # Flip the coordinates
  facet_wrap(~ celltype_LR, scales = "free_y", nrow = 2) +  # Changed to nrow since we flipped
  theme_classic() +
  scale_fill_manual(values = colors_palette) +
  labs(y = NULL,  # Now y is the x-axis after flipping
       x = "Proportion of Cells",  # Now x is the y-axis after flipping
       fill = "Cell Type") +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20),
        strip.text = element_text(size = 18, face = "bold"))

# Save the combined plot
png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Cat_Immune_Hepatocytes_Faceted_Flipped.png",
    width = 3000, height = 3500, res = 300)
print(prop_plot)
dev.off()

# Same for steatosis_grade
prop_plot_grade <- ggplot(data=cellcount, aes(steatosis_grade, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  coord_flip() +  # Flip the coordinates
  facet_wrap(~ celltype_LR, scales = "free_y", nrow = 2) +
  theme_classic() +
  scale_fill_manual(values = colors_palette) +
  labs(y = NULL,
       x = "Proportion of Cells",
       fill = "Cell Type") +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20),
        strip.text = element_text(size = 18, face = "bold"))

png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Grade_Immune_Hepatocytes_Faceted_Flipped.png",
    width = 3000, height = 4000, res = 300)
print(prop_plot_grade)
dev.off()

# Your color palette - extended with similar tones if needed
base_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "#a01a50", "darkred")

# If you need more colors, extend with similar tones
extended_colors <- c(base_colors,
                     "#bd5743",# darker coral
                     "#1a3a42",  # darker teal
                     "#237a6f",  # darker green
                     "#d4a855",  # darker gold
                     "#e09051")  # darker orange


# Create faceted plot with flipped coordinates
prop_plot <- ggplot(data=cellcount, aes(steatosis_cat, fill = celltype2)) + 
  geom_bar(stat = "count", position = "fill") +
  coord_flip() +  # Flip the coordinates
  facet_wrap(~ celltype_LR, scales = "free_y", nrow = 2) +  
  theme_classic() +
  scale_fill_manual(values = extended_colors) +
  labs(y = NULL,  
       x = "Proportion of Cells",  
       fill = "Cell Type") +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20),
        strip.text = element_text(size = 18, face = "bold"))

png("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/Tables and Figures/Barchart_Steatosis_Cat_Immune_Hepatocytes_Faceted.png",
    width = 3000, height = 2000, res = 300)
print(prop_plot)
dev.off()

# Calculate cell type proportions
celltype_props <- table(so_liver_sn@meta.data$celltype)
celltype_percentages <- prop.table(celltype_props) * 100

# Display as data frame
prop_df <- data.frame(
  CellType = names(celltype_percentages),
  Count = as.numeric(celltype_props),
  Percentage = as.numeric(celltype_percentages)
)

write.csv(prop_df,fs::path(dir.results,"Proportion_of_HR_Celltypes.csv"))

celltype_props <- table(so_liver_sn@meta.data$celltype_LR)
celltype_percentages <- prop.table(celltype_props) * 100

# Display as data frame
prop_df <- data.frame(
  CellType = names(celltype_percentages),
  Count = as.numeric(celltype_props),
  Percentage = as.numeric(celltype_percentages)
)

write.csv(prop_df,fs::path(dir.results,"Proportion_of_LR_Celltypes.csv"))

```
### ii. Hepatocytes Only
```{r}
#Filter to hepatocytes only
so_celltype <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA"

so_celltype <- FindVariableFeatures(object = so_celltype)
so_celltype <- RunPCA(so_celltype, features = VariableFeatures(object = so_celltype),assay="RNA")
ElbowPlot(so_celltype)

# # Find neighbors and clusters (again using integrated data)
so_celltype <- FindNeighbors(so_celltype, assay = "RNA", dims = 1:20)
so_celltype <- FindClusters(so_celltype, resolution = 0.5)

# Perform UMAP 
#Print plot
png(fs::path(dir.results, "UMAP_Hepatocytes.png"),
    width = 4500, height = 4500, res = 300)
p <- DimPlot(so_celltype, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  coord_fixed(ratio=1)+
  ggtitle("UMAP Plot of Hepatocytes")
print(p)
dev.off()

#PCA Plot
png(fs::path(dir.results, "PCA_Hepatocytes.png"),
    width = 3000, height = 3000, res = 300)
p <- DimPlot(so_celltype, reduction = "pca", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  coord_fixed(ratio=1)+
  ggtitle("PCA Plot of Hepatocytes")
print(p)
dev.off()

#Print plot
png(fs::path(dir.results, "UMAP_by_Steatosis.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_celltype,
  reduction = "umap",
  group.by = "steatosis_cat",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("darkblue","lightgray")) +
  ggtitle("UMAP by Steatosis Status")
print(p)
dev.off()

#Barcharts of proportions
cellcount <- so_celltype@meta.data
prop_plot <- ggplot(data=cellcount,aes(StudyID, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png(fs::path(dir.results, "Barchart_Steatosis_Cat_All_Cells.png"),width = 3000, height = 3000, res = 300)
print(prop_plot)
dev.off()


prop_plot <- ggplot(data=cellcount,aes(steatosis_grade, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_Steatosis_Grade_All_Cells.png"),width = 3500, height = 3000, res = 300)
print(prop_plot)
dev.off()


```

###iii. Hepatocyte Zone Types
```{r}
# Define zonation markers
zone1_markers <- c("ARG1", "CPS1", "MFSD2A", "ACSS2", "SLBP")
zone3_markers <- c("CYP2E1", "BCHE", "GHR", "RCAN1","CYP1A","CYP3A","CYP2C","GS","AXIN2","TXB3")

# Subset to hepatocyte subtypes only
hep_subtypes <- c("Hep_1", "Hep_2", "Hep_3", "Hep_4", "Hep_5", "dHep", "Hep_Immune")
so_hep <- subset(so_liver_sn, subset = celltype_LR=="Hep")
DefaultAssay(so_hep) <- "RNA"

# 1. Calculate average expression per subtype
avg_exp <- AverageExpression(so_hep, 
                             features = c(zone1_markers, zone3_markers),
                             group.by = "celltype",
                             assays = "RNA")$RNA


# Scale the average expression for better comparison
avg_exp_scaled <- t(scale(t(avg_exp)))

# 2. Calculate zonation scores for each subtype
zone1_score <- colMeans(avg_exp_scaled[zone1_markers[zone1_markers %in% rownames(avg_exp_scaled)], , drop = FALSE])
zone3_score <- colMeans(avg_exp_scaled[zone3_markers[zone3_markers %in% rownames(avg_exp_scaled)], , drop = FALSE])

zonation_scores <- data.frame(
  cell_type = names(zone1_score),
  Zone1_score = zone1_score,
  Zone3_score = zone3_score,
  Zonation_ratio = zone1_score - zone3_score  # Positive = Zone1, Negative = Zone3
)

print("Zonation Scores (ratio > 0 suggests Zone 1, < 0 suggests Zone 3):")
print(zonation_scores[order(zonation_scores$Zonation_ratio, decreasing = TRUE), ])

# 3. Create dot plot showing marker expression
p1 <- DotPlot(so_hep, 
              features = c(zone1_markers, zone3_markers),
              group.by = "celltype",
              cols = c("gray", "#990000")) +
  coord_flip() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Zonation Marker Expression Across Hepatocyte Subtypes") +
  geom_hline(yintercept = length(zone1_markers) + 0.5, linetype = "dashed", color = "#003366", linewidth = 1)

# 4. Create heatmap of scaled average expression
library(pheatmap)
pheatmap(avg_exp_scaled,
         cluster_rows = FALSE,
         cluster_cols = TRUE,
         annotation_row = data.frame(
           Zone = c(rep("Zone 1", length(zone1_markers)), 
                    rep("Zone 3", length(zone3_markers))),
           row.names = c(zone1_markers, zone3_markers)
         ),
         main = "Scaled Average Expression of Zonation Markers",
         color = colorRampPalette(c("#003366", "white", "#990000"))(100))

png("/home/hhampson/Results/Zonation_Heatmap2.png",res=300,height=2000,width=3000)
pheatmap(avg_exp_scaled,
         cluster_rows = FALSE,
         cluster_cols = TRUE,
         annotation_row = data.frame(
           Zone = c(rep("Zone 1", length(zone1_markers)), 
                    rep("Zone 3", length(zone3_markers))),
           row.names = c(zone1_markers, zone3_markers)
         ),
         main = "Scaled Average Expression of Zonation Markers",
         color = colorRampPalette(c("#003366", "white", "#990000"))(100))
dev.off()

# 5. Visualize zonation scores
zonation_plot <- ggplot(zonation_scores, 
                        aes(x = reorder(cell_type, Zonation_ratio), 
                            y = Zonation_ratio)) +
  geom_bar(stat = "identity", 
           aes(fill = Zonation_ratio > 0)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("TRUE" = "#990000", "FALSE" = "#003366"),
                    labels = c("TRUE" = "Zone 1-like", "FALSE" = "Zone 3-like"),
                    name = "Zonation") +
  coord_flip() +
  labs(x = "Hepatocyte Subtype", 
       y = "Zonation Score (Zone 1 - Zone 3)",
       title = "Hepatocyte Subtype Zonation Classification") +
  theme_classic() +
  theme(legend.position = "bottom")

print(p1)
print(zonation_plot)

png("/home/hhampson/Results/Zonation_Bubbleplot2.png",res=300,height=2000,width=3000)
print(p1)
dev.off()

png("/home/hhampson/Results/Zonation_Barchart2.png",res=300,height=2000,width=3000)
print(zonation_plot)
dev.off()
```


## e. Explore Distribution & Zero-Inflation
###i. All Celltypes
```{r}
#Check if data have been normalized 
so_liver_sn@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_liver_sn, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_liver_sn, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
# pdf(fs::path(dir.results,"Normalization_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# 
# # Randomly select 100 genes from the Seurat object
# # genes <- sample(rownames(so_liver_sn), 100)
# genes <- tca
# genesN <- genes
# # Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
# par(mfrow = c(2, 3))
# 
# # Loop over each randomly selected gene
# for (g in genes) {
#   
#   # Plot a histogram of the expression values for gene 'g'
#   # using normalized expression values from the "data" slot
#   hist(GetAssayData(so_liver_sn, layer = "counts")[g, ],
#        main = g,                # Title of the plot = gene name
#        xlab = "Normalized Expression")     # Label for x-axis
# }
# 
# # Close the PDF device — this writes the file to disk
# dev.off()

pdf(fs::path(dir.results,"Raw_Count_gene_expression_histograms_tca.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
# genes <- sample(rownames(so_liver_sn), 100)
genes <- tca[-9]
genesR <- genes
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_liver_sn, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Try log transforming
log_data <- log1p(GetAssayData(so_liver_sn, layer = "data"))  # log(x + 1)
pdf(fs::path(dir.results,"Log_Normalized_gene_expression_histograms_counts.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
# genes <- sample(rownames(so_liver_sn), 100)
genes <- genesN
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(log_data[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

log_data <- log1p(GetAssayData(so_liver_sn, layer = "count"))  # log(x + 1)
pdf(fs::path(dir.results,"Log_Raw_Count_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
# genes <- sample(rownames(so_liver_sn), 100)
genes <- genesR
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(log_data[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_liver_sn, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_liver_sn, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=200, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 2))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)
```

### ii. Hepatocytes Only
```{r}
so_celltype <- subset(so_celltype,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA" 

#Check if data have been normalized 
so_celltype@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_celltype, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_celltype, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
pdf(fs::path(dir.results,"Hep_Normalization_gene_expression_histograms_counts.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_celltype), 100)
genesN <- genes
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_celltype, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Normalized Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

pdf(fs::path(dir.results,"Hep_Raw_Count_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_celltype), 100)
genesR <- genes
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_celltype, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

# #Try log transforming
# log_data <- log1p(GetAssayData(so_celltype, layer = "data"))  # log(x + 1)
# pdf(fs::path(dir.results,"Hep_Log_Normalized_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# 
# # Randomly select 100 genes from the Seurat object
# # genes <- sample(rownames(so_celltype), 100)
# genes <- genesN
# # Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
# par(mfrow = c(2, 3))
# 
# # Loop over each randomly selected gene
# for (g in genes) {
#   
#   # Plot a histogram of the expression values for gene 'g'
#   # using normalized expression values from the "data" slot
#   hist(log_data[g, ],
#        main = g,                # Title of the plot = gene name
#        xlab = "Log of Normalized Counts Expression")     # Label for x-axis
# }
# 
# # Close the PDF device — this writes the file to disk
# dev.off()
# 
# log_data <- log1p(GetAssayData(so_celltype, layer = "count"))  # log(x + 1)
# pdf(fs::path(dir.results,"Hep_Log_Raw_Count_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# # Randomly select 100 genes from the Seurat object
# # genes <- sample(rownames(so_celltype), 100)
# genes <- genesR
# # Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
# par(mfrow = c(2, 3))
# 
# # Loop over each randomly selected gene
# for (g in genes) {
#   
#   # Plot a histogram of the expression values for gene 'g'
#   # using normalized expression values from the "data" slot
#   hist(log_data[g, ],
#        main = g,                # Title of the plot = gene name
#        xlab = "Log of Raw Counts Expression")     # Label for x-axis
# }
# 
# # Close the PDF device — this writes the file to disk
# dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Hep_Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_celltype, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_celltype, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Hep_Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=200, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 2))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)
```

## f. Evaluate Covariates before Adjustment
```{r}
#Categorical Covariates
#Get metadata for everyone
# dat <- so_liver_sn@meta.data %>%
#   group_by(StudyID) %>%
#   summarise(across(everything(), first)) %>%
#   ungroup() 
dat <- so_liver_sn@meta.data %>%
  group_by(StudyID) %>%
  summarise(across(everything(), ~ .x[1])) %>%
  ungroup()

dat$study <- case_when(grepl("IT2D",dat$StudyID) ~ "IMPROVE",
                       grepl("MANGO",dat$StudyID) ~ "MANGO",
                       grepl("BSA",dat$StudyID) ~ "BIOBANK")
dat <- dat %>% 
  mutate(both=ifelse(glp1agonist=="Yes" & sglt2=="Yes","Yes","No")) %>% 
  mutate(sglt2_exclusive=ifelse(sglt2=="Yes" & glp1agonist=="No","Yes","No")) %>% 
  mutate(glp1_exclusive=ifelse(sglt2=="No" & glp1agonist=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(sglt2=="No" & glp1agonist=="No","Yes","No")) 

dat <- dat %>% 
  mutate(group2=case_when(both == "Yes" ~ "glp1_and_sglt2",
                          sglt2_exclusive == "Yes" ~ "sglt2_exclusive",
                          glp1_exclusive == "Yes" ~ "glp1_exclusive",
                          either == "Yes" ~ "glp1_or_sglt2",
                          neither == "Yes" ~ "no_med",
                          hc == "Yes" ~ "obese_control"))

# table(dat2$sglt2_exclusive) #-/+ #5 No, 0 yes
# table(dat2$glp1_exclusive) #+/- # 2 Yes, 3 No
# table(dat2$both) #+/+ #1 Both, 4 not both
# table(dat2$neither) #-/- #3 neither, 2 on someting
# dat$steatosis_cat <- factor(dat$steatosis_cat,levels=c("0+1","2+3"),labels=c("Low Steatosis (0+1)","High Steatosis (2+3)"))
dat$fibrosis_cat <- factor(dat$fibrosis_cat)
dat$diagnosis_of_MASLD <- factor(dat$diagnosis_of_MASLD, levels=c("Yes","No"), labels=c("MASLD", "No MASLD"))
dat$diagnosis_of_diabetes <- factor(dat$diagnosis_of_diabetes, levels=c("Yes","No"), labels=c("Type 2 Diabetes", "Obese Controls"))
dat$nih_sex     <- factor(dat$nih_sex, levels=c("Male", "Female"), labels=c("Male", "Female"))
dat$nih_ethnicity   <- factor(dat$nih_ethnicity, levels=c("Hispanic_Or_Latino","NonHispanic"), labels=c("Hispanic or Latino","Non-Hispanic/Non-Latino"))
dat$nih_race   <- factor(dat$nih_race, levels=c("White","BlackAfAm","Multiracial","Other"),
                         labels=c("White","Black","Multirace","Other"))
dat$steatosis_grade <- as.factor(dat$steatosis_grade)
dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)

label(dat$age_surgery)      <- "Age (y)"
label(dat$sglt2_exclusive) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$glp1agonist) <- "GLP-1 Receptor Agonists (Yes/No)"
label(dat$sglt2) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$nih_sex)      <- "Sex"
label(dat$nih_race)    <- "Race"
label(dat$nih_ethnicity)    <- "Ethnicity"
label(dat$diagnosis_of_diabetes)  <- "Diabetes Status (Yes/No)"
label(dat$diagnosis_of_MASLD) <- "MASLD (Yes/No)"
label(dat$bmi)   <- "Body Mass Index (kg/m2)"
label(dat$diagnosis_of_MASLD)  <- "MASLD Status"
label(dat$a1c) <- "HbA1c (%)"
#label(dat$sbp)     <- "Systolic Blood Pressure (mmHg)"
#label(dat$dbp) <- "Diastolic Blood Pressure (mmHg)"
label(dat$tg) <-  "Triglycerides (mg/dL)"
label(dat$creatinine) <-  "Creatinine (mg/dL)"
label(dat$steatosis_grade) <- "Steatosis Grade"
label(dat$fibrosis_stage) <- "Fibrosis Stage"
label(dat$lobular_inflammation_percent) <- "Lobular Inflammation Percent (%)"
label(dat$sglt2_exclusive) <- "Exclusive SGLT2 Inhibitors (Yes/No)"
label(dat$glp1_exclusive) <- "Exclusive GLP-1 Receptor Agonists (Yes/No)"
#label(dat$group2) <- "Disease Group"
label(dat$both) <- "SLGT2i + GLP-1ra (Yes/No)"
label(dat$neither) <- "No SGLT2i or GLP-1ra (Yes/No)"
label(dat$metformin) <- "Metformin (Yes/No)"
label(dat$insulin) <- "Insulin (Yes/No)"
label(dat$alt) <- "ALT (U/L)"
label(dat$ast) <- "AST (U/L)"
label(dat$ggt) <- "GGT (U/L)"
label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"

label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"

#Table 1. 
table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg + a1c+
         diagnosis_of_diabetes + diagnosis_of_MASLD+
         sglt2 + glp1agonist  | study, data=dat)

table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg +a1c+
         diagnosis_of_MASLD+
         sglt2 + glp1agonist +metformin + insulin | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_MASLD + diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_cat + fibrosis_cat +steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_MASLD, data=dat)

table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither| steatosis_cat, data=dat)
table1(~ alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat| steatosis_cat, data=dat)
table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither + alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat| steatosis_cat, data=dat)

#Examine covariates
# age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg + a1c+
#   diagnosis_of_diabetes + diagnosis_of_MASLD+
#   sglt2 + glp1agonist

cat_covariates <- c("nih_sex", "nih_race","nih_ethnicity", "diagnosis_of_diabetes", "diagnosis_of_MASLD", "group2","fibrosis_stage")
plot_list <- list()

for (covariate in cat_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_cat", fill = covariate)) +
    geom_bar(position = "fill") +  # use "dodge" for absolute counts
    labs(y = "Proportion", x = NULL) +
    # title = paste0("Distribution of ", covariate, " by Steatosis Category")
    scale_y_continuous(labels = scales::percent_format()) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 4)


#Continuous Covariates
con_covariates <- c("age_surgery", "bmi", "tg", "a1c")
plot_list <- list()

for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_cat", y = covariate, fill = "steatosis_cat")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
    labs(title = paste0("Distribution of ", covariate, " by group"),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust ncol/nrow as needed)
wrap_plots(plot_list, ncol = 4 )



# Continuous Covariates
con_covariates <- oro_vars
plot_list <- list()
test_results <- list()

for (covariate in con_covariates) {
  # Remove NA values for this covariate
  dat_clean <- dat[!is.na(dat[[covariate]]) & !is.na(dat$steatosis_cat), ]
  
  # Check number of groups
  n_groups <- length(unique(dat_clean$steatosis_cat))
  
  # Perform appropriate test
  if (n_groups == 2) {
    # Two groups: use t-test (parametric) or Wilcoxon test (non-parametric)
    # Parametric test
    t_test <- t.test(as.formula(paste(covariate, "~ steatosis_cat")), data = dat_clean)
    p_value <- t_test$p.value
    test_type <- "t-test"
    
    # Alternative: Non-parametric test
    # wilcox_test <- wilcox.test(as.formula(paste(covariate, "~ steatosis_cat")), data = dat_clean)
    # p_value <- wilcox_test$p.value
    # test_type <- "Wilcoxon"
    
  } else if (n_groups > 2) {
    # More than two groups: use ANOVA (parametric) or Kruskal-Wallis (non-parametric)
    # Parametric test
    anova_test <- aov(as.formula(paste(covariate, "~ steatosis_cat")), data = dat_clean)
    p_value <- summary(anova_test)[[1]][["Pr(>F)"]][1]
    test_type <- "ANOVA"
    
    # Alternative: Non-parametric test
    # kw_test <- kruskal.test(as.formula(paste(covariate, "~ steatosis_cat")), data = dat_clean)
    # p_value <- kw_test$p.value
    # test_type <- "Kruskal-Wallis"
  }
  
  # Store test results
  test_results[[covariate]] <- list(
    variable = covariate,
    test = test_type,
    p_value = p_value,
    p_value_formatted = format.pval(p_value, digits = 3),
    significant = p_value < 0.05
  )
  
  # Create plot with p-value annotation
  p <- ggplot(dat_clean, aes_string(x = "steatosis_cat", y = covariate, fill = "steatosis_cat")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    labs(title = paste0("Distribution of ", covariate, " by group"),
         subtitle = paste0(test_type, ": p = ", format.pval(p_value, digits = 3)),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Create summary table of test results
test_summary <- do.call(rbind, lapply(test_results, as.data.frame))
print(test_summary)

# Save plots
combined_plot <- wrap_plots(plot_list, ncol = 4)
ggsave("continuous_covariates_boxplots_with_pvalues.png", 
       plot = combined_plot,
       width = 16,
       height = 12,
       dpi = 300)

# Save test results to CSV
write.csv(test_summary, "steatosis_comparison_tests.csv", row.names = FALSE)


```

##g. Descriptive Stats Tables
###i. All Celltypes
```{r}
dat <- so_liver_sn@meta.data %>%
  group_by(StudyID) %>%
  summarise(across(everything(), ~ .x[1])) %>%
  ungroup()

dat$study <- case_when(grepl("IT2D",dat$StudyID) ~ "IMPROVE",
                       grepl("MANGO",dat$StudyID) ~ "MANGO",
                       grepl("BSA",dat$StudyID) ~ "BIOBANK")
dat <- dat %>% 
  mutate(both=ifelse(glp1agonist=="Yes" & sglt2=="Yes","Yes","No")) %>% 
  mutate(sglt2_exclusive=ifelse(sglt2=="Yes" & glp1agonist=="No","Yes","No")) %>% 
  mutate(glp1_exclusive=ifelse(sglt2=="No" & glp1agonist=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(sglt2=="No" & glp1agonist=="No","Yes","No")) 

# dat <- dat %>% 
#   mutate(group2=case_when(both == "Yes" ~ "glp1_and_sglt2",
#                           sglt2_exclusive == "Yes" ~ "sglt2_exclusive",
#                           glp1_exclusive == "Yes" ~ "glp1_exclusive",
#                           either == "Yes" ~ "glp1_or_sglt2",
#                           neither == "Yes" ~ "no_med",
#                           hc == "Yes" ~ "obese_control"))

# table(dat2$sglt2_exclusive) #-/+ #5 No, 0 yes
# table(dat2$glp1_exclusive) #+/- # 2 Yes, 3 No
# table(dat2$both) #+/+ #1 Both, 4 not both
# table(dat2$neither) #-/- #3 neither, 2 on someting
# dat$steatosis_cat <- factor(dat$steatosis_cat,levels=c("0+1","2+3"),labels=c("Low Steatosis (0+1)","High Steatosis (2+3)"))
dat$fibrosis_cat <- factor(dat$fibrosis_cat)
dat$diagnosis_of_MASLD <- factor(dat$diagnosis_of_MASLD, levels=c("Yes","No"), labels=c("MASLD", "No MASLD"))
dat$diagnosis_of_diabetes <- factor(dat$diagnosis_of_diabetes, levels=c("Yes","No"), labels=c("Type 2 Diabetes", "Obese Controls"))
dat$nih_sex     <- factor(dat$nih_sex, levels=c("Male", "Female"), labels=c("Male", "Female"))
dat$nih_ethnicity   <- factor(dat$nih_ethnicity, levels=c("Hispanic_Or_Latino","NonHispanic"), labels=c("Hispanic or Latino","Non-Hispanic/Non-Latino"))
dat$nih_race   <- factor(dat$nih_race, levels=c("White","BlackAfAm","Multiracial","Other"),
                         labels=c("White","Black","Multirace","Other"))
dat$steatosis_grade <- as.factor(dat$steatosis_grade)
dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)

label(dat$age_surgery)      <- "Age (y)"
label(dat$sglt2_exclusive) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$glp1agonist) <- "GLP-1 Receptor Agonists (Yes/No)"
label(dat$sglt2) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$nih_sex)      <- "Sex"
label(dat$nih_race)    <- "Race"
label(dat$nih_ethnicity)    <- "Ethnicity"
label(dat$diagnosis_of_diabetes)  <- "Diabetes Status (Yes/No)"
label(dat$diagnosis_of_MASLD) <- "MASLD (Yes/No)"
label(dat$bmi)   <- "Body Mass Index (kg/m2)"
label(dat$diagnosis_of_MASLD)  <- "MASLD Status"
label(dat$a1c) <- "HbA1c (%)"
#label(dat$sbp)     <- "Systolic Blood Pressure (mmHg)"
#label(dat$dbp) <- "Diastolic Blood Pressure (mmHg)"
label(dat$tg) <-  "Triglycerides (mg/dL)"
label(dat$creatinine) <-  "Creatinine (mg/dL)"
label(dat$steatosis_grade) <- "Steatosis Grade"
label(dat$fibrosis_stage) <- "Fibrosis Stage"
label(dat$lobular_inflammation_percent) <- "Lobular Inflammation Percent (%)"
label(dat$sglt2_exclusive) <- "Exclusive SGLT2 Inhibitors (Yes/No)"
label(dat$glp1_exclusive) <- "Exclusive GLP-1 Receptor Agonists (Yes/No)"
#label(dat$group2) <- "Disease Group"
label(dat$both) <- "SLGT2i + GLP-1ra (Yes/No)"
label(dat$neither) <- "No SGLT2i or GLP-1ra (Yes/No)"
label(dat$metformin) <- "Metformin (Yes/No)"
label(dat$insulin) <- "Insulin (Yes/No)"
label(dat$alt) <- "ALT (U/L)"
label(dat$ast) <- "AST (U/L)"
label(dat$ggt) <- "GGT (U/L)"
label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"

label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"
label(dat$hepatocyte_ballooning_score) <- "Hepatocyte Ballooning Score"

# c("alt","ast","ggt","bmi","a1c","hepatocyte_ballooning_score","lobular_inflammation_grade","steatosis_grade","fibrosis_stage")

#Table 1. 
table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg + a1c+
         diagnosis_of_diabetes + diagnosis_of_MASLD+
         sglt2 + glp1agonist| study, data=dat)

table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg +a1c+
         diagnosis_of_MASLD+
         sglt2 + glp1agonist +metformin + insulin | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_MASLD + diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_cat + fibrosis_cat +steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_MASLD, data=dat)

table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither| steatosis_cat, data=dat)
table1(~ alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat| steatosis_cat, data=dat)
table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither + alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat+study| steatosis_cat, data=dat)


t1 <- table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
             +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither + alt + ast + ggt + lobular_inflammation_percent + hepatocyte_ballooning_score+steatosis_grade+fibrosis_stage+fibrosis_cat| steatosis_cat, data=dat)

# Save as HTML
write(t1, file = "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/table1_liver_manuscript.html")

# Convert to data frame first
t1_df <- as.data.frame(t1)
write.csv(t1_df, "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Hailey Hampson/1_Ongoing Projects/Liver snRNA/Manuscript/table1_liver_manuscript.csv", row.names = FALSE)

table1(~ alt+ast+ggt+bmi+a1c+hepatocyte_ballooning_score+lobular_inflammation_grade+steatosis_grade+fibrosis_stage| steatosis_cat, data=dat)



dat$hepatocyte_ballooning_score <- as.numeric(dat$hepatocyte_ballooning_score)
dat$steatosis_grade <- as.numeric(dat$steatosis_grade)
summary(dat$steatosis_grade)
summary(dat$hepatocyte_ballooning_score)

# Check for correlation
cor.test(dat$steatosis_grade, dat$hepatocyte_ballooning_score, 
         method = "spearman")
cor.test(dat$steatosis_grade, dat$hepatocyte_ballooning_score, 
         method = "pearson")
dat$steatosis_grade <- dat$steatosis_grade-1
p1 <- ggplot(dat, aes(x = steatosis_grade, y = hepatocyte_ballooning_score)) +
  geom_point(alpha = 0.3, size = 0.5) +
  geom_smooth(method = "lm", color = "red",se=F) +
  theme_classic() +
  labs(title = "Steatosis vs Hepatocyte Ballooning",
       x = "Steatosis Score",
       y = "Hepatocyte Ballooning Score")

print(p1)

# which(is.na(so_celltype$carbfccp))
meta <- so_liver_sn@meta.data
oro_vars <- colnames(meta)[85:114]
# oro_variables <- paste0("~",paste(oro_vars,collapse="+"))
# table1(oro_variables|steatosis_cat, data=dat)
dat <- dat %>% 
  filter(study!="BIOBANK")
table1(~carbp_m+carb_adp+carb_g+carb_cytoc+carb_s+carb_omy+carbfccp+carbrcr_pm+carbrcr_pmgs+carbpe_pmgs+carb_ep+carbrcr_state2+carbrcr_state4_c1+carbrcr_state4_c12+carb_le| steatosis_cat, data=dat)

table1(~carbp_m+carb_adp+carb_g+carb_cytoc+carb_s+carb_omy+carbfccp+carbrcr_pm+carbrcr_pmgs+carbpe_pmgs+carb_ep+carbrcr_state2+carbrcr_state4_c1+carbrcr_state4_c12+carb_le| StudyID, data=dat)

table1(~StudyID| steatosis_cat, data=dat)
dat$StudyID

table1(~lipidpc_m+lipid_adp+lipid_cytoc+lipid_g+lipid_s+lipid_omy+lipidfccp+lipidrcr_pcm+lipidrcr_pcmgs+lipidpe_pcmgs+lipid_ep+lipidrcr_state2+lipidrcr_state4_c1+lipidrcr_state4_c12+lipid_le| steatosis_cat, data=dat)


carb_vars <- oro_vars[1:15]
# Run simple t-tests
results <- data.frame()
for(var in carb_vars) {
  formula <- as.formula(paste(var, "~ steatosis_cat"))
  test <- t.test(formula, data = dat)
  
  results <- rbind(results, 
                   data.frame(variable = var,
                              p_value = test$p.value))
}

# Reshape data to long format
#Carb variables
# carb_vars <- oro_vars[c(1,2,4:7,9,10,15)]
carb_vars <- oro_vars[c(1,2,5:7,9,10,15)]
dat_long_carb <- dat %>%
  filter(StudyID!="BSA_026") %>% 
  filter(StudyID!="BSA_034") %>% 
  # dplyr::select(c(StudyID,steatosis_cat, all_of(carb_vars)))
  dplyr::select(c(steatosis_cat, all_of(carb_vars))) %>% 
  # dat_long_carb <- dat_long_carb %>% 
  # tibble::column_to_rownames("StudyID") %>% 
  pivot_longer(cols = -steatosis_cat, 
               names_to = "variable", 
               values_to = "value") 
dat_long_carb <- dat_long_carb %>% 
  mutate(name = case_when(variable=="carbp_m" ~ "State 2 PM",
                          variable=="carb_adp" ~ "State 3 PM",
                          variable=="carb_s" ~ "State 3 PMGS",
                          variable=="carb_omy" ~ "State 4 PMGS",
                          variable=="carbfccp" ~ "ETS PMGS",
                          variable=="carbrcr_pmgs" ~ "RCR PMGS",
                          variable=="carbpe_pmgs" ~ "PE PMGS",
                          variable=="carb_le" ~ "L/E PMGS")) %>% 
  dplyr::rename(Parameter=value)
dat_long_carb$name <- factor(dat_long_carb$name, 
                             levels = c("State 2 PM", "State 3 PM", "State 3 PMGS", 
                                        "State 4 PMGS", "ETS PMGS", 
                                        "RCR PMGS", "PE PMGS", "L/E PMGS"))

# "carbp_m"    "carb_adp"   "carb_g"     "carb_cytoc" "carb_s"     "carb_omy" 
# "State 2 PM","State 3 PM", "State 3 PMG", "State 3 PMG (Cyt C)","State 3 PMGS","State 4 PMGS (Olyg.)"

# Create faceted boxplots
g <- ggplot(dat_long_carb, aes(x = steatosis_cat, y = Parameter, fill = steatosis_cat)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5) +  # Show individual points
  facet_wrap(~ name, scales = "free_y", ncol = 4) +
  scale_fill_manual(values = c("#e76f51", "#264653")) +
  # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        text = element_text(face = "bold", family = "arial"),
        strip.text = element_text(size = 12, face = "bold"),  # Facet labels
        plot.title = element_text(hjust = 0.5,size=14), 
        legend.position = "none") +
  labs(title = "Respiratory Parameters (Run 1 - Absense of Lipid) by Steatosis Category",
       x = "Steatosis Category",
       y = "Respiratory Parameters",
       fill = "Steatosis Category")

# # Display all plots together (adjust ncol/nrow as needed)
# wrap_plots(plot_list, ncol = 4 )
# # Create the combined plot object
# combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
# png(fs::path(dir.results,"Carb_Oroboros_Boxplots_Parameters.png"), 
#     width = 3000, 
#     height = 3000, 
#     res = 300)
# print(g)
# dev.off()
png(fs::path("/home/hhampson/Results/Carb_Oroboros_Boxplots_Parameters.png"), 
    width = 4000, 
    height = 2500, 
    res = 300)
print(g)
dev.off()

# #carb ratios
# carb_vars <- oro_vars[7:15]
# dat_long_carb <- dat %>%
#   dplyr::select(steatosis_cat, all_of(carb_vars)) %>%
#   pivot_longer(cols = -steatosis_cat, 
#                names_to = "variable", 
#                values_to = "value") %>% 
#   mutate(variable = factor(variable, levels = carb_vars))
# # dat_long_carb <- dat_long_carb %>% 
# #   mutate(name = case_when(variable=="carbp_m" ~ "State 2 PM",
# #                    variable=="carb_adp" ~ "State 3 PM",
# #                    variable=="carb_g" ~ "State 3 PMG",
# #                    variable=="carb_cytoc" ~ "State 3 PMG (Cyt C)",
# #                    variable=="carb_s" ~ "State 3 PMGS",
# #                    variable=="carb_omy" ~ "State 4 PMGS (Olyg.)")) %>% 
# #   dplyr::rename(Parameter=value)
# # "carbp_m"    "carb_adp"   "carb_g"     "carb_cytoc" "carb_s"     "carb_omy" 
# # "State 2 PM","State 3 PM", "State 3 PMG", "State 3 PMG (Cyt C)","State 3 PMGS","State 4 PMGS (Olyg.)"
# 
# # Create faceted boxplots
# g <- ggplot(dat_long_carb, aes(x = steatosis_cat, y = value, fill = steatosis_cat)) +
#   geom_boxplot(alpha = 0.7) +
#   geom_jitter(width = 0.2, alpha = 0.5) +  # Show individual points
#   facet_wrap(~ variable, scales = "free_y", ncol = 3) +
#   scale_fill_manual(values = c("#e76f51", "#264653")) +
#   # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
#         text = element_text(face = "bold", family = "arial"),
#         strip.text = element_text(size = 12, face = "bold"),  # Facet labels
#         plot.title = element_text(hjust = 0.5,size=14), 
#         legend.position = "none") +
#   labs(title = "Respiratory Ratios (Run 1 - Absense of Lipid) by Steatosis Category",
#        x = "Steatosis Category",
#        y = "Respiratory Ratios",
#        fill = "Steatosis Category")
# 
# # # Display all plots together (adjust ncol/nrow as needed)
# # wrap_plots(plot_list, ncol = 4 )
# # # Create the combined plot object
# # combined_plot <- wrap_plots(plot_list, ncol = 4)
# 
# # Save using png() device
# png(fs::path(dir.results,"Carb_Oroboros_Boxplots_Ratios.png"), 
#     width = 3000, 
#     height =2500, 
#     res = 300)
# print(g)
# dev.off()



# Get list of variables
lipid_vars <- c("lipidpc_m", "lipid_adp", "lipid_cytoc", "lipid_g", 
                "lipid_s", "lipid_omy", "lipidfccp", "lipidrcr_pcm", 
                "lipidrcr_pcmgs", "lipidpe_pcmgs", "lipid_ep", 
                "lipidrcr_state2", "lipidrcr_state4_c1", 
                "lipidrcr_state4_c12", "lipid_le")

# Run simple t-tests
results <- data.frame()

for(var in lipid_vars) {
  formula <- as.formula(paste(var, "~ steatosis_cat"))
  test <- t.test(formula, data = dat)
  
  results <- rbind(results, 
                   data.frame(variable = var,
                              p_value = test$p.value))
}

#Lipid variables
lipid_vars <- oro_vars[c(16,17,20:22,24,25,30)]
dat_long_lipid <- dat %>%
  filter(StudyID!="BSA_026") %>% 
  filter(StudyID!="BSA_034") %>% 
  dplyr::select(steatosis_cat, all_of(lipid_vars)) %>%
  pivot_longer(cols = -steatosis_cat, 
               names_to = "variable", 
               values_to = "value") 
dat_long_lipid <- dat_long_lipid %>% 
  mutate(name = case_when(variable=="lipidpc_m" ~ "State 2 FAM",
                          variable=="lipid_adp" ~ "State 3 FAM",
                          variable=="lipid_s" ~ "State 3 FAMGS",
                          variable=="lipid_omy" ~ "State 4 FAMGS",
                          variable=="lipidfccp" ~ "ETS FAMGS",
                          variable=="lipidrcr_pcmgs" ~ "RCR FAMGS",
                          variable=="lipidpe_pcmgs" ~ "PE FAMGS",
                          variable=="lipid_le" ~ "L/E FAMGS")) %>% 
  dplyr::rename(Parameter=value)
#"lipidpc_m"   "lipid_adp"   "lipid_cytoc" "lipid_g"     "lipid_s"     "lipid_omy" 
# Set factor levels to maintain the order of lipid_vars
dat_long_lipid$name <- factor(dat_long_lipid$name, 
                              levels = c("State 2 FAM", "State 3 FAM", 
                                         "State 3 FAMGS", "State 4 FAMGS", "ETS FAMGS", 
                                         "RCR FAMGS", "PE FAMGS", "L/E FAMGS"))

# Create faceted boxplots
g <- ggplot(dat_long_lipid, aes(x = steatosis_cat, y = Parameter, fill = steatosis_cat)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5) +  # Show individual points
  facet_wrap(~ name, scales = "free_y", ncol = 4) +
  scale_fill_manual(values = c("#e76f51", "#264653")) +
  # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        text = element_text(face = "bold", family = "arial"),
        strip.text = element_text(size = 12, face = "bold"),  # Facet labels
        plot.title = element_text(hjust = 0.5,size=14), 
        legend.position = "none") +
  labs(title = "Respiratory Parameters (Run 2 - Presence of Lipid) by Steatosis Category",
       x = "Steatosis Category",
       y = "Respiratory Parameters",
       fill = "Steatosis Category")

# # Display all plots together (adjust ncol/nrow as needed)
# wrap_plots(plot_list, ncol = 4 )
# # Create the combined plot object
# combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png("/home/hhampson/Results/Lipid_Oroboros_Boxplots_Parameters.png", 
    width = 4000, 
    height = 2500, 
    res = 300)
print(g)
dev.off()


#Lipid variables
lipid_vars <- oro_vars[22:30]
dat_long_lipid <- dat %>%
  dplyr::select(steatosis_cat, all_of(lipid_vars)) %>%
  pivot_longer(cols = -steatosis_cat, 
               names_to = "variable", 
               values_to = "value") 
dat_long_lipid <- dat_long_lipid %>%
  #   mutate(name = case_when(variable=="lipidpc_m" ~ "State 2 FAM",
  #                    variable=="lipid_adp" ~ "State 3 FAM (ADP)",
  #                    variable=="lipid_cytoc" ~ "State 3 FAM (Cytochrome C)",
  #                    variable=="lipid_g" ~ "State 3 FAM (G)",
  #                    variable=="lipid_s" ~ "State 3 FAMG (S)",
  #                    variable=="lipid_omy" ~ "State 4 FAMGS (Olygomycin)")) %>% 
  dplyr::rename(Parameter=value)
#"lipidpc_m"   "lipid_adp"   "lipid_cytoc" "lipid_g"     "lipid_s"     "lipid_omy" 

# Create faceted boxplots
g <- ggplot(dat_long_lipid, aes(x = steatosis_cat, y = Parameter, fill = steatosis_cat)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.5) +  # Show individual points
  facet_wrap(~ variable, scales = "free_y", ncol = 3) +
  scale_fill_manual(values = c("#e76f51", "#264653")) +
  # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#e76f51","darkred"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        text = element_text(face = "bold", family = "arial"),
        strip.text = element_text(size = 12, face = "bold"),  # Facet labels
        plot.title = element_text(hjust = 0.5,size=14), 
        legend.position = "none") +
  labs(title = "Respiratory Ratios (Run 2 - Presence of Lipid) by Steatosis Category",
       x = "Steatosis Category",
       y = "Respiratory Ratios",
       fill = "Steatosis Category")

# # Display all plots together (adjust ncol/nrow as needed)
# wrap_plots(plot_list, ncol = 4 )
# # Create the combined plot object
# combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png(fs::path(dir.results,"Lipid_Oroboros_Boxplots_Ratios.png"), 
    width = 3000, 
    height = 2500, 
    res = 300)
print(g)
dev.off()


# table1(~lipidpc_m+lipid_adp+lipid_cytoc+lipid_g+lipid_s+lipid_omy+lipidfccp+lipidrcr_pcm+lipidrcr_pcmgs+lipidpe_pcmgs+lipid_ep+lipidrcr_state2+lipidrcr_state4_c1+lipidrcr_state4_c12+lipid_le| StudyID, data=dat)
# Save the first table
# Convert to data frame and save as CSV
library(table1)

# For the first table
t1 <- table1(~carbp_m+carb_adp+carb_g+carb_cytoc+carb_s+carb_omy+carbfccp+carbrcr_pm+carbrcr_pmgs+carbpe_pmgs+carb_ep+carbrcr_state2+carbrcr_state4_c1+carbrcr_state4_c12+carb_le| steatosis_cat, data=dat)
write.csv(as.data.frame(t1), file = fs::path(dir.results,"carb_table.csv"), row.names = FALSE)

# For the second table
t2 <- table1(~lipidpc_m+lipid_adp+lipid_cytoc+lipid_g+lipid_s+lipid_omy+lipidfccp+lipidrcr_pcm+lipidrcr_pcmgs+lipidpe_pcmgs+lipid_ep+lipidrcr_state2+lipidrcr_state4_c1+lipidrcr_state4_c12+lipid_le| steatosis_cat, data=dat)
write.csv(as.data.frame(t2), file = fs::path(dir.results,"lipid_table.csv"), row.names = FALSE)

table(so_celltype$steatosis_cat,so_celltype$lipid_g)
unique(so_celltype$lipid_adp)
dat$lipid_adp
length(unique(so_celltype$StudyID))


#Check for separation in oroboros variables

# cat_covariates <- oro_vars
# plot_list <- list()
# 
# for (covariate in cat_covariates) {
#   p <- ggplot(dat, aes_string(x = "steatosis_cat", fill = covariate)) +
#     geom_bar(position = "fill") +  # use "dodge" for absolute counts
#     labs(y = "Proportion", x = NULL) +
#     # title = paste0("Distribution of ", covariate, " by Steatosis Category")
#     scale_y_continuous(labels = scales::percent_format()) +
#     theme_minimal() +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))
#   
#   plot_list[[covariate]] <- p
# }
# 
# # Display all plots together (adjust depending on how many you have)
# wrap_plots(plot_list, ncol = 4)


#Continuous Covariates
dat <- dat %>% 
  filter(study!="BIOBANK")
con_covariates <- oro_vars[1:15]
plot_list <- list()

for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_cat", y = covariate, fill = "steatosis_cat")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
    labs(title = paste0("Distribution of ", covariate, " by group"),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust ncol/nrow as needed)
wrap_plots(plot_list, ncol = 4 )
# Create the combined plot object
combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png(fs::path(dir.results,"Carb_Oroboros_continuous_covariates_boxplots.png"), 
    width = 16, 
    height = 12, 
    units = "in", 
    res = 300)
print(combined_plot)
dev.off()

con_covariates <- oro_vars[1:15]
plot_list <- list()

for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_grade", y = covariate, fill = "steatosis_grade")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
    labs(title = paste0("Distribution of ", covariate, " by group"),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust ncol/nrow as needed)
wrap_plots(plot_list, ncol = 4 )
# Create the combined plot object
combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png(fs::path(dir.results,"Carb_Oroboros_continuous_covariates_boxplots_steatosis_grade.png"), 
    width = 16, 
    height = 12, 
    units = "in", 
    res = 300)
print(combined_plot)
dev.off()

#Lipid
con_covariates <- oro_vars[16:30]
plot_list <- list()

for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_cat", y = covariate, fill = "steatosis_cat")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
    labs(title = paste0("Distribution of ", covariate, " by group"),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust ncol/nrow as needed)
wrap_plots(plot_list, ncol = 4 )
# Create the combined plot object
combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png(fs::path(dir.results,"Lipid_Oroboros_continuous_covariates_boxplots.png"), 
    width = 16, 
    height = 12, 
    units = "in", 
    res = 300)
print(combined_plot)
dev.off()

con_covariates <- oro_vars[16:30]
plot_list <- list()

for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "steatosis_grade", y = covariate, fill = "steatosis_grade")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
    labs(title = paste0("Distribution of ", covariate, " by group"),
         x = "Group", y = covariate) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust ncol/nrow as needed)
wrap_plots(plot_list, ncol = 4 )
# Create the combined plot object
combined_plot <- wrap_plots(plot_list, ncol = 4)

# Save using png() device
png(fs::path(dir.results,"Lipid_Oroboros_continuous_covariates_boxplots_steatosis_grade.png"), 
    width = 16, 
    height = 12, 
    units = "in", 
    res = 300)
print(combined_plot)
dev.off()
```
###ii. Hepatocytes
```{r}
so_celltype <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA"

dat <- so_celltype@meta.data %>%
  group_by(StudyID) %>%
  summarise(across(everything(), ~ .x[1])) %>%
  ungroup()

dat$study <- case_when(grepl("IT2D",dat$StudyID) ~ "IMPROVE",
                       grepl("MANGO",dat$StudyID) ~ "MANGO",
                       grepl("BSA",dat$StudyID) ~ "BIOBANK")
dat <- dat %>% 
  mutate(both=ifelse(glp1agonist=="Yes" & sglt2=="Yes","Yes","No")) %>% 
  mutate(sglt2_exclusive=ifelse(sglt2=="Yes" & glp1agonist=="No","Yes","No")) %>% 
  mutate(glp1_exclusive=ifelse(sglt2=="No" & glp1agonist=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(sglt2=="No" & glp1agonist=="No","Yes","No")) 

dat <- dat %>% 
  mutate(group2=case_when(both == "Yes" ~ "glp1_and_sglt2",
                          sglt2_exclusive == "Yes" ~ "sglt2_exclusive",
                          glp1_exclusive == "Yes" ~ "glp1_exclusive",
                          either == "Yes" ~ "glp1_or_sglt2",
                          neither == "Yes" ~ "no_med",
                          hc == "Yes" ~ "obese_control"))

# table(dat2$sglt2_exclusive) #-/+ #5 No, 0 yes
# table(dat2$glp1_exclusive) #+/- # 2 Yes, 3 No
# table(dat2$both) #+/+ #1 Both, 4 not both
# table(dat2$neither) #-/- #3 neither, 2 on someting
# dat$steatosis_cat <- factor(dat$steatosis_cat,levels=c("0+1","2+3"),labels=c("Low Steatosis (0+1)","High Steatosis (2+3)"))
dat$fibrosis_cat <- factor(dat$fibrosis_cat)
dat$diagnosis_of_MASLD <- factor(dat$diagnosis_of_MASLD, levels=c("Yes","No"), labels=c("MASLD", "No MASLD"))
dat$diagnosis_of_diabetes <- factor(dat$diagnosis_of_diabetes, levels=c("Yes","No"), labels=c("Type 2 Diabetes", "Obese Controls"))
dat$nih_sex     <- factor(dat$nih_sex, levels=c("Male", "Female"), labels=c("Male", "Female"))
dat$nih_ethnicity   <- factor(dat$nih_ethnicity, levels=c("Hispanic_Or_Latino","NonHispanic"), labels=c("Hispanic or Latino","Non-Hispanic/Non-Latino"))
dat$nih_race   <- factor(dat$nih_race, levels=c("White","BlackAfAm","Multiracial","Other"),
                         labels=c("White","Black","Multirace","Other"))
dat$steatosis_grade <- as.factor(dat$steatosis_grade)
dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)

label(dat$age_surgery)      <- "Age (y)"
label(dat$sglt2_exclusive) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$glp1agonist) <- "GLP-1 Receptor Agonists (Yes/No)"
label(dat$sglt2) <- "SGLT2 Inhibitors (Yes/No)"
label(dat$nih_sex)      <- "Sex"
label(dat$nih_race)    <- "Race"
label(dat$nih_ethnicity)    <- "Ethnicity"
label(dat$diagnosis_of_diabetes)  <- "Diabetes Status (Yes/No)"
label(dat$diagnosis_of_MASLD) <- "MASLD (Yes/No)"
label(dat$bmi)   <- "Body Mass Index (kg/m2)"
label(dat$diagnosis_of_MASLD)  <- "MASLD Status"
label(dat$a1c) <- "HbA1c (%)"
#label(dat$sbp)     <- "Systolic Blood Pressure (mmHg)"
#label(dat$dbp) <- "Diastolic Blood Pressure (mmHg)"
label(dat$tg) <-  "Triglycerides (mg/dL)"
label(dat$creatinine) <-  "Creatinine (mg/dL)"
label(dat$steatosis_grade) <- "Steatosis Grade"
label(dat$fibrosis_stage) <- "Fibrosis Stage"
label(dat$lobular_inflammation_percent) <- "Lobular Inflammation Percent (%)"
label(dat$sglt2_exclusive) <- "Exclusive SGLT2 Inhibitors (Yes/No)"
label(dat$glp1_exclusive) <- "Exclusive GLP-1 Receptor Agonists (Yes/No)"
#label(dat$group2) <- "Disease Group"
label(dat$both) <- "SLGT2i + GLP-1ra (Yes/No)"
label(dat$neither) <- "No SGLT2i or GLP-1ra (Yes/No)"
label(dat$metformin) <- "Metformin (Yes/No)"
label(dat$insulin) <- "Insulin (Yes/No)"
label(dat$alt) <- "ALT (U/L)"
label(dat$ast) <- "AST (U/L)"
label(dat$ggt) <- "GGT (U/L)"
label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"

label(dat$fibrosis_cat) <- "Fibrosis Category"
label(dat$steatosis_cat) <- "Steatosis Category"

#Table 1. 
table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg + a1c+
         diagnosis_of_diabetes + diagnosis_of_MASLD+
         sglt2 + glp1agonist  | study, data=dat)

table1(~ age_surgery + nih_sex + nih_race + nih_ethnicity + bmi + tg +a1c+
         diagnosis_of_MASLD+
         sglt2 + glp1agonist +metformin + insulin | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_MASLD + diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_diabetes, data=dat)

table1(~ a1c+ diagnosis_of_diabetes+ sglt2 + glp1agonist + metformin + insulin + alt + ast + ggt + steatosis_cat + fibrosis_cat +steatosis_grade + fibrosis_stage + lobular_inflammation_percent  
       | diagnosis_of_MASLD, data=dat)

table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither| steatosis_cat, data=dat)
table1(~ alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat| steatosis_cat, data=dat)
table1(~ age_surgery + nih_sex + nih_ethnicity + bmi + tg +a1c
       +metformin + insulin + diagnosis_of_MASLD+ diagnosis_of_diabetes+both+glp1_exclusive+sglt2_exclusive+neither + alt + ast + ggt +lobular_inflammation_percent + fibrosis_cat| steatosis_cat, data=dat)


```


# 3. Steatosis Analysis 
##A. Hepatocytes
## a. HEP Cells 
```{r}
#Filter to Hep Cells
so_celltype <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
ncol(so_celltype) #130124 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# # so_celltype_hvg <- subset(so_celltype, features = hvgs)
# subset_counts <- GetAssayData(so_celltype, layer = "counts")[hvgs, ]
# DefaultAssay(so_celltype_hvg) <- "RNA" 
# rm(so_celltype)
```

### i. NEBULA
#### Unadjusted
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)[1501:2000]
# # count_gene <- counts_hvg[g, , drop = FALSE]
# meta_gene_hvg <- .subset(so_celltype_hvg,features=g)@meta.data
# pred_gene_hvg <- model.matrix(~steatosis_cat, data = meta_gene_hvg)
# data_g_hvg = list(count = counts_hvg, id = id, pred = pred_gene_hvg)
# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
cl <- makeCluster(5)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# nebula_results_list <- nebula_results_list2
# nebula_results_list_full <- rbind(nebula_results_list2,nebula_results_list)
# nebula_results_list_full <- rbind(nebula_results_list_full,nebula_results_list)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
# full_results_full <- full_results
# full_results_full <- rbind(full_results_full,full_results)
# rm(full_results)
# full_results <- full_results_full
# rm(full_results_full)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset_with_HepImmune.csv"))
# full_results <- read.csv(fs::path(dir.results,"NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
#   dplyr::rename(`logFC_steatosis_catHigh Steatosis (2+3)`=logFC_steatosis_catHigh.Steatosis..2.3.)

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
# volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
#   geom_point(alpha = 0.7) +  # Plot points with transparency
#   scale_color_identity() +  # Use the color column directly
#   theme_minimal() +  # Minimal theme
#   labs(
#     title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
#     subtitle = "Hepatocytes, Unadjusted (REML,Log Normal,Pooled Offset)",
#     x = "FC",
#     y = "-log10(P-Value)",
#     color = "FC Direction Direction",
#     caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.x = element_text(angle = 0, hjust = 1)
#   )+
#   xlim(min,max)+
#   # # Add labels for significant points
#   geom_text(data = significant_df, aes(label = gene),
#             vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# # Add labels for significant points with ggrepel
# # geom_text_repel(data = significant_df, aes(label = Gene),
# #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# 
# volcano_plot
# 
# # pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# # print(volcano_plot)
# # dev.off()
# png(fs::path(dir.results, "Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset.png"),
#     width = 3000, height = 2100, res = 300)
# print(volcano_plot)
# dev.off()


volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.6) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # scale_color_identity(guide = "legend", 
  #                    name = "LogFC Direction", 
  #                    labels = c("Downregulated", "N.S.", "Upregulated"), 
  # breaks = c("#003366", "lightgrey", "#990000"))+
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed Genes in High Steatosis vs. Low Steatosis",
    subtitle = "Hepatocytes",
    x = "LogFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0,face="bold"),
    plot.subtitle = element_text(face="bold"),
    axis.text.x = element_text(angle = 0, hjust = 1),
    legend.text = element_text(face="bold")
  )+
  # xlim(min,max)+
  xlim(-2,1.6)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black",fontface="bold")

volcano_plot
png(fs::path(dir.results, "Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_withHepImmune.png"),
    width = 2500, height = 2000, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset_with_HepImmune.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hepatocytes <- full_results$LogFC
names(rankings_Hepatocytes) <- full_results$Gene
rankings_Hepatocytes <- sort(rankings_Hepatocytes, decreasing = TRUE)
plot(rankings_Hepatocytes)
min(rankings_Hepatocytes)
max(rankings_Hepatocytes)

set.seed(1234)

kegg_legacy_res_Hepatocytes <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_Hepatocytes,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_Hepatocytes <- fgsea(pathways = reactome,
                                  stats = rankings_Hepatocytes,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
# saveRDS(reactome_res_Hepatocytes,fs::path(dir.results,"Hepatocytes_Steatosis_Reactome.rds"))
go_res_Hepatocytes <- fgsea(pathways = go,
                            stats = rankings_Hepatocytes,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)
# saveRDS(go_res_Hepatocytes,fs::path(dir.results,"Hepatocytes_Steatosis_GO.rds"))

Hepatocytes_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hepatocytes[, padj < 0.05]), sum(kegg_legacy_res_Hepatocytes[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_Hepatocytes[, padj < 0.05]), sum(reactome_res_Hepatocytes[, pval < 0.05])),
                                "GO"=c(sum(go_res_Hepatocytes[, padj < 0.05]), sum(go_res_Hepatocytes[, pval < 0.05])))
rownames(Hepatocytes_fgsea) <- c("adj.pval", "p.val")
Hepatocytes_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_Hepatocytes, title = "Hepatocytes Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hepatocytes, title = "Hepatocytes Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hepatocytes, title = "Hepatocytes Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"Hepatocytes_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hepatocytes_top30_pathways_unadjusted_withHepImmune.jpeg"),
       width = 15, height = 20, scale = 1)
```

#### Adjusted
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)
# # count_gene <- counts_hvg[g, , drop = FALSE]
# meta_gene_hvg <- .subset(so_celltype_hvg,features=g)@meta.data
# id <- meta_gene_hvg$Kit_Lot
# pred_gene_hvg <- model.matrix(~steatosis_cat, data = meta_gene_hvg)
# data_g_hvg = list(count = counts_hvg, id = id, pred = pred_gene_hvg)
# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat+a1c, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hepatocytes_Steatosis_unadjusted_2000_a1c.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hepatocytes, Adjusted for HbA1c (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_a1c.png"),
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### ii. glmmTMB
```{r}
#Access the raw count matrix
raw_counts <- GetAssayData(so_celltype_hvg, layer = "counts")

# Step 2: Round manually for sparse matrix (dgCMatrix)
raw_counts_rounded <- raw_counts
raw_counts_rounded@x <- round(raw_counts@x)

# Step 3: Extract the full gene expression matrix (rounded counts)
expr_matrix <- as.matrix(raw_counts_rounded)

#View how rounded counts data looks
#1. Randomly select a few genes for visualization (e.g., top 50 or random)
selected_genes <- sample(rownames(raw_counts_rounded), 25)  # Random 50 genes

#2. Get the expression data for those genes (rounded counts)
selected_data <- as.matrix(raw_counts_rounded[selected_genes, ])

# Convert matrix to data.frame
df_selected_data <- as.data.frame(t(selected_data))  # Transpose so that genes are columns

# 3. **Boxplot** for raw counts of selected genes across cells (to see distribution)
df_selected_data_long <- reshape2::melt(df_selected_data)  # Convert to long format

ggplot(df_selected_data_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  labs(title = "Boxplot of Selected Genes' Counts", x = "Genes", y = "Count") +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
    # legend.position = "none"
  )

# 4. **Heatmap** of raw counts (scaled by genes) for a few cells (e.g., top 50 cells)
top_cells <- sample(colnames(raw_counts_rounded), 50)  # Random 50 cells
heatmap_data <- as.matrix(raw_counts_rounded[selected_genes, top_cells])

# Plot heatmap
pheatmap(heatmap_data, 
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = FALSE,
         main = "Heatmap of Gene Expression (Selected Genes & Cells)") 

#Check rownames and colnames: Rownames = genes, Colnames = cells
#view(expr_matrix)
#Transpose gene expression dataset to merge with metadata
expr_matrix <- t(expr_matrix)
expr_matrix <- data.frame(expr_matrix) #Make a dataframe again after transposing

#Set gene list
gene_list_total <- hvgs

#Create cell variable to merge metadata in
expr_matrix$cellname <- rownames(expr_matrix) 
rownames(expr_matrix) <- NULL

# Extract the metadata
metadata <- .subset(so_celltype_hvg,features=g)@meta.data

#Create cell variable to merge metadata into gene expression data
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,expr_matrix,by="cellname")
rm(metadata,expr_matrix)

#Make sure exposure/independent/x variable or group variable is a factor variable
data$steatosis_cat <- factor(data$steatosis_cat)
#Make sure to set reference level
data$steatosis_cat <- relevel(data$steatosis_cat,ref="Low Steatosis (0+1)")

```


### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA" 

genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hepatocytes_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hepatocytes, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hepatocytes_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()

#Examine distributions 
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
# Step 1: Pull expression for gene PNPLA3
gene_expr <- FetchData(so_celltype, vars = target_genes)

# Step 2: Pull metadata for steatosis_cat
metadata <- so_celltype@meta.data["steatosis_cat"]

# Step 3: Combine into one dataframe
df <- cbind(gene_expr, metadata)
# colnames(df) <- c("PNPLA3", "steatosis_cat")

# Step 4: Plot using ggplot
ggplot(df, aes(x = PNPLA3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "PNPLA3 Expression by Steatosis Category",
       x = "PNPLA3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = GCKR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "GCKR Expression by Steatosis Category",
       x = "GCKR Expression",
       y = "Cell Count")

ggplot(df, aes(x = TM6SF2, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "TM6SF2 Expression by Steatosis Category",
       x = "TM6SF2 Expression",
       y = "Cell Count")

ggplot(df, aes(x = APOC3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "APOC3 Expression by Steatosis Category",
       x = "APOC3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = MTOR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "MTOR Expression by Steatosis Category",
       x = "MTOR Expression",
       y = "Cell Count")
```

## b. Hep-1
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_celltype) <- "RNA" 
so_celltype@assays
head(GetAssayData(so_celltype, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_celltype, layer = "data")[, 1:5])  

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_celltype, layer = "counts")
counts <- counts[rownames(counts) %in% hvgs, ]


# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
# pdf(fs::path(dir.results,"Hep_Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=200, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 2))
abline(v = 1, col="red")  # Poisson expectation
# dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-1, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hepatocytes <- full_results$LogFC
names(rankings_Hepatocytes) <- full_results$Gene
rankings_Hepatocytes <- sort(rankings_Hepatocytes, decreasing = TRUE)
plot(rankings_Hepatocytes)
min(rankings_Hepatocytes)
max(rankings_Hepatocytes)

set.seed(1234)

kegg_legacy_res_Hepatocytes <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_Hepatocytes,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_Hepatocytes <- fgsea(pathways = reactome,
                                  stats = rankings_Hepatocytes,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
reactome_res_Hepatocytes <- data.frame(reactome_res_Hepatocytes)
saveRDS(reactome_res_Hepatocytes,fs::path(dir.results,"Hep_1_Steatosis_Reactome.rds"))
go_res_Hepatocytes <- fgsea(pathways = go,
                            stats = rankings_Hepatocytes,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)
saveRDS(go_res_Hepatocytes,fs::path(dir.results,"Hep_1_Steatosis_GO.rds"))

Hepatocytes_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hepatocytes[, padj < 0.05]), sum(kegg_legacy_res_Hepatocytes[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_Hepatocytes[, padj < 0.05]), sum(reactome_res_Hepatocytes[, pval < 0.05])),
                                "GO"=c(sum(go_res_Hepatocytes[, padj < 0.05]), sum(go_res_Hepatocytes[, pval < 0.05])))
rownames(Hepatocytes_fgsea) <- c("adj.pval", "p.val")
Hepatocytes_fgsea

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"Hep_1_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_1_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_1_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-1, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_1_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()


#Examine distributions 
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
# Step 1: Pull expression for gene PNPLA3
gene_expr <- FetchData(so_celltype, vars = target_genes)

# Step 2: Pull metadata for steatosis_cat
metadata <- so_celltype@meta.data["steatosis_cat"]

# Step 3: Combine into one dataframe
df <- cbind(gene_expr, metadata)
# colnames(df) <- c("PNPLA3", "steatosis_cat")

# Step 4: Plot using ggplot
ggplot(df, aes(x = PNPLA3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "PNPLA3 Expression by Steatosis Category",
       x = "PNPLA3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = GCKR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "GCKR Expression by Steatosis Category",
       x = "GCKR Expression",
       y = "Cell Count")

ggplot(df, aes(x = TM6SF2, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "TM6SF2 Expression by Steatosis Category",
       x = "TM6SF2 Expression",
       y = "Cell Count")

ggplot(df, aes(x = APOC3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "APOC3 Expression by Steatosis Category",
       x = "APOC3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = MTOR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "MTOR Expression by Steatosis Category",
       x = "MTOR Expression",
       y = "Cell Count")
```

### ii. Pathway Enrichment
```{r echo = F}
#Hep-1
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::select(c("gene","log_fc_steatosis_cat_high_steatosis_2_3","fdr")) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
sig_pos <- full_results %>% 
  filter(LogFC>0 & fdr<0.05)
sig_neg <- full_results %>% 
  filter(LogFC<0 & fdr<0.05)

#Run postive enricher analysis 
sig_pos_en <- enrichr(as.character(sig_pos$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[1]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[2]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Kegg")
# plotEnrich(as.data.frame(sig_pos_en[[2]]), title = "Model 1 Positive Hep-1 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Positive Hep-1 - Reactome '22")
# # plotEnrich(as.data.frame(sig_pos_en[[3]]), title = "Model 1 Positive Hep-1 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[5]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Positive Hep-1 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[4]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# # Arrange 6 plots in 3 rows x 2 columns
# combined_plot <- (p1 | p2) / 
#   (p3 | p4) 
# 
# # Display or save the plot
# figure <- combined_plot + 
#   plot_annotation(
#     title = "Positive Gene Set Enrichment Analysis for Hep-1 vs. Steatosis (High/Low)",
#     theme = theme(
#       plot.title = element_text(
#         hjust = 0.5,         # Center title
#         size = 18,           # Bigger font
#         face = "bold"        # Bold text
#       )
#     )
#   )

# ggsave(fs::path(dir.results, "Positive_Hep-1_gsea_figure.jpeg"), figure, width = 18, height = 10)

#Run negative enricher analysis 
sig_neg_en <- enrichr(as.character(sig_neg$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[1]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[2]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Kegg")
# plotEnrich(as.data.frame(sig_neg_en[[2]]), title = "Model 1 Negative Hep-1 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Negative Hep-1 - Reactome '22")
# # plotEnrich(as.data.frame(sig_neg_en[[3]]), title = "Model 1 Negative Hep-1 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[5]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Negative Hep-1 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[4]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# Arrange 6 plots in 3 rows x 2 columns
combined_plot <- (p1 | p2) / 
  (p3 | p4) 

# Display or save the plot
figure <- combined_plot + 
  plot_annotation(
    title = "Negative Gene Set Enrichment Analysis for Hep-1 vs. Steatosis (High/Low)",
    theme = theme(
      plot.title = element_text(
        hjust = 0.5,         # Center title
        size = 18,           # Bigger font
        face = "bold"        # Bold text
      )
    )
  )

ggsave(fs::path(dir.results, "NEBULA_Negative_Hep_1_gsea_figure.jpeg"), figure, width = 18, height = 10)

```

## c. Hep-2
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-2")
DefaultAssay(so_celltype) <- "RNA" 
# so_celltype@assays
# head(GetAssayData(so_celltype, layer = "counts")[, 1:5])  # Raw counts
# head(GetAssayData(so_celltype, layer = "data")[, 1:5])  

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-2, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_2_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hepatocytes <- full_results$LogFC
names(rankings_Hepatocytes) <- full_results$Gene
rankings_Hepatocytes <- sort(rankings_Hepatocytes, decreasing = TRUE)
plot(rankings_Hepatocytes)
min(rankings_Hepatocytes)
max(rankings_Hepatocytes)

set.seed(1234)

kegg_legacy_res_Hepatocytes <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_Hepatocytes,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_Hepatocytes <- fgsea(pathways = reactome,
                                  stats = rankings_Hepatocytes,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
saveRDS(reactome_res_Hepatocytes,fs::path(dir.results,"Hep_2_Steatosis_Reactome.rds"))
go_res_Hepatocytes <- fgsea(pathways = go,
                            stats = rankings_Hepatocytes,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)
saveRDS(go_res_Hepatocytes,fs::path(dir.results,"Hep_2_Steatosis_GO.rds"))
Hepatocytes_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hepatocytes[, padj < 0.05]), sum(kegg_legacy_res_Hepatocytes[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_Hepatocytes[, padj < 0.05]), sum(reactome_res_Hepatocytes[, pval < 0.05])),
                                "GO"=c(sum(go_res_Hepatocytes[, padj < 0.05]), sum(go_res_Hepatocytes[, pval < 0.05])))
rownames(Hepatocytes_fgsea) <- c("adj.pval", "p.val")
# Hepatocytes_fgsea

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hepatocytes, title = "Hep-2 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hepatocytes, title = "Hep-2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hepatocytes, title = "Hep-2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_2_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-2")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_2_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-2, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_2_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

## d. Hep-3
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-3")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-3, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_3_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep3 <- full_results$LogFC
names(rankings_Hep3) <- full_results$Gene
rankings_Hep3 <- sort(rankings_Hep3, decreasing = TRUE)
plot(rankings_Hep3)
min(rankings_Hep3)
max(rankings_Hep3)


set.seed(1234)

kegg_legacy_res_Hep3 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep3,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep3 <- fgsea(pathways = reactome,
                           stats = rankings_Hep3,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
saveRDS(reactome_res_Hep3,fs::path(dir.results,"Hep_3_Steatosis_Reactome.rds"))
go_res_Hep3 <- fgsea(pathways = go,
                     stats = rankings_Hep3,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)
saveRDS(go_res_Hep3,fs::path(dir.results,"Hep_3_Steatosis_GO.rds"))
Hep3_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep3[, padj < 0.05]), sum(kegg_legacy_res_Hep3[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep3[, padj < 0.05]), sum(reactome_res_Hep3[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep3[, padj < 0.05]), sum(go_res_Hep3[, pval < 0.05])))
rownames(Hep3_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hepatocytes, title = "Hep-3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hepatocytes, title = "Hep-3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hepatocytes, title = "Hep-3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_3_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-3")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_3_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-3, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_3_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

## e. Hep-4
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-4")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_4_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-4, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_4_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_4_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_4_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep4 <- full_results$LogFC
names(rankings_Hep4) <- full_results$Gene
rankings_Hep4 <- sort(rankings_Hep4, decreasing = TRUE)
plot(rankings_Hep4)
min(rankings_Hep4)
max(rankings_Hep4)


set.seed(1234)

kegg_legacy_res_Hep4 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep4,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep4 <- fgsea(pathways = reactome,
                           stats = rankings_Hep4,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
saveRDS(reactome_res_Hep4,fs::path(dir.results,"Hep_4_Steatosis_Reactome.rds"))
go_res_Hep4 <- fgsea(pathways = go,
                     stats = rankings_Hep4,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)
saveRDS(go_res_Hep4,fs::path(dir.results,"Hep_4_Steatosis_GO.rds"))
Hep4_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep4[, padj < 0.05]), sum(kegg_legacy_res_Hep4[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep4[, padj < 0.05]), sum(reactome_res_Hep4[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep4[, padj < 0.05]), sum(go_res_Hep4[, pval < 0.05])))
rownames(Hep4_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hep4, title = "Hep-4 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hep4, title = "Hep-4 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hep4, title = "Hep-4 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_4_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-4")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_4_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-4, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_4_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

## f. Hep-5
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-5")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.csv"))
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.csv")) %>% 
  dplyr::select(-X) %>% 
  dplyr::rename(`logFC_steatosis_catHigh Steatosis (2+3)`=logFC_steatosis_catHigh.Steatosis..2.3.)


# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-5, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-2.5,2.5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_5_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep5 <- full_results$LogFC
names(rankings_Hep5) <- full_results$Gene
rankings_Hep5 <- sort(rankings_Hep5, decreasing = TRUE)
plot(rankings_Hep5)
min(rankings_Hep5)
max(rankings_Hep5)


set.seed(1234)

kegg_legacy_res_Hep5 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep5,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep5 <- fgsea(pathways = reactome,
                           stats = rankings_Hep5,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
saveRDS(reactome_res_Hep5,fs::path(dir.results,"Hep_5_Steatosis_reactome.rds"))
go_res_Hep5 <- fgsea(pathways = go,
                     stats = rankings_Hep5,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)
saveRDS(go_res_Hep5,fs::path(dir.results,"Hep_5_Steatosis_GO.rds"))

Hep5_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep5[, padj < 0.05]), sum(kegg_legacy_res_Hep5[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep5[, padj < 0.05]), sum(reactome_res_Hep5[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep5[, padj < 0.05]), sum(go_res_Hep5[, pval < 0.05])))
rownames(Hep5_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hep5, title = "Hep-5 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hep5, title = "Hep-5 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hep5, title = "Hep-5 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_5_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-5")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_5_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-5, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_5_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

## g. dHep
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "dHep, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(-2.5,2.5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_dHep_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_dHep <- full_results$LogFC
names(rankings_dHep) <- full_results$Gene
rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
plot(rankings_dHep)
min(rankings_dHep)
max(rankings_dHep)


set.seed(1234)

kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                              stats = rankings_dHep,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_dHep <- fgsea(pathways = reactome,
                           stats = rankings_dHep,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
go_res_dHep <- fgsea(pathways = go,
                     stats = rankings_dHep,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)
saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                         "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
rownames(dHep_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_dHep, title = "dHep Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_dHep, title = "dHep Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"dHep_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

##B. Other Celltypes
###i. LR Nebula
```{r}
#Filter to celltype 
LR_celltypes <- unique(so_liver_sn$celltype_LR)

# cell_name <- "Hep"
for (cell_name in LR_celltypes[-1]){
  so_celltype <- subset(so_liver_sn,celltype_LR==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  ## Select Highly Variable Genes (HVGs)
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  
  #Make sure exposure/independent/x variable or group variable is a factor variable
  # so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
  so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)
  
  #Make sure to set reference level
  # so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
  so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")
  
  #Round counts layer for nb
  # counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round
  
  # List of genes
  genes_list <- rownames(counts_hvg)
  
  # With parallelization
  cl <- makeCluster(20)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  
  full_results <- as.data.frame(nebula_summaries)
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(genes_list)-length(full_results$gene)
  
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
  
  #Save Results
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv")))
  
}
# names <- colnames(full_results)
# full_results_hep <- read.csv(fs::path(dir.results,paste0("NEBULA_Hep_Steatosis_unadjusted_2000_pooled_offset.csv")))
# low_exp <- 2000-length(full_results_hep$gene)
# full_results_hep$low_exp <- low_exp
# #Filter out non-converging genes
# # full_results_hep <- full_results_hep %>%
# #   filter(!gene %in%  nonconverge_genes)
# #Calculate nonconvergence rate
# full_results_hep$nebula_nonconverged_percent <- 0
# 
# full_results_hep <- full_results_hep %>%
#   dplyr::select(names)

#Heat Map visualization of results
total_results <- data.frame()
LR_celltypes <- unique(so_liver_sn$celltype_LR)[-1]
for (cell_name in LR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_type
  total_results <- rbind(total_results,full_results)
}

# # full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
# full_results_hep <- full_results_hep %>% 
#   clean_names() %>% 
#   dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
#   dplyr::rename(Gene=gene)
# full_results_hep <- full_results_hep[,-1]
# full_results_hep$Celltype <- "Hep"
# total_results <- rbind(total_results,full_results_hep)
# write.csv(total_results,fs::path(dir.results,"All_Celltypes_NEBULA_Results.csv"))

total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Celltype, logFC, signif)
LR_celltypes <- unique(so_liver_sn$celltype_LR)
custom_order <- LR_celltypes
heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
# custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
#                    "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Celltype, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "2000 HVGs by Steatosis Grade",
       x = "Exposure",
       y = "Gene") +
  # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

# png(fs::path(dir.results, "Heatmap_NEBULA_All_Celltypess_unadjusted_pooled_offset_Steatosis.png"),
#     width = 1500, height = 2000, res = 300)
# print(heat_map_p)
# dev.off()

# Prepare data for volcano plots - keeping your exact color scheme and logic
total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# Add -log10(p-value) column if not already present
# Assuming you have a p-value column, adjust the name as needed
if("pvalue" %in% names(total_results)) {
  total_results$PValue10 <- -log10(total_results$pvalue)
} else if("p.value" %in% names(total_results)) {
  total_results$PValue10 <- -log10(total_results$p.value)
} else {
  # If only FDR is available, use it as approximation
  total_results$PValue10 <- -log10(total_results$fdr)
}

# Set factor levels for cell type ordering
total_results$Celltype <- factor(total_results$Celltype, levels = LR_celltypes)
# total_results$Celltype <- "Hepatocytes"

# Calculate statistics for caption (will be done per cell type)
summary_stats <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Genes = n_distinct(Gene),
    Significant = sum(fdr < 0.05),
    .groups = 'drop'
  )

# Create the faceted volcano plot matching your style
volcano_plots <- ggplot(total_results, aes(x = logFC, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  
  # # Add labels for significant points
  # geom_text(data = total_results[total_results$fdr < 0.05, ], 
  #           aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black",fontface="bold") +
  geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
                  aes(label = Gene),
                  size = 3, 
                  color = "black", 
                  fontface = "bold",
                  box.padding = 0.3,        # Space around each label
                  point.padding = 0.3,      # Space around each point
                  segment.color = "gray50", # Color of connecting lines
                  segment.size = 0.3,       # Thickness of connecting lines
                  max.overlaps = 20,        # Maximum number of overlaps allowed
                  min.segment.length = 0.1) + # Minimum segment length to draw
  
  # Facet by cell type
  # facet_wrap(~ Celltype, 
  #            ncol = 2,  # Adjust as needed
  #            scales = "free_y") +  # Free y-scale but fixed x-scale
  
  # Set x-axis limits matching your original
  xlim(-2, 2) +
  
  # Labels and theme matching your style
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
    subtitle = "2000 HVGs",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

# Display the plot
print(volcano_plots)
png(fs::path(dir.results,"Supplemental Results", "Volcano_Plots_NEBULA_Other_Celltypess_unadjusted_pooled_offset_Steatosis.png"),
    width = 2000, height = 2000, res = 300)
print(volcano_plots)
dev.off()

png(fs::path(dir.results,"Supplemental Results", "Volcano_Plots_NEBULA_Hepatocytes_unadjusted_pooled_offset_Steatosis.png"),
    width = 2000, height = 2000, res = 300)
print(volcano_plots)
dev.off()

```
### ii. LR GSEA
```{r echo = F}
LR_celltypes <- unique(so_liver_sn$celltype_LR)
for (cell_name in LR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  # full_results <- full_results %>% 
  #   clean_names() %>% 
  #   dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
  #   dplyr::rename(Gene=gene)
  # full_results <- full_results[,-1]
  # full_results$Celltype <- cell_name
  
  
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  full_results <- full_results %>%
    clean_names() %>% 
    dplyr::select(-x) %>% 
    dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- full_results$LogFC
  names(rankings_dHep) <- full_results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  # 
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(cell_name," Top 30 REACTOME Pathways"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(cell_name,"  Top 30 GO Pathways"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 2)
  print(combined_plot)
  ggsave(fs::path(dir.results,"Supplemental Results",paste0(cell_name,"_top30_pathways_unadjusted.jpeg")),
         width = 25, height = 10, scale = 1)
}
```
### iii. LR Targeted Genes
```{r}

#Filter to celltype 
LR_celltypes <- unique(so_liver_sn$celltype_LR)

# cell_name <- "Hep"
for (cell_name in LR_celltypes){
  so_celltype <- subset(so_liver_sn,celltype_LR==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  # #Filter to PT Cells
  # so_celltype <- subset(so_liver_sn,celltype=="dHep")
  # DefaultAssay(so_celltype) <- "RNA" 
  
  
  genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
  so_celltype_hvg <- subset(so_celltype, features =genes_list)
  DefaultAssay(so_celltype_hvg) <- "RNA"
  so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
  #Make sure to set reference level
  so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
  nrow(so_celltype_hvg) #28964 genes
  Nuclei <- ncol(so_celltype_hvg) #130124 nuclei
  
  counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  
  # With parallelization
  
  cl <- makeCluster(1)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
      pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
  full_results$cell_name <- cell_name
  write.csv(full_results,fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv")))
}

total_results <- data.frame()
LR_celltypes <- unique(so_liver_sn$celltype_LR)
for (cell_name in LR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(se=se_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(pval=p_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_name
  total_results <- rbind(total_results,full_results)
}

# Calculate Confidence Intervals (95% CI) by cell type
total_results <- total_results %>%
  group_by(cell_name) %>%  # Group by cell type
  mutate(
    CI_Lower = logFC - 1.96 * se,
    CI_Upper = logFC + 1.96 * se,
    sig = ifelse(pval < 0.05, "*", "")
  ) %>%
  ungroup()  # Remove grouping

# Create the coefficient plot with facet wrap
dot_plot <- ggplot(total_results, aes(x = logFC, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), 
                 height = 0.2, color = "#f4a261") +
  geom_point(size = 3, color = "darkred") +
  # "#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"
  # Add facet wrap by cell type
  facet_wrap(~ cell_name, 
             scales = "free_y",  # Allow different genes per cell type
             ncol = 3) +  # Adjust number of columns as needed
  
  labs(title = "Targeted Gene Analysis: Steatosis (High vs. Low) by Cell Type",
       # subtitle = "Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", 
       y = "Gene") +
  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),  # Smaller text for faceted plot
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 9),  # Cell type labels
    strip.background = element_rect(fill = "gray95", color = NA),
    text = element_text(size = 10),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(dot_plot)

# Save the plot
png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_All_Cells_LR_Steatosis_unadjusted.png"),
    width = 2500, height = 1500, res = 300)  # Increased size for faceted plot
print(dot_plot)
dev.off()



# 
# 
# # Calculate Confidence Intervals (95% CI)
# full_results <- full_results %>%
#   mutate(
#     CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
#     CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
#   )
# full_results <- full_results %>% 
#   mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))
# 
# # Create the coefficient plot
# dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
#   geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
#   geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
#   # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
#   labs(title = "Steatosis (High vs. Low) in All Cell Types",
#        subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
#        x = "LogFC", y = "Gene",
#        caption=paste0("Nuclei = ",Nuclei) )+
#   geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
#   theme_minimal() +
#   theme(axis.text.y = element_text(size = 10),
#         axis.title.x = element_text(size = 10),
#         axis.title.y = element_text(size = 10),
#         text =element_text(size=10)) 
# dot_plot
# 
# png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
#     width = 2500, height = 2100, res = 300)
# print(dot_plot)
# dev.off()
```

###iv. HR Nebula
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_liver_sn$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
cell_name <- "Hep-2"
# for (cell_name in HR_celltypes)
# {
so_celltype <- subset(so_liver_sn,celltype==cell_name)
DefaultAssay(so_celltype) <- "RNA" 

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)

full_results <- as.data.frame(nebula_summaries)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
) 

#Calculate number of genes filtered out for low expression 
full_results$low_exp <- length(genes_list)-length(full_results$gene)

#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)

#Calculate nonconvergence rate
full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")

full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

cell_name2 <- str_replace_all(cell_name,"/","_")
cell_name2 <- str_replace_all(cell_name2,"-","_")

#Save Results
write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",cell_name2,"_Steatosis_unadjusted_2000_pooled_offset.csv")))

# }

#Heat Map visualization of results
total_results <- data.frame()
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "EC_2"
for (cell_name2 in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name2,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_name2
  total_results <- rbind(total_results,full_results)
}

total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Celltype, logFC, signif)

custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
                  "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
                  "Stellate_1","Stellate_2",
                  "Cholang","EC_1","EC_2")
heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
# custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
#                    "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Celltype, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "2000 HVGs by Steatosis Grade",
       x = "Celltype",
       y = "Gene") +
  # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )
print(heat_map_p )
# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_NEBULA_All_Celltypes_HR_unadjusted_pooled_offset_Steatosis.png"),
    width = 4000, height = 4000, res = 300)
print(heat_map_p)
dev.off()

# Prepare data for volcano plots - keeping your exact color scheme and logic
total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# # Add -log10(p-value) column if not already present
# # Assuming you have a p-value column, adjust the name as needed
# if("pvalue" %in% names(total_results)) {
#   total_results$PValue10 <- -log10(total_results$pvalue)
# } else if("p.value" %in% names(total_results)) {
#   total_results$PValue10 <- -log10(total_results$p.value)
# } else {
#   # If only FDR is available, use it as approximation
#   total_results$PValue10 <- -log10(total_results$fdr)
# }

# Set factor levels for cell type ordering
# total_results$Celltype <- factor(total_results$Celltype, levels = HR_celltypes)

# Calculate statistics for caption (will be done per cell type)
summary_stats <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Genes = n_distinct(Gene),
    Significant = sum(fdr < 0.05),
    .groups = 'drop'
  )
summary_stats <- summary_stats %>% 
  mutate(Significant=ifelse(Celltype=="Stellate_2",0,Significant))

total_results <- total_results %>% 
  na.omit()

# # Create the faceted volcano plot matching your style
# volcano_plots <- ggplot(total_results, aes(x = logFC, y = p_value10, color = color)) +
#   geom_point(alpha = 0.7) +  # Plot points with transparency
#   scale_color_identity() +  # Use the color column directly
#   
#   # # Add labels for significant points
#   # geom_text(data = total_results[total_results$fdr < 0.05, ], 
#   #           aes(label = Gene),
#   #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
#     geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
#                   aes(label = Gene),
#                   size = 3, 
#                   color = "black", 
#                   fontface = "bold",
#                   box.padding = 0.3,        # Space around each label
#                   point.padding = 0.3,      # Space around each point
#                   segment.color = "gray50", # Color of connecting lines
#                   segment.size = 0.3,       # Thickness of connecting lines
#                   max.overlaps = 20,        # Maximum number of overlaps allowed
#                   min.segment.length = 0.1) + # Minimum segment length to draw
#   # 
#   # Facet by cell type
#   facet_wrap(~ Celltype, 
#              ncol = 4,  # Adjust as needed
#              scales = "free_y") +  # Free y-scale but fixed x-scale
#   
#   # Set x-axis limits matching your original
#   xlim(-3, 3) +
#   
#   # Labels and theme matching your style
#   labs(
#     title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
#     subtitle = "2000 HVGs, Unadjusted",
#     x = "Log Fold Change",
#     y = "-log10(P-Value)"
#     # caption = paste0("FDR < 0.05, Genes = ", Genes, ", Significant = ", Significant_Genes)
#   ) +
#   
#   theme_minimal() +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.x = element_text(angle = 0, hjust = 1),
#     strip.text = element_text(face = "bold", size = 10),
#     strip.background = element_rect(fill = "gray95", color = NA),
#     panel.border = element_rect(color = "gray80", fill = NA)
#   )
# Define your desired order
desired_order <- c("Hep_1", "Hep_2", "Hep_3", "Hep_4", "Hep_5", 
                   "dHep", "Hep_Immune", 
                   "EC_1", "EC_2", 
                   "Stellate_1", "Stellate_2",
                   "Cholang", 
                   "B_Plasma", "cFIB_cImmune", "Kup_MAC", "Kup_MON", "NKC_NKT")

# Convert Celltype to factor with custom order
total_results$Celltype <- factor(total_results$Celltype, levels = desired_order)

# Then your existing ggplot code
volcano_plots <- ggplot(total_results, aes(x = logFC, y = p_value10, color = color)) +
  geom_point(alpha = 0.7) +  
  scale_color_identity() +  
  
  geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
                  aes(label = Gene),
                  size = 3, 
                  color = "black", 
                  fontface = "bold",
                  box.padding = 0.3,       
                  point.padding = 0.3,     
                  segment.color = "gray50", 
                  segment.size = 0.3,      
                  max.overlaps = 20,       
                  min.segment.length = 0.1) + 
  
  # Facet by cell type (will now use the custom order)
  facet_wrap(~ Celltype, 
             ncol = 4,  
             scales = "free_y") +  
  
  xlim(-3, 3) +
  
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
    subtitle = "2000 HVGs, Unadjusted",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(volcano_plots)

png(fs::path(dir.results, "Supplemental Results","Volcano_Plots_NEBULA_All_Celltypes_HR_unadjusted_pooled_offset_Steatosis.png"),
    width = 5000, height = 4000, res = 300)
print(volcano_plots)
dev.off()

# Alternative: Create individual plots with custom captions for each cell type
library(patchwork)

# Function to create individual volcano plots matching your exact style
create_volcano_by_celltype <- function(data, celltype_name) {
  
  # Filter data for this cell type
  ct_data <- filter(data, Celltype == celltype_name)
  
  # Identify significant points
  significant_df <- ct_data[ct_data$fdr < 0.05, ]
  
  # Calculate stats for this cell type
  Genes <- length(unique(ct_data$Gene))
  Significant_Genes <- nrow(significant_df)
  
  # Create the plot
  p <- ggplot(ct_data, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    theme_minimal() +
    labs(
      title = celltype_name,
      subtitle = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
      x = "Log Fold Change",
      y = "-log10(P-Value)",
      caption = paste0("FDR < 0.05, Genes = ", Genes, ", Significant = ", Significant_Genes)
    ) +
    theme(
      plot.title = element_text(hjust = 0, face = "bold"),
      plot.subtitle = element_text(hjust = 0, size = 9),
      axis.text.x = element_text(angle = 0, hjust = 1),
      plot.caption = element_text(size = 7, hjust = 0)
    ) +
    xlim(-2.5, 2.5) +
    geom_text(data = significant_df, aes(label = Gene),
              vjust = 1, hjust = 1, size = 2.5, check_overlap = TRUE, color = "black")
  
  return(p)
}

# Create individual plots for each cell type
volcano_list <- list()
for (ct in levels(total_results$Celltype)) {
  volcano_list[[ct]] <- create_volcano_by_celltype(total_results, ct)
}

# Combine plots using patchwork
combined_volcanoes <- wrap_plots(volcano_list, ncol = 3) + 
  plot_annotation(
    title = "Differential Gene Expression by Cell Type",
    subtitle = "High Steatosis (2+3) vs. Low Steatosis (0+1), 2000 HVGs",
    theme = theme(
      plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
      plot.subtitle = element_text(hjust = 0.5, size = 11)
    )
  )

print(combined_volcanoes)

# Version with ggrepel for better label placement (if you prefer)
library(ggrepel)

volcano_plots_repel <- ggplot(total_results, aes(x = logFC, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  
  # Add labels for significant points with ggrepel
  geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
                  aes(label = Gene),
                  size = 2.5, color = "black", 
                  box.padding = 0.3, 
                  point.padding = 0.2,
                  max.overlaps = 10,
                  segment.size = 0.3) +
  
  facet_wrap(~ Celltype, ncol = 3, scales = "free_y") +
  xlim(-2.5, 2.5) +
  
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
    subtitle = "2000 HVGs, Unadjusted",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

# Create a summary plot showing number of DEGs per cell type
deg_summary <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Upregulated = sum(fdr < 0.05 & logFC > 0),
    Downregulated = sum(fdr < 0.05 & logFC < 0),
    .groups = 'drop'
  ) %>%
  pivot_longer(cols = c(Upregulated, Downregulated), 
               names_to = "Direction", 
               values_to = "Count")

summary_barplot <- ggplot(deg_summary, aes(x = Celltype, y = Count, fill = Direction)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("Upregulated" = "#990000", "Downregulated" = "#003366")) +
  theme_minimal() +
  labs(title = "Number of Differentially Expressed Genes by Cell Type",
       x = "Cell Type",
       y = "Number of DEGs (FDR < 0.05)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5, face = "bold"))

print(summary_barplot)
# }
```
### v. HR GSEA
```{r echo = F}
HR_celltypes <- unique(so_liver_sn$celltype)
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
HR_celltypes <- str_replace_all(HR_celltypes,"/","_")

for (cell_name in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  # full_results <- full_results %>% 
  #   clean_names() %>% 
  #   dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
  #   dplyr::rename(Gene=gene)
  # full_results <- full_results[,-1]
  # full_results$Celltype <- cell_name
  
  
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  full_results <- full_results %>%
    clean_names() %>% 
    dplyr::select(-x) %>% 
    dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- full_results$LogFC
  names(rankings_dHep) <- full_results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  # 
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(cell_name," Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(cell_name," Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,"Supplemental Results",paste0(cell_name,"_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
}
```
### iii. HR Targeted Genes
```{r}

#Filter to celltype 
HR_celltypes <- unique(so_liver_sn$celltype)

# cell_name <- "Hep"
for (cell_name in HR_celltypes){
  so_celltype <- subset(so_liver_sn,celltype==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  # #Filter to PT Cells
  # so_celltype <- subset(so_liver_sn,celltype=="dHep")
  # DefaultAssay(so_celltype) <- "RNA" 
  
  
  genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
  so_celltype_hvg <- subset(so_celltype, features =genes_list)
  DefaultAssay(so_celltype_hvg) <- "RNA"
  so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
  #Make sure to set reference level
  so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
  nrow(so_celltype_hvg) #28964 genes
  Nuclei <- ncol(so_celltype_hvg) #130124 nuclei
  
  counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  
  # With parallelization
  
  cl <- makeCluster(1)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
      pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
  full_results$cell_name <- cell_name
  full_results$cell_name <- str_replace_all(full_results$cell_name,"-","_")
  full_results$cell_name <- str_replace_all(full_results$cell_name,"/","_")
  cell_name <- str_replace_all(cell_name,"-","_")
  cell_name <- str_replace_all(cell_name,"/","_")
  write.csv(full_results,fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv")))
}

total_results <- data.frame()
HR_celltypes <- unique(so_liver_sn$celltype)
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
HR_celltypes <- str_replace_all(HR_celltypes,"/","_")
for (cell_name in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(se=se_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(pval=p_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_name
  total_results <- rbind(total_results,full_results)
}

# Calculate Confidence Intervals (95% CI) by cell type
total_results <- total_results %>%
  group_by(cell_name) %>%  # Group by cell type
  mutate(
    CI_Lower = logFC - 1.96 * se,
    CI_Upper = logFC + 1.96 * se,
    sig = ifelse(pval < 0.05, "*", "")
  ) %>%
  ungroup()  # Remove grouping

# Create the coefficient plot with facet wrap
dot_plot <- ggplot(total_results, aes(x = logFC, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), 
                 height = 0.2, color = "#f4a261") +
  geom_point(size = 3, color = "darkred") +
  # "#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"
  # Add facet wrap by cell type
  facet_wrap(~ cell_name, 
             scales = "free_y",  # Allow different genes per cell type
             ncol = 3) +  # Adjust number of columns as needed
  
  labs(title = "Targeted Gene Analysis: Steatosis (High vs. Low) by Cell Sub-Type",
       # subtitle = "Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", 
       y = "Gene") +
  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),  # Smaller text for faceted plot
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 9),  # Cell type labels
    strip.background = element_rect(fill = "gray95", color = NA),
    text = element_text(size = 10),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(dot_plot)

# Define your desired order for cell types
desired_order <- c("Hep_1", "Hep_2", "Hep_3", "Hep_4", "Hep_5","dHep", "Hep_Immune",
                   "Stellate_1", "Stellate_2", 
                   "EC_1", "EC_2",
                   "Cholang",
                   "B_Plasma", "cFIB_cImmune", "Kup_MAC", "Kup_MON", "NKC_NKT")

# Convert cell_name to factor with custom order
total_results$cell_name <- factor(total_results$cell_name, levels = desired_order)

# Create the coefficient plot with facet wrap
dot_plot <- ggplot(total_results, aes(x = logFC, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), 
                 height = 0.2, color = "#f4a261") +
  geom_point(size = 3, color = "darkred") +
  
  # Add facet wrap by cell type (now with custom order)
  facet_wrap(~ cell_name, 
             scales = "free_y",
             ncol = 3) +
  
  labs(title = "Targeted Gene Analysis: Steatosis (High vs. Low) by Cell Sub-Type",
       x = "LogFC", 
       y = "Gene") +
  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 9),
    strip.background = element_rect(fill = "gray95", color = NA),
    text = element_text(size = 10),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(dot_plot)

# Save the plot
png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_All_Cells_HR_Steatosis_unadjusted.png"),
    width = 4000, height = 3500, res = 300)  # Increased size for faceted plot
print(dot_plot)
dev.off()



# 
# 
# # Calculate Confidence Intervals (95% CI)
# full_results <- full_results %>%
#   mutate(
#     CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
#     CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
#   )
# full_results <- full_results %>% 
#   mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))
# 
# # Create the coefficient plot
# dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
#   geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
#   geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
#   # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
#   labs(title = "Steatosis (High vs. Low) in All Cell Types",
#        subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
#        x = "LogFC", y = "Gene",
#        caption=paste0("Nuclei = ",Nuclei) )+
#   geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
#   theme_minimal() +
#   theme(axis.text.y = element_text(size = 10),
#         axis.title.x = element_text(size = 10),
#         axis.title.y = element_text(size = 10),
#         text =element_text(size=10)) 
# dot_plot
# 
# png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
#     width = 2500, height = 2100, res = 300)
# print(dot_plot)
# dev.off()
```
### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```

##C. Ballooning & Steatosis
###iv. HR Nebula
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_liver_sn$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
# cell_name <- "Hep-1"
for (cell_name in HR_celltypes){
  so_celltype <- subset(so_liver_sn,celltype==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  ## Select Highly Variable Genes (HVGs)
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  
  so_celltype$ballooning_steatosis_cat <- factor(so_celltype$ballooning_steatosis_cat,levels = c("No Steatosis, No Ballooning","Any Steatosis, No Ballooning","Any Steatosis, Any Ballooning"))
  so_celltype$ballooning_steatosis_cat <- relevel(so_celltype$ballooning_steatosis_cat,ref="No Steatosis, No Ballooning")
  
  #Round counts layer for nb
  # counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round
  
  # List of genes
  genes_list <- rownames(counts_hvg)
  
  # With parallelization
  cl <- makeCluster(20)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      pred_gene <- model.matrix(~ballooning_steatosis_cat, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  # Extract results in LONG format (one row per gene-coefficient pair)
  nebula_results_df <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      tryCatch({
        result_obj <- nebula_results_list[[gene_name]]
        
        # Check if summary exists
        if (!is.null(result_obj$summary) && nrow(result_obj$summary) > 0) {
          
          summary_df <- result_obj$summary
          
          # Get coefficient columns (start with "logFC_")
          coef_cols <- grep("^logFC_", colnames(summary_df), value = TRUE)
          
          # Extract data for each coefficient
          results_list <- lapply(coef_cols, function(coef) {
            
            # Remove "logFC_" prefix to get coefficient name
            coef_name <- gsub("^logFC_", "", coef)
            
            # Get corresponding se and p-value columns
            se_col <- paste0("se_", coef_name)
            p_col <- paste0("p_", coef_name)
            
            # Create row for this gene-coefficient combination
            data.frame(
              gene = gene_name,
              coefficient = coef_name,
              logFC = summary_df[[coef]],
              se = summary_df[[se_col]],
              p_value = summary_df[[p_col]],
              stringsAsFactors = FALSE
            )
          })
          
          # Combine all coefficients for this gene
          do.call(rbind, results_list)
          
        } else {
          return(NULL)
        }
        
      }, error = function(e) {
        message("Error processing gene ", gene_name, ": ", e$message)
        return(NULL)
      })
    }
  )
  
  # Remove any NULL entries
  nebula_results_df <- nebula_results_df %>%
    filter(!is.na(gene))
  
  # FDR correction within each coefficient type
  nebula_results_df <- nebula_results_df %>%
    group_by(coefficient) %>%
    mutate(
      fdr = p.adjust(p_value, method = "fdr")) %>%
    ungroup()
  
  # Intercept (baseline/reference level)
  intercept_df <- nebula_results_df %>%
    filter(coefficient == "(Intercept)")
  
  # Stage 2: Any Steatosis, No Ballooning vs Reference
  stage2_df <- nebula_results_df %>%
    filter(grepl("No Ballooning", coefficient, ignore.case = TRUE))
  
  # Stage 3: Any Steatosis, Any Ballooning vs Reference
  stage3_df <- nebula_results_df %>%
    filter(grepl("Any Ballooning", coefficient, ignore.case = TRUE))
  
  # Get Stage 2 estimates (Stage 2 vs Stage 1)
  stage2_estimates <- nebula_results_df %>%
    filter(grepl("No Ballooning", coefficient, ignore.case = TRUE)) %>%
    select(gene, 
           logFC_stage2 = logFC, 
           se_stage2 = se, 
           p_stage2 = p_value,
           fdr2 = fdr)
  
  # Get Stage 3 estimates (Stage 3 vs Stage 1)
  stage3_estimates <- nebula_results_df %>%
    filter(grepl("Any Ballooning", coefficient, ignore.case = TRUE)) %>%
    select(gene, 
           logFC_stage3 = logFC, 
           se_stage3 = se, 
           p_stage3 = p_value,
           fdr3 =fdr)
  
  # Merge the two
  stage3_vs_stage2 <- inner_join(stage2_estimates, stage3_estimates, by = "gene")
  
  # Calculate the contrast
  stage3_vs_stage2 <- stage3_vs_stage2 %>%
    mutate(
      # LogFC for Stage 3 vs Stage 2 = (Stage 3 vs Stage 1) - (Stage 2 vs Stage 1)
      logFC_contrast = logFC_stage3 - logFC_stage2,
      
      # Standard error of the difference
      # SE(A - B) = sqrt(SE(A)^2 + SE(B)^2) assuming independence
      se_contrast = sqrt(se_stage2^2 + se_stage3^2),
      
      # Z-statistic
      z_statistic = logFC_contrast / se_contrast,
      
      # Two-tailed p-value
      p_value_contrast = 2 * pnorm(-abs(z_statistic)),
      
      # Direction of change
      direction = case_when(
        logFC_contrast > 0 ~ "Higher in Stage 3",
        logFC_contrast < 0 ~ "Higher in Stage 2",
        TRUE ~ "No change"
      ),
      
      # Absolute effect size
      abs_logFC = abs(logFC_contrast)
    )
  
  # Add FDR correction for the contrast
  stage3_vs_stage2 <- stage3_vs_stage2 %>%
    mutate(fdr_contrast = p.adjust(p_value_contrast, method = "fdr"))
  
  
  # Comparison 1: Stage 2 vs Stage 1 (already have this)
  comp1 <- stage2_df %>%
    select(gene, logFC, se, p_value, fdr) %>%
    mutate(
      comparison = "Stage 2 vs Stage 1\nSteatosis & No Ballooning vs. No Steatosis, No Ballooning",
      comparison_short = "Stage 2 vs 1",
      significant = fdr < 0.05,
      sig_label = ifelse(significant, "FDR < 0.05", "Not Significant")
    )
  
  # Comparison 2: Stage 3 vs Stage 1 (already have this)
  comp2 <- stage3_df %>%
    select(gene, logFC, se, p_value, fdr) %>%
    mutate(
      comparison = "Stage 3 vs Stage 1\nSteatosis & Ballooning vs. No Steatosis, No Ballooning",
      comparison_short = "Stage 3 vs 1",
      significant = fdr < 0.05,
      sig_label = ifelse(significant, "FDR < 0.05", "Not Significant")
    )
  
  # Comparison 3: Stage 3 vs Stage 2 (the contrast we calculated)
  comp3 <- stage3_vs_stage2 %>%
    select(gene, 
           logFC = logFC_contrast, 
           se = se_contrast, 
           p_value = p_value_contrast, 
           fdr = fdr_contrast) %>%
    mutate(
      comparison = "Stage 3 vs Stage 2\nSteatosis & Ballooning vs Steatosis & No Ballooning",
      comparison_short = "Stage 3 vs 2",
      significant = fdr < 0.05,
      sig_label = ifelse(significant, "FDR < 0.05", "Not Significant")
    )
  
  # Combine all three
  all_comparisons <- bind_rows(comp1, comp2, comp3)
  
  # Make comparison a factor with specific order
  all_comparisons$comparison <- factor(
    all_comparisons$comparison,
    levels = c(
      "Stage 2 vs Stage 1\nSteatosis & No Ballooning vs. No Steatosis, No Ballooning",
      "Stage 3 vs Stage 2\nSteatosis & Ballooning vs Steatosis & No Ballooning",
      "Stage 3 vs Stage 1\nSteatosis & Ballooning vs. No Steatosis, No Ballooning"
    )
  )
  
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  #Calculate number of genes filtered out for low expression 
  all_comparisons$low_exp <- length(genes_list)-length(unique(all_comparisons$gene))
  
  #Filter out non-converging genes
  all_comparisons <- all_comparisons %>% 
    filter(!gene %in%  nonconverge_genes)
  
  #Calculate nonconvergence rate
  all_comparisons$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  
  cell_name2 <- str_replace_all(cell_name,"/","_")
  cell_name2 <- str_replace_all(cell_name2,"-","_")
  
  all_comparisons <- all_comparisons %>% 
    mutate(Log10Pvalue=-log10(p_value))
  
  write.csv(all_comparisons,paste0("/home/hhampson/Results/NEBULA_",cell_name2,"_Ballooning_Steatosis_Cat_unadjusted_2000_pooled_offset.csv"))
  
  # Define colors
  all_comparisons <- all_comparisons %>%
    mutate(
      color_category = case_when(
        fdr < 0.05 & logFC > 0 ~ "Up-regulated (FDR < 0.05)",
        fdr < 0.05 & logFC < 0 ~ "Down-regulated (FDR < 0.05)",
        TRUE ~ "Not Significant"
      ),
      point_color = case_when(
        fdr < 0.05 & logFC > 0 ~ "#990000",
        fdr < 0.05 & logFC < 0 ~ "#003366",
        TRUE ~ "lightgray"
      )
    )
  
  # Get top 10 UP-regulated genes per comparison
  top_up <- all_comparisons %>%
    filter(fdr < 0.05, logFC > 0) %>%
    group_by(comparison) %>%
    arrange(p_value) %>%
    slice_head(n = 10) %>%
    ungroup() %>%
    select(comparison, gene)
  
  # Get top 10 DOWN-regulated genes per comparison
  top_down <- all_comparisons %>%
    filter(fdr < 0.05, logFC < 0) %>%
    group_by(comparison) %>%
    arrange(p_value) %>%
    slice_head(n = 10) %>%
    ungroup() %>%
    select(comparison, gene)
  
  # Combine top genes
  top_genes <- bind_rows(top_up, top_down)
  
  # Add label column
  all_comparisons <- all_comparisons %>%
    left_join(top_genes %>% mutate(is_top = TRUE), 
              by = c("comparison", "gene")) %>%
    mutate(
      label = ifelse(is_top == TRUE & !is.na(is_top), gene, "")
    ) %>%
    select(-is_top)
  
  # Define colors for scale
  color_values <- c(
    "Up-regulated (FDR < 0.05)" = "#990000",
    "Down-regulated (FDR < 0.05)" = "#003366",
    "Not Significant" = "lightgray"
  )
  
  
  p_volcano_faceted <- ggplot(all_comparisons, 
                              aes(x = logFC, y = Log10Pvalue)) +
    # Points
    geom_point(aes(color = color_category), alpha = 0.6, size = 1.2) +
    
    # Gene labels with repel
    geom_text_repel(
      aes(label = label),
      size = 2.5,
      max.overlaps = 20,
      box.padding = 0.5,
      point.padding = 0.3,
      segment.size = 0.2,
      segment.alpha = 0.6,
      min.segment.length = 0,
      force = 2,
      seed = 42
    ) +
    
    # Color scale
    scale_color_manual(
      values = color_values,
      name = "",
      breaks = c("Up-regulated (FDR < 0.05)", 
                 "Down-regulated (FDR < 0.05)", 
                 "Not Significant")
    ) +
    
    # Reference lines
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.4, color = "black") +
    # geom_hline(yintercept = -log10(0.05), linetype = "dashed", alpha = 0.4, color = "gray40") +
    
    # Faceting
    facet_wrap(~comparison, ncol = 3, scales = "free_x") +
    
    # Theme
    theme_bw(base_size = 12) +
    theme(
      legend.position = "bottom",
      legend.direction = "horizontal",
      strip.background = element_rect(fill = "gray95", color = "gray60"),
      strip.text = element_text(face = "bold", size = 10),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90"),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      plot.subtitle = element_text(hjust = 0.5, size = 11)
    ) +
    
    # Labels
    labs(
      title = "Differential Gene Expression for Hepatocyte Ballooning & Steatosis",
      subtitle = paste0("Pediatric MASLD Progression in ",cell_name),
      x = "Log2 Fold Change",
      y = "-log10(p-value)"
    ) +
    
    # Guide styling
    guides(color = guide_legend(override.aes = list(size = 3, alpha = 1)))
  
  print(p_volcano_faceted)
  
  png(paste0("/home/hhampson/Results/NEBULA_",cell_name2,"_Ballooning_Steatosis_Cat_unadjusted_2000_pooled_offset.png"),res=300,height=1900,width=4000)
  print(p_volcano_faceted)
  dev.off()
  
}


```

```{r}
# hep_nebula_converged <- map_dfr(
#   names(nebula_results_list),
#   function(gene_name) {
#     converged <- nebula_results_list[[gene_name]]$convergence
#     df <- data.frame(Gene = gene_name,
#                      Convergence_Code = converged)
#     return(df)
#   }
# )
# 
# nebula_summaries <- map_dfr(
#   names(nebula_results_list),
#   function(gene_name) {
#     df <- nebula_results_list[[gene_name]]$summary
#     df <- df %>% mutate(Gene = gene_name)
#     return(df)
#   }
# )

full_results <- as.data.frame(nebula_summaries)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
) 

#Calculate number of genes filtered out for low expression 
full_results$low_exp <- length(genes_list)-length(full_results$gene)

#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)

#Calculate nonconvergence rate
full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")

full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

cell_name2 <- str_replace_all(cell_name,"/","_")
cell_name2 <- str_replace_all(cell_name2,"-","_")

#Save Results
write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",cell_name2,"_Steatosis_unadjusted_2000_pooled_offset.csv")))

# }

#Heat Map visualization of results
total_results <- data.frame()
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "EC_2"
for (cell_name2 in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name2,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_name2
  total_results <- rbind(total_results,full_results)
}

total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename LogFC for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Celltype, logFC, signif)

custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
                  "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
                  "Stellate_1","Stellate_2",
                  "Cholang","EC_1","EC_2")
heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
# custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
#                    "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Celltype, y = Gene, fill = logFC)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "2000 HVGs by Steatosis Grade",
       x = "Celltype",
       y = "Gene") +
  # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )
print(heat_map_p )
# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_NEBULA_All_Celltypes_HR_unadjusted_pooled_offset_Steatosis.png"),
    width = 4000, height = 4000, res = 300)
print(heat_map_p)
dev.off()

# Prepare data for volcano plots - keeping your exact color scheme and logic
total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))

# # Add -log10(p-value) column if not already present
# # Assuming you have a p-value column, adjust the name as needed
# if("pvalue" %in% names(total_results)) {
#   total_results$PValue10 <- -log10(total_results$pvalue)
# } else if("p.value" %in% names(total_results)) {
#   total_results$PValue10 <- -log10(total_results$p.value)
# } else {
#   # If only FDR is available, use it as approximation
#   total_results$PValue10 <- -log10(total_results$fdr)
# }

# Set factor levels for cell type ordering
# total_results$Celltype <- factor(total_results$Celltype, levels = HR_celltypes)

# Calculate statistics for caption (will be done per cell type)
summary_stats <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Genes = n_distinct(Gene),
    Significant = sum(fdr < 0.05),
    .groups = 'drop'
  )
summary_stats <- summary_stats %>% 
  mutate(Significant=ifelse(Celltype=="Stellate_2",0,Significant))

total_results <- total_results %>% 
  na.omit()

# # Create the faceted volcano plot matching your style
# volcano_plots <- ggplot(total_results, aes(x = logFC, y = p_value10, color = color)) +
#   geom_point(alpha = 0.7) +  # Plot points with transparency
#   scale_color_identity() +  # Use the color column directly
#   
#   # # Add labels for significant points
#   # geom_text(data = total_results[total_results$fdr < 0.05, ], 
#   #           aes(label = Gene),
#   #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
#     geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
#                   aes(label = Gene),
#                   size = 3, 
#                   color = "black", 
#                   fontface = "bold",
#                   box.padding = 0.3,        # Space around each label
#                   point.padding = 0.3,      # Space around each point
#                   segment.color = "gray50", # Color of connecting lines
#                   segment.size = 0.3,       # Thickness of connecting lines
#                   max.overlaps = 20,        # Maximum number of overlaps allowed
#                   min.segment.length = 0.1) + # Minimum segment length to draw
#   # 
#   # Facet by cell type
#   facet_wrap(~ Celltype, 
#              ncol = 4,  # Adjust as needed
#              scales = "free_y") +  # Free y-scale but fixed x-scale
#   
#   # Set x-axis limits matching your original
#   xlim(-3, 3) +
#   
#   # Labels and theme matching your style
#   labs(
#     title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
#     subtitle = "2000 HVGs, Unadjusted",
#     x = "Log Fold Change",
#     y = "-log10(P-Value)"
#     # caption = paste0("FDR < 0.05, Genes = ", Genes, ", Significant = ", Significant_Genes)
#   ) +
#   
#   theme_minimal() +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.x = element_text(angle = 0, hjust = 1),
#     strip.text = element_text(face = "bold", size = 10),
#     strip.background = element_rect(fill = "gray95", color = NA),
#     panel.border = element_rect(color = "gray80", fill = NA)
#   )
# Define your desired order
desired_order <- c("Hep_1", "Hep_2", "Hep_3", "Hep_4", "Hep_5", 
                   "dHep", "Hep_Immune", 
                   "EC_1", "EC_2", 
                   "Stellate_1", "Stellate_2",
                   "Cholang", 
                   "B_Plasma", "cFIB_cImmune", "Kup_MAC", "Kup_MON", "NKC_NKT")

# Convert Celltype to factor with custom order
total_results$Celltype <- factor(total_results$Celltype, levels = desired_order)

# Then your existing ggplot code
volcano_plots <- ggplot(total_results, aes(x = logFC, y = p_value10, color = color)) +
  geom_point(alpha = 0.7) +  
  scale_color_identity() +  
  
  geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
                  aes(label = Gene),
                  size = 3, 
                  color = "black", 
                  fontface = "bold",
                  box.padding = 0.3,       
                  point.padding = 0.3,     
                  segment.color = "gray50", 
                  segment.size = 0.3,      
                  max.overlaps = 20,       
                  min.segment.length = 0.1) + 
  
  # Facet by cell type (will now use the custom order)
  facet_wrap(~ Celltype, 
             ncol = 4,  
             scales = "free_y") +  
  
  xlim(-3, 3) +
  
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
    subtitle = "2000 HVGs, Unadjusted",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(volcano_plots)

png(fs::path(dir.results, "Supplemental Results","Volcano_Plots_NEBULA_All_Celltypes_HR_unadjusted_pooled_offset_Steatosis.png"),
    width = 5000, height = 4000, res = 300)
print(volcano_plots)
dev.off()

# Alternative: Create individual plots with custom captions for each cell type
library(patchwork)

# Function to create individual volcano plots matching your exact style
create_volcano_by_celltype <- function(data, celltype_name) {
  
  # Filter data for this cell type
  ct_data <- filter(data, Celltype == celltype_name)
  
  # Identify significant points
  significant_df <- ct_data[ct_data$fdr < 0.05, ]
  
  # Calculate stats for this cell type
  Genes <- length(unique(ct_data$Gene))
  Significant_Genes <- nrow(significant_df)
  
  # Create the plot
  p <- ggplot(ct_data, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +
    scale_color_identity() +
    theme_minimal() +
    labs(
      title = celltype_name,
      subtitle = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
      x = "Log Fold Change",
      y = "-log10(P-Value)",
      caption = paste0("FDR < 0.05, Genes = ", Genes, ", Significant = ", Significant_Genes)
    ) +
    theme(
      plot.title = element_text(hjust = 0, face = "bold"),
      plot.subtitle = element_text(hjust = 0, size = 9),
      axis.text.x = element_text(angle = 0, hjust = 1),
      plot.caption = element_text(size = 7, hjust = 0)
    ) +
    xlim(-2.5, 2.5) +
    geom_text(data = significant_df, aes(label = Gene),
              vjust = 1, hjust = 1, size = 2.5, check_overlap = TRUE, color = "black")
  
  return(p)
}

# Create individual plots for each cell type
volcano_list <- list()
for (ct in levels(total_results$Celltype)) {
  volcano_list[[ct]] <- create_volcano_by_celltype(total_results, ct)
}

# Combine plots using patchwork
combined_volcanoes <- wrap_plots(volcano_list, ncol = 3) + 
  plot_annotation(
    title = "Differential Gene Expression by Cell Type",
    subtitle = "High Steatosis (2+3) vs. Low Steatosis (0+1), 2000 HVGs",
    theme = theme(
      plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
      plot.subtitle = element_text(hjust = 0.5, size = 11)
    )
  )

print(combined_volcanoes)

# Version with ggrepel for better label placement (if you prefer)
library(ggrepel)

volcano_plots_repel <- ggplot(total_results, aes(x = logFC, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  
  # Add labels for significant points with ggrepel
  geom_text_repel(data = total_results[total_results$fdr < 0.05, ], 
                  aes(label = Gene),
                  size = 2.5, color = "black", 
                  box.padding = 0.3, 
                  point.padding = 0.2,
                  max.overlaps = 10,
                  segment.size = 0.3) +
  
  facet_wrap(~ Celltype, ncol = 3, scales = "free_y") +
  xlim(-2.5, 2.5) +
  
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1) by Cell Type",
    subtitle = "2000 HVGs, Unadjusted",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

# Create a summary plot showing number of DEGs per cell type
deg_summary <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Upregulated = sum(fdr < 0.05 & logFC > 0),
    Downregulated = sum(fdr < 0.05 & logFC < 0),
    .groups = 'drop'
  ) %>%
  pivot_longer(cols = c(Upregulated, Downregulated), 
               names_to = "Direction", 
               values_to = "Count")

summary_barplot <- ggplot(deg_summary, aes(x = Celltype, y = Count, fill = Direction)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("Upregulated" = "#990000", "Downregulated" = "#003366")) +
  theme_minimal() +
  labs(title = "Number of Differentially Expressed Genes by Cell Type",
       x = "Cell Type",
       y = "Number of DEGs (FDR < 0.05)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5, face = "bold"))

print(summary_barplot)
# }
```
### v. HR GSEA
```{r echo = F}
HR_celltypes <- unique(so_liver_sn$celltype)
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
HR_celltypes <- str_replace_all(HR_celltypes,"/","_")

for (cell_name in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  # full_results <- full_results %>% 
  #   clean_names() %>% 
  #   dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
  #   dplyr::rename(Gene=gene)
  # full_results <- full_results[,-1]
  # full_results$Celltype <- cell_name
  
  
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  full_results <- full_results %>%
    clean_names() %>% 
    dplyr::select(-x) %>% 
    dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- full_results$LogFC
  names(rankings_dHep) <- full_results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  # 
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(cell_name," Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(cell_name," Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,"Supplemental Results",paste0(cell_name,"_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
}
```
### iii. HR Targeted Genes
```{r}

#Filter to celltype 
HR_celltypes <- unique(so_liver_sn$celltype)

# cell_name <- "Hep"
for (cell_name in HR_celltypes){
  so_celltype <- subset(so_liver_sn,celltype==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  # #Filter to PT Cells
  # so_celltype <- subset(so_liver_sn,celltype=="dHep")
  # DefaultAssay(so_celltype) <- "RNA" 
  
  
  genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
  so_celltype_hvg <- subset(so_celltype, features =genes_list)
  DefaultAssay(so_celltype_hvg) <- "RNA"
  so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
  #Make sure to set reference level
  so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
  nrow(so_celltype_hvg) #28964 genes
  Nuclei <- ncol(so_celltype_hvg) #130124 nuclei
  
  counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  
  # With parallelization
  
  cl <- makeCluster(1)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
      pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results <- full_results %>%
    mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
  full_results$cell_name <- cell_name
  full_results$cell_name <- str_replace_all(full_results$cell_name,"-","_")
  full_results$cell_name <- str_replace_all(full_results$cell_name,"/","_")
  cell_name <- str_replace_all(cell_name,"-","_")
  cell_name <- str_replace_all(cell_name,"/","_")
  write.csv(full_results,fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv")))
}

total_results <- data.frame()
HR_celltypes <- unique(so_liver_sn$celltype)
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
HR_celltypes <- str_replace_all(HR_celltypes,"/","_")
for (cell_name in HR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("Targeted_Genes_NEBULA_",cell_name,"_Steatosis_unadjusted.csv"))) 
  full_results <- full_results %>% 
    clean_names() %>% 
    dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(se=se_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(pval=p_steatosis_cat_high_steatosis_2_3) %>% 
    dplyr::rename(Gene=gene)
  full_results <- full_results[,-1]
  full_results$Celltype <- cell_name
  total_results <- rbind(total_results,full_results)
}

# Calculate Confidence Intervals (95% CI) by cell type
total_results <- total_results %>%
  group_by(cell_name) %>%  # Group by cell type
  mutate(
    CI_Lower = logFC - 1.96 * se,
    CI_Upper = logFC + 1.96 * se,
    sig = ifelse(pval < 0.05, "*", "")
  ) %>%
  ungroup()  # Remove grouping

# Create the coefficient plot with facet wrap
dot_plot <- ggplot(total_results, aes(x = logFC, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), 
                 height = 0.2, color = "#f4a261") +
  geom_point(size = 3, color = "darkred") +
  # "#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"
  # Add facet wrap by cell type
  facet_wrap(~ cell_name, 
             scales = "free_y",  # Allow different genes per cell type
             ncol = 3) +  # Adjust number of columns as needed
  
  labs(title = "Targeted Gene Analysis: Steatosis (High vs. Low) by Cell Sub-Type",
       # subtitle = "Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", 
       y = "Gene") +
  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),  # Smaller text for faceted plot
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 9),  # Cell type labels
    strip.background = element_rect(fill = "gray95", color = NA),
    text = element_text(size = 10),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(dot_plot)

# Define your desired order for cell types
desired_order <- c("Hep_1", "Hep_2", "Hep_3", "Hep_4", "Hep_5","dHep", "Hep_Immune",
                   "Stellate_1", "Stellate_2", 
                   "EC_1", "EC_2",
                   "Cholang",
                   "B_Plasma", "cFIB_cImmune", "Kup_MAC", "Kup_MON", "NKC_NKT")

# Convert cell_name to factor with custom order
total_results$cell_name <- factor(total_results$cell_name, levels = desired_order)

# Create the coefficient plot with facet wrap
dot_plot <- ggplot(total_results, aes(x = logFC, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), 
                 height = 0.2, color = "#f4a261") +
  geom_point(size = 3, color = "darkred") +
  
  # Add facet wrap by cell type (now with custom order)
  facet_wrap(~ cell_name, 
             scales = "free_y",
             ncol = 3) +
  
  labs(title = "Targeted Gene Analysis: Steatosis (High vs. Low) by Cell Sub-Type",
       x = "LogFC", 
       y = "Gene") +
  
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 9),
    strip.background = element_rect(fill = "gray95", color = NA),
    text = element_text(size = 10),
    panel.border = element_rect(color = "gray80", fill = NA)
  )

print(dot_plot)

# Save the plot
png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_All_Cells_HR_Steatosis_unadjusted.png"),
    width = 4000, height = 3500, res = 300)  # Increased size for faceted plot
print(dot_plot)
dev.off()



# 
# 
# # Calculate Confidence Intervals (95% CI)
# full_results <- full_results %>%
#   mutate(
#     CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
#     CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
#   )
# full_results <- full_results %>% 
#   mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))
# 
# # Create the coefficient plot
# dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
#   geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
#   geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
#   # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
#   labs(title = "Steatosis (High vs. Low) in All Cell Types",
#        subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
#        x = "LogFC", y = "Gene",
#        caption=paste0("Nuclei = ",Nuclei) )+
#   geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
#   theme_minimal() +
#   theme(axis.text.y = element_text(size = 10),
#         axis.title.x = element_text(size = 10),
#         axis.title.y = element_text(size = 10),
#         text =element_text(size=10)) 
# dot_plot
# 
# png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
#     width = 2500, height = 2100, res = 300)
# print(dot_plot)
# dev.off()
```

##D. Clinical Variables & Gene Expression
###i. LR Nebula
```{r}
#Filter to celltype 
LR_celltypes <- unique(so_liver_sn$celltype_LR)[1]
# clinical_variables <- c("alt","ast","ggt","bmi","a1c","hepatocyte_ballooning_score","lobular_inflammation_grade","steatosis_grade","fibrosis_stage","steatosis_grade")
clinical_variables <- c("tg")
#Filter to celltype 
# LR_celltypes <- unique(so_liver_sn$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
# clinical_variables <- c("alt","ast","ggt","bmi","a1c")
# clinical_variables <- c("hepatocyte_ballooning_score","lobular_inflammation_grade",
#                         "steatosis_grade","fibrosis_stage")
# cell_name <- "Hep-1"
# unique(so_liver_sn$hepatocyte_ballooning_percent)
# unique(so_liver_sn$lobular_inflammation_grade)

# {
# for (cell_name in LR_celltypes) {
cell_name <- LR_celltypes

so_celltype <- subset(so_liver_sn,celltype_LR==cell_name)
DefaultAssay(so_celltype) <- "RNA" 

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
# so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
# so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# for (var in clinical_variables[10]) {
var <- clinical_variables
so_celltype[[var]] <- as.numeric(unlist(so_celltype[[var]][1]))

# With parallelization
cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    # pred_gene <- model.matrix(~var, data = meta_gene)
    pred.formula <- as.formula(paste0("~",var))
    pred_gene <- model.matrix(pred.formula, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)

full_results <- as.data.frame(nebula_summaries)
# total_results <- full_results

nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
) 

#Calculate number of genes filtered out for low expression 
full_results$low_exp <- length(genes_list)-length(full_results$gene)

#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)

#Calculate nonconvergence rate
full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")

# full_results <- full_results %>%
#   mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
# full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))

cell_name2 <- str_replace(cell_name,"/","_")
cell_name2 <- str_replace(cell_name2,"-","_")
full_results$variable <- var
full_results$celltype <- cell_name2
#Save Results
write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",cell_name2,"_",var,"_unadjusted_2000_pooled_offset.csv"))

# }
# }

#Heat Map visualization of results
total_results <- data.frame()
LR_celltypes <- unique(so_liver_sn$celltype_LR)[1]
for (cell_name in LR_celltypes) {
  for (var in clinical_variables) {
    full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",cell_name,"_",var,"_unadjusted_2000_pooled_offset.csv"))
    full_results <- full_results %>% 
      clean_names() %>% 
      # dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name
    full_results$variable <- var
    full_results$log_fc <- full_results[,2]
    full_results <- full_results %>% 
      dplyr::select(log_fc, fdr, p_value10,Celltype,variable,Gene)
    total_results <- rbind(total_results,full_results)
  }
}

total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$log_fc > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$log_fc < 0, "#003366", "lightgray"))

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))

# Select only the needed columns and rename log_fc for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Celltype, log_fc, signif)

custom_order <- LR_celltypes
heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
# custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
#                    "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Celltype, y = Gene, fill = log_fc)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "LogFC"
  ) +
  theme_minimal() +
  labs(title = "2000 HVGs by Clinical Variables",
       x = "Exposure",
       y = "Gene") +
  # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  )

# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

# png(fs::path(dir.results, "Heatmap__NEBULA_Other_Celltypess_unadjusted_pooled_offset_Steatosis.png"), 
#     width = 1500, height = 2000, res = 300)
print(heat_map_p)
# dev.off()

# Prepare data for volcano plots - keeping your exact color scheme and logic
total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$log_fc > 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$log_fc < 0, "#003366", "lightgray"))

# Add -log10(p-value) column if not already present
# Assuming you have a p-value column, adjust the name as needed
if("pvalue" %in% names(total_results)) {
  total_results$PValue10 <- -log10(total_results$pvalue)
} else if("p.value" %in% names(total_results)) {
  total_results$PValue10 <- -log10(total_results$p.value)
} else {
  # If only FDR is available, use it as approximation
  total_results$PValue10 <- -log10(total_results$fdr)
}

# Set factor levels for cell type ordering
total_results$Celltype <- factor(total_results$Celltype, levels = LR_celltypes)

# Calculate statistics for caption (will be done per cell type)
summary_stats <- total_results %>%
  group_by(Celltype) %>%
  summarise(
    Genes = n_distinct(Gene),
    Significant = sum(fdr < 0.05),
    .groups = 'drop'
  )

# Create the faceted volcano plot matching your style
volcano_plots <- ggplot(total_results, aes(x = log_fc, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  
  # Add labels for significant points
  geom_text(data = total_results[total_results$fdr < 0.05, ],
            aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  
  # Facet by cell type
  facet_wrap(~ Celltype,
             ncol = 2,  # Adjust as needed
             scales = "free_y") +  # Free y-scale but fixed x-scale
  
  # Set x-axis limits matching your original
  xlim(-2.5, 2.5) +
  
  # Labels and theme matching your style
  labs(
    title = paste0("Gene Expression vs. ",var),
    subtitle = "2000 HVGs, Unadjusted",
    x = "Log Fold Change",
    y = "-log10(P-Value)"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "gray95", color = NA),
    panel.border = element_rect(color = "gray80", fill = NA)
  )+facet_wrap(~variable)

# Display the plot
print(volcano_plots)
png("/home/hhampson/Results/Volcano_Plots_NEBULA_Other_Celltypess_LR_unadjusted_pooled_offset_Clinical_vars.png",
    width = 6000, height = 4000, res = 300)
print(volcano_plots)
dev.off()
# 
# # var <- "bmi"
# for (var in clinical_variables){
#   results <- total_results %>% 
#     filter(variable == var)
#   Genes <- length(unique(results$Gene))
#   results$p_value10 <- round(as.numeric(results$p_value10),3)
#   results$fdr <- as.numeric(results$fdr)
#   significant_df <- results[results$fdr < 0.05, ]
#   
#   celltype_limits <- results %>%
#     group_by(Celltype) %>%
#     summarise(
#       min = min(log_fc, na.rm = TRUE),
#       max = max(log_fc, na.rm = TRUE)
#     )
#   
#   # Join back to results
#   results <- results %>%
#     left_join(celltype_limits, by = "Celltype")
#   
#   results <- results %>% 
#     na.omit()
#   
#   # # Create the faceted volcano plot matching your style
#   # volcano_plot <- ggplot(results, aes(x = log_fc, y = p_value10, color = color)) +
#   #   geom_point(alpha = 0.7) +  # Plot points with transparency
#   #   scale_color_identity() +  # Use the color column directly
#   #   theme_bw() +  # Minimal theme
#   #   # Facet by cell type
#   #   facet_wrap(~ Celltype,
#   #              ncol = 5,  # Adjust as needed
#   #              scales = "free_y") +  # Free y-scale but fixed x-scale
#   #   theme(
#   #     plot.title = element_text(hjust = 0),
#   #     axis.text.x = element_text(angle = 0, hjust = 1)
#   #   )+
#   #   labs(title=paste0("Gene Expression vs. ",var))+
#   #   xlim(-1,1)+
#   #   # # Add labels for significant points
#   #   geom_text(data = significant_df, aes(label =Gene),
#   #             vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
#   volcano_plot <- ggplot(results, aes(x = log_fc, y = p_value10, color = color)) +
#     geom_point(alpha = 0.7) +
#     scale_color_identity() +
#     theme_bw() +
#     facet_wrap(~ Celltype, ncol = 5, scales = "free_y") +
#     theme(
#       plot.title = element_text(hjust = 0),
#       axis.text.x = element_text(angle = 0, hjust = 1)
#     ) +
#     labs(title = paste0("Gene Expression vs. ", var)) +
#     xlim(-1, 1) +
#     # Use geom_text_repel instead
#     geom_text_repel(
#       data = significant_df, 
#       aes(label = Gene),
#       size = 3, 
#       color = "black", 
#       box.padding = 0.5,
#       point.padding = 0.3,
#       segment.color = "grey50",
#       max.overlaps = 20,
#       force = 2,
#       nudge_y = 0.5  # Nudge labels up slightly
#     )
#   # Add labels for significant points with ggrepel
#   # geom_text_repel(data = significant_df, aes(label = Gene),
#   #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
#   
#   # volcano_plot
#   
#   # Display the plot
#   # print(volcano_plot)
#   png(paste0("/home/hhampson/ResultsVolcano_Plots_NEBULA_",var,"_All_Celltypes_LR_unadjusted_pooled_offset.png"),
#       width = 4000, height = 1500, res = 300)
#   print(volcano_plot)
#   dev.off()
# }
##GSEA
for (var in clinical_variables){
  results <- total_results %>% 
    filter(variable == var)
  # for (celltype in LR_celltypes) {
  # results <- results 
  #   filter(Celltype %in% celltype)
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- results$log_fc
  names(rankings_dHep) <- results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(var," in ",celltype,"Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(var," in ",celltype,"Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,paste0(celltype,"_",var,"top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
}
# }
```
### ii. LR GSEA
```{r echo = F}
LR_celltypes <- unique(so_liver_sn$celltype_LR)
for (cell_name in LR_celltypes) {
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name,"_Steatosis_unadjusted_2000_pooled_offset.csv"))) 
  # full_results <- full_results %>% 
  #   clean_names() %>% 
  #   dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
  #   dplyr::rename(Gene=gene)
  # full_results <- full_results[,-1]
  # full_results$Celltype <- cell_name
  
  
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  full_results <- full_results %>%
    clean_names() %>% 
    dplyr::select(-x) %>% 
    dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- full_results$LogFC
  names(rankings_dHep) <- full_results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  # 
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(cell_name," Top 30 REACTOME Pathways"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(cell_name,"  Top 30 GO Pathways"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 2)
  print(combined_plot)
  ggsave(fs::path(dir.results,"Supplemental Results",paste0(cell_name,"_top30_pathways_unadjusted.jpeg")),
         width = 25, height = 10, scale = 1)
}
```
###ii. HR Nebula
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_liver_sn$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
# clinical_variables <- c("alt","ast","ggt","bmi","a1c")
clinical_variables <- c("hepatocyte_ballooning_score","lobular_inflammation_grade",
                        "steatosis_grade","fibrosis_stage")
# cell_name <- "Hep-1"
# unique(so_liver_sn$hepatocyte_ballooning_percent)
# unique(so_liver_sn$lobular_inflammation_grade)

# {
for (cell_name in HR_celltypes) {
  
  so_celltype <- subset(so_liver_sn,celltype==cell_name)
  DefaultAssay(so_celltype) <- "RNA" 
  
  ## Select Highly Variable Genes (HVGs)
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  
  #Make sure exposure/independent/x variable or group variable is a factor variable
  # so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
  # so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)
  
  #Make sure to set reference level
  # so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
  # so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")
  
  #Round counts layer for nb
  # counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round
  
  # List of genes
  genes_list <- rownames(counts_hvg)
  
  for (var in clinical_variables){
    so_celltype[[var]] <- as.numeric(unlist(so_celltype[[var]][1]))
    
    # With parallelization
    cl <- makeCluster(20)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_hvg[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        # pred_gene <- model.matrix(~var, data = meta_gene)
        pred.formula <- as.formula(paste0("~",var))
        pred_gene <- model.matrix(pred.formula, data = meta_gene)
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    
    full_results <- as.data.frame(nebula_summaries)
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40|hep_nebula_converged$Convergence_Code==-50|hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    
    # full_results <- full_results %>%
    #   mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    # full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    
    cell_name2 <- str_replace(cell_name,"/","_")
    cell_name2 <- str_replace(cell_name2,"-","_")
    full_results$variable <- var
    full_results$celltype <- cell_name2
    #Save Results
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",cell_name2,"_",var,"_unadjusted_2000_pooled_offset.csv")))
    
  }
}

#Heat Map visualization of results
total_results <- data.frame()
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
# HR_celltypes <- str_replace_all(HR_celltypes,"EC-1","EC_1")
# HR_celltypes <- str_replace_all(HR_celltypes,"Stellate-1","Stellate_1")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "EC_2"
for (cell_name2 in HR_celltypes) {
  for(var in clinical_variables) {
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",cell_name2,"_",var,"_unadjusted_2000_pooled_offset.csv")))
    full_results <- full_results %>% 
      clean_names() %>% 
      # dplyr::rename(logFC=log_fc_steatosis_cat_high_steatosis_2_3) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    full_results$variable <- var
    full_results$log_fc <- full_results[,2]
    full_results <- full_results %>% 
      dplyr::select(log_fc, fdr, p_value10,Celltype,variable,Gene)
    total_results <- rbind(total_results,full_results)
  }
}
# total_results <- total_results %>% 
#   mutate(fdr=ifelse(is.na(fdr),"",fdr)) %>% 
#   mutate(p_value10=ifelse(is.na(p_value10),"",p_value10))
total_results$Celltype <- factor(total_results$Celltype)
total_results$variable <- factor(total_results$variable)
total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$log_fc >= 0, "#990000",
                              ifelse(total_results$fdr < 0.05 & total_results$log_fc < 0, "#003366", "lightgray"))
total_results$color <- ifelse(total_results$fdr=="","lightgray",total_results$color)

# Define significance stars
total_results <- total_results %>%
  mutate(signif = case_when(
    fdr < 0.01 ~ "**",
    fdr < 0.05 ~ "*",
    TRUE ~ ""
  ))
# total_results$signif <- ifelse(total_results$fdr=="","",total_results$signif)
# Select only the needed columns and rename log_fc for clarity
heatmap_data <- total_results %>%
  dplyr::select(Gene, Celltype, log_fc, signif,variable)

custom_order <- unique(heatmap_data$Celltype)
heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
# custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
#                    "Average Cortical K2/F","Average Medulla K2/F")

heat_map_p <- ggplot(heatmap_data, aes(x = Celltype, y = Gene, fill = log_fc)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = signif), size = 3, color = "black") +
  facet_wrap(~variable)+
  scale_fill_gradient2(
    low = "#264653", mid = "white", high = "darkred",
    midpoint = 0,
    name = "log_fc"
  ) +
  theme_minimal() +
  labs(title = "2000 HVGs by Steatosis Grade",
       x = "Celltype",
       y = "Gene") +
  # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
  theme(
    text = element_text(face="bold"),
    axis.text.y = element_text(size = 6),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank()
  ) 
print(heat_map_p)
# custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Heatmap_NEBULA_All_Celltypes_HR_unadjusted_pooled_offset_clinical_vars2.png"),
    width = 4000, height = 4000, res = 300)
print(heat_map_p)
dev.off()

# var <- "bmi"
for (var in clinical_variables){
  results <- total_results %>% 
    filter(variable == var)
  Genes <- length(unique(results$Gene))
  results$p_value10 <- round(as.numeric(results$p_value10),3)
  results$fdr <- as.numeric(results$fdr)
  significant_df <- results[results$fdr < 0.05, ]
  
  celltype_limits <- results %>%
    group_by(Celltype) %>%
    summarise(
      min = min(log_fc, na.rm = TRUE),
      max = max(log_fc, na.rm = TRUE)
    )
  
  # Join back to results
  results <- results %>%
    left_join(celltype_limits, by = "Celltype")
  
  results <- results %>% 
    na.omit()
  
  # Create the faceted volcano plot matching your style
  volcano_plot <- ggplot(results, aes(x = log_fc, y = p_value10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_bw() +  # Minimal theme
    # Facet by cell type
    facet_wrap(~ Celltype,
               ncol = 5,  # Adjust as needed
               scales = "free_y") +  # Free y-scale but fixed x-scale
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    labs(title=paste0("Gene Expression vs. ",var))+
    xlim(-1,1)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label =Gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  
  # Display the plot
  print(volcano_plot)
  png(fs::path(dir.results, paste0("Volcano_Plots_NEBULA_",var,"_All_Celltypes_HR_unadjusted_pooled_offset.png")),
      width = 5000, height = 3000, res = 300)
  print(volcano_plot)
  dev.off()
}

##GSEA
for (var in clinical_variables){
  results <- total_results %>% 
    filter(variable == var)
  for (celltype in HR_celltypes) {
    cell_results <- results %>% 
      filter(Celltype %in% celltype)
    # Filter out the gmt files for KEGG, Reactome and GOBP
    list.files(bg_path)
    gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
    gmt_files
    kegg_legacy <- prepare_gmt(gmt_files[1], unique(cell_results$Gene), savefile = FALSE)
    reactome <- prepare_gmt(gmt_files[3], unique(cell_results$Gene), savefile = FALSE)
    go <- prepare_gmt(gmt_files[4], unique(cell_results$Gene), savefile = FALSE)
    
    # rank genes by t-stats in DiD
    rankings_dHep <- cell_results$log_fc
    names(rankings_dHep) <- cell_results$Gene
    rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
    plot(rankings_dHep)
    min(rankings_dHep)
    max(rankings_dHep)
    
    
    set.seed(1234)
    
    kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                  stats = rankings_dHep,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
    
    reactome_res_dHep <- fgsea(pathways = reactome,
                               stats = rankings_dHep,
                               scoreType = 'std', 
                               minSize = 3,
                               maxSize = 500,
                               nproc = 1)
    # saveRDS(reactome_res_dHep,fs::path(dir.results,"dHep_Steatosis_reactome.rds"))
    go_res_dHep <- fgsea(pathways = go,
                         stats = rankings_dHep,
                         scoreType = 'std', 
                         minSize = 5,
                         maxSize = 500,
                         nproc = 1)
    # saveRDS(go_res_dHep,fs::path(dir.results,"dHep_Steatosis_GO.rds"))
    dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                             "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                             "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
    rownames(dHep_fgsea) <- c("adj.pval", "p.val")
    
    ##### KEGG Legacy
    # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
    
    # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
    #        width = 13, height = 10, scale = 1)
    
    ##### REACTOME
    b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(var," in ",celltype,"Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
    
    # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
    #        width = 13, height = 10, scale = 1)
    ##### GO
    c <- plot_fgsea_transpose(go_res_dHep, title = paste0(var," in ",celltype,"Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
    
    # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
    #        width = 13, height = 10, scale = 1)
    
    combined_plot <- b + c + plot_layout(ncol = 1)
    print(combined_plot)
    ggsave(fs::path(dir.results,paste0(celltype,"_",var,"top30_pathways_unadjusted.jpeg")),
           width = 15, height = 20, scale = 1)
  }
}
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "dHep, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()
```



# 4. Oroboros Analysis 
## Load Gene Sets
```{r}
# #Local
# tca1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/tca_cycle_genes.csv")$genesymbol
gc()
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "Liver transcriptomics/tca_cycle_genes.csv", temp_file)
tca1 <-  read.csv(temp_file)
gc()
tca1 <- tca1$genesymbol
tca2 <- c(
  "ACO1", "ACO2", "IDH1", "IDH2", "IDH3A", "IDH3B", "IDH3G", "OGDH", "OGDHL",
  "SUCLA2", "SUCLG1", "SUCLG2", "SDHA", "SDHB", "SDHC", "SDHD", "FH", "MDH1",
  "MDH2", "FAS", "CS"
) #21 genes

tca <- unique(c(tca1,tca2))


#Lambda
gc()
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "Liver transcriptomics/ox_phos_genes.csv", temp_file)
ox_phos1 <-  read.csv(temp_file)
gc()
ox_phos1 <- ox_phos1$genesymbol
#Local
# ox_phos1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/ox_phos_genes.csv")$genesymbol
ox_phos2 <- c(
  "NDUFS6",  "SDHB", "SDHC", "SDHD",
  "UQCRC1", "UQCRC2", "COX4I1", "COX4I2", "ATP5PF") #47 genes
ox_phos <- unique(c(ox_phos1,ox_phos2))

```

##a. HR Celltypes
###A. All Celltypes
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_oro$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_oro@meta.data
# oro_vars <- colnames(meta)[85:114]
oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
              "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
# cell_name <- "Hep/Immune"
for (cell_name in HR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_oro,celltype==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_tca <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- tca
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_tca[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_tca))-length(unique(full_results$gene)))/length(rownames(counts_tca))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_tca.csv")))
  }
}


#Heat Map visualization of results]
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

for (cell_name2 in HR_celltypes){
  total_results <- data.frame()
  for (oro in oro_vars) {
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_tca.csv"))) 
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "TCA Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_TCA.png")),
      width = 2000, height = 3000, res = 300)
  print(heat_map_p)
  dev.off()
}

##Ox Phos
#Filter to celltype 
HR_celltypes <- unique(so_oro$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_oro@meta.data
# oro_vars <- colnames(meta)[85:114]
oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
              "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
cell_name <- "cFIB/cImmune"
for (cell_name in HR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_oro,celltype==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_ox_phos <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- ox_phos
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_ox_phos[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_ox_phos))-length(unique(full_results$gene)))/length(rownames(counts_ox_phos))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_ox_phos.csv")))
  }
}


#Heat Map visualization of results]
# total_results <- data.frame()
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

# HR_celltypes <- unique(so_oro$celltype)[-17]
for (cell_name2 in HR_celltypes[-17]){
  total_results <- data.frame()
  for (oro in oro_vars) {
    # cell_name2 <- str_replace_all(cell_name,"/","_")
    # cell_name2 <- str_replace_all(cell_name2,"-","_")
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_ox_phos.csv")))
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "ox_phos Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_ox_phos.png")),
      width = 2000, height = 3000, res = 300)
  print(heat_map_p)
  dev.off()
}


```
###B. MT Genes
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_oro$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_oro@meta.data
# oro_vars <- colnames(meta)[85:114]
oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
              "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
# cell_name <- "Hep/Immune"
for (cell_name in HR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_oro,celltype==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_tca <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- mito_genes
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_tca[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_tca))-length(unique(full_results$gene)))/length(rownames(counts_tca))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_MT_genes.csv")))
  }
}


#Heat Map visualization of results]
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

for (cell_name2 in HR_celltypes){
  total_results <- data.frame()
  for (oro in oro_vars) {
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_MT_genes.csv"))) 
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "MT Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_MT_genes.png")),
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
}


```
##b. LR Celltypes
###A. All Celltypes
```{r}
#Filter to celltype 
LR_celltypes <- unique(so_liver_sn$celltype_LR)[1]
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_liver_sn@meta.data
# # oro_vars <- colnames(meta)[85:114]
oro_vars <- colnames(meta)[c(85,86,89,90,91,93,94,99,100,101,104,105,106,108,110,114)]
# oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
#               "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
# cell_name <- "Hep/Immune"
for (cell_name in LR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_liver_sn,celltype_LR==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_tca <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- tca
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_tca[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_tca))-length(unique(full_results$gene)))/length(rownames(counts_tca))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    # write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_TCA_Genes.csv")))
    write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_",cell_name2,"_unadjusted_TCA_Genes.csv"))
  }
}

#Ox Phos
#Filter to celltype 
LR_celltypes <- unique(so_liver_sn$celltype_LR)[1]
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_liver_sn@meta.data
# # oro_vars <- colnames(meta)[85:114]
oro_vars <- colnames(meta)[c(85,86,89,90,91,93,94,99,100,101,104,105,106,108,110,114)]
# oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
#               "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
# cell_name <- "Hep/Immune"
for (cell_name in LR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_liver_sn,celltype_LR==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_ox_phos <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- ox_phos
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_ox_phos[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_tca))-length(unique(full_results$gene)))/length(rownames(counts_tca))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    # write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_TCA_Genes.csv")))
    write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_",cell_name2,"_unadjusted_Ox_Phos_Genes.csv"))
  }
}
```


```{r}
#Heat Map visualization of results]
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

for (cell_name2 in HR_celltypes){
  total_results <- data.frame()
  for (oro in oro_vars) {
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_tca.csv"))) 
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "TCA Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_TCA.png")),
      width = 2000, height = 3000, res = 300)
  print(heat_map_p)
  dev.off()
}

##Ox Phos
#Filter to celltype 
HR_celltypes <- unique(so_oro$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_oro@meta.data
# oro_vars <- colnames(meta)[85:114]
oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
              "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
cell_name <- "cFIB/cImmune"
for (cell_name in HR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_oro,celltype==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_ox_phos <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- ox_phos
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_ox_phos[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_ox_phos))-length(unique(full_results$gene)))/length(rownames(counts_ox_phos))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_ox_phos.csv")))
  }
}


#Heat Map visualization of results]
# total_results <- data.frame()
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

# HR_celltypes <- unique(so_oro$celltype)[-17]
for (cell_name2 in HR_celltypes[-17]){
  total_results <- data.frame()
  for (oro in oro_vars) {
    # cell_name2 <- str_replace_all(cell_name,"/","_")
    # cell_name2 <- str_replace_all(cell_name2,"-","_")
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_ox_phos.csv")))
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "ox_phos Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_ox_phos.png")),
      width = 2000, height = 3000, res = 300)
  print(heat_map_p)
  dev.off()
}


```
###B. MT Genes
```{r}
#Filter to celltype 
HR_celltypes <- unique(so_oro$celltype)
#  [1] Hep-2        Hep-5        Hep-4        EC-2         Stellate-2   Hep-3        Cholang     
#  [8] Hep-1        NKC/NKT      Kup/MON      dHep         Kup/MAC      EC-1         Stellate-1  
# [15] B/Plasma     Hep/Immune   cFIB/cImmune
meta <- so_oro@meta.data
# oro_vars <- colnames(meta)[85:114]
oro_vars <- c("carb_cytoc","carb_s","carb_omy","carbfccp",
              "lipid_g","lipid_s","lipid_omy","lipidfccp","lipidrcr_pcm")
# cell_name <- "Hep/Immune"
for (cell_name in HR_celltypes){
  # oro <- "carbp_m"
  for (oro in oro_vars) {
    so_celltype <- subset(so_oro,celltype==cell_name)
    DefaultAssay(so_celltype) <- "RNA" 
    StartGenes <- nrow(so_celltype) #28964 genes
    Nuclei <- ncol(so_celltype) #130124 nuclei
    
    cells_to_keep <- !is.na(so_celltype@meta.data[[oro]])
    so_celltype <- subset(so_celltype, cells = colnames(so_celltype)[cells_to_keep])
    
    # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
    # hvgs <- VariableFeatures(so_celltype)
    counts_tca <- round(GetAssayData(so_celltype, layer = "counts"))
    genes_list <- mito_genes
    cl <- makeCluster(10)
    registerDoParallel(cl)
    
    start_time <- Sys.time()
    
    nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
      tryCatch({
        count_gene <- counts_tca[g, , drop = FALSE]
        meta_gene <- subset(so_celltype,features=g)@meta.data
        formula <- as.formula(paste("~", oro))
        pred_gene <- model.matrix(formula, data = meta_gene)
        # pred_gene <- model.matrix(~oro, data = meta_gene)
        # library <- meta_gene$pooled_offset
        library <- meta_gene$pooled_offset
        data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
        
        if (is.null(data_g_gene)) {
          data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
        }
        
        #With offset
        result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
        
        list(gene = g, result = result)  # return both gene name and result
        
      }, error = function(e) {
        NULL
      })
    }
    
    stopCluster(cl)
    end_time <- Sys.time()
    print(end_time - start_time)
    
    # set the names of results based on gene names
    nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
    names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
    nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
    
    hep_nebula_converged <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        converged <- nebula_results_list[[gene_name]]$convergence
        df <- data.frame(Gene = gene_name,
                         Convergence_Code = converged)
        return(df)
      }
    )
    
    nebula_summaries <- map_dfr(
      names(nebula_results_list),
      function(gene_name) {
        df <- nebula_results_list[[gene_name]]$summary
        df <- df %>% mutate(Gene = gene_name)
        return(df)
      }
    )
    nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
    ) 
    
    full_results <- as.data.frame(nebula_summaries)
    colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
    full_results$Variable <- oro
    full_results$Celltype <- cell_name
    
    #Calculate number of genes filtered out for low expression 
    full_results$low_exp <- length(genes_list)-length(full_results$gene)
    #Filter out non-converging genes
    full_results <- full_results %>% 
      filter(!gene %in%  nonconverge_genes)
    #Calculate nonconvergence rate
    full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
    full_results$Nuceli <- Nuclei
    full_results$Genes <- length(full_results$Gene)
    # nebula_nonconverged_percent <- (length(rownames(counts_tca))-length(unique(full_results$gene)))/length(rownames(counts_tca))
    # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
    full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
    # mutate(fdr3=p.adjust(PValue3,method="fdr"))
    full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
    # results_total <- rbind(results_total,full_results)
    cell_name2 <- str_replace_all(cell_name,"/","_")
    cell_name2 <- str_replace_all(cell_name2,"-","_")
    write.csv(full_results,fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_MT_genes.csv")))
  }
}


#Heat Map visualization of results]
HR_celltypes <- str_replace_all(unique(so_liver_sn$celltype),"/","_")
HR_celltypes <- str_replace_all(HR_celltypes,"-","_")
# cell_name2 <- "B_Plasma"
# cell_name2

for (cell_name2 in HR_celltypes){
  total_results <- data.frame()
  for (oro in oro_vars) {
    full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_",oro,"_",cell_name2,"_unadjusted_2000_MT_genes.csv"))) 
    full_results <- full_results %>% 
      clean_names() %>% 
      dplyr::rename(logFC=log_fc) %>% 
      dplyr::rename(Gene=gene)
    full_results <- full_results[,-1]
    full_results$Celltype <- cell_name2
    total_results <- rbind(total_results,full_results)
  }
  
  total_results$color <- ifelse(total_results$fdr < 0.05 & total_results$logFC > 0, "#990000",
                                ifelse(total_results$fdr < 0.05 & total_results$logFC < 0, "#003366", "lightgray"))
  
  # Define significance stars
  total_results <- total_results %>%
    mutate(signif = case_when(
      fdr < 0.01 ~ "**",
      fdr < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Select only the needed columns and rename LogFC for clarity
  heatmap_data <- total_results %>%
    dplyr::select(Gene, variable, logFC, signif)
  
  # custom_order <- c("Hep_1","Hep_2","Hep_3","Hep_4","Hep_5","dHep","Hep_Immune",
  #                   "cFIB_cImmune","NKC_NKT","Kup_MON","Kup_MAC","B_Plasma",
  #                   "Stellate_1","Stellate_2",
  #                   "Cholang","EC_1","EC_2")
  # heatmap_data$Celltype <- factor(heatmap_data$Celltype, levels = custom_order)
  # custom_labels <- c("Average Cortical K2","Average Medulla K2","Average Cortical F","Average Medulla F",
  #                    "Average Cortical K2/F","Average Medulla K2/F")
  
  heat_map_p <- ggplot(heatmap_data, aes(x = variable, y = Gene, fill = logFC)) +
    geom_tile(color = "grey90") +
    geom_text(aes(label = signif), size = 3, color = "black") +
    scale_fill_gradient2(
      low = "#264653", mid = "white", high = "darkred",
      midpoint = 0,
      name = "LogFC"
    ) +
    theme_minimal() +
    labs(title = "MT Genes vs. Mitochondrial Function",
         subtitle = cell_name2,
         x = "Mitochondrial Function",
         y = "Gene") +
    # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
    theme(
      text = element_text(face="bold"),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.ticks.y = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank()
    )
  print(heat_map_p)
  # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
  
  png(fs::path(dir.results, paste0("Heatmap_NEBULA_",cell_name2,"_mitochondrial_fxn_MT_genes.png")),
      width = 2000, height = 1000, res = 300)
  print(heat_map_p)
  dev.off()
}


```

##II. Analyze
## a. HEP Cells 
###i. TCA
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 

#Filter out the Biobank participants with missing oroboros data
biobank_ids <- c("BSA_026","BSA_034")
so_Hep <- subset(so_Hep,!StudyID %in% biobank_ids)
unique(so_Hep$StudyID) #"MANGO-06" "MANGO-18" "MANGO-05" "MANGO-07" "IT2D-19"  "IT2D-14"  "IT2D-15"  "MANGO-04"
table(so_Hep$steatosis_cat,so_Hep$carbp_m)

nrow(so_Hep) #28964 genes before, now 11224 genes
ncol(so_Hep) #130124 nuclei before, now 81388 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]

# for (cell_name in HR_celltypes){
# oro <- "carbp_m"
for (oro in oro_vars) {
  # Clear any existing objects from previous iterations
  if (exists("nebula_results_list")) rm(nebula_results_list)
  if (exists("hep_nebula_converged")) rm(hep_nebula_converged)
  if (exists("nebula_summaries")) rm(nebula_summaries)
  if (exists("full_results")) rm(full_results)
  if (exists("cl")) {
    try(stopCluster(cl), silent = TRUE)
    rm(cl)
  }
  
  # Force garbage collection
  gc()
  
  print(paste("Processing:", oro))
  
  
  so_TCA <- subset(so_Hep, features = tca)
  DefaultAssay(so_TCA) <- "RNA"
  StartGenes <- nrow(so_TCA) #28964 genes, now 28 TCA genes only
  Nuclei <- ncol(so_TCA) #130124 nuclei, now 81388 nuclei
  # counts_tca <- round(GetAssayData(so_TCA, layer = "counts"))
  genes_list <- tca
  cells_to_keep <- colnames(so_TCA)[!is.na(so_TCA@meta.data[[oro]])]
  so_subset <- subset(so_TCA, cells = cells_to_keep)
  DefaultAssay(so_subset) <- "RNA"
  counts_tca <- round(GetAssayData(so_subset, layer = "counts"))
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_tca[g, , drop = FALSE]
      meta_gene <- subset(so_subset,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  full_results$Celltype <- "Hepatocytes"
  
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  full_results$Nuceli <- Nuclei
  full_results$Genes <- length(full_results$Gene)
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
}
# # }
# # "carbp_m"             "carb_adp"            "carb_g"              "carb_cytoc"          "carb_s"              "carb_omy"
# #  [7] "carbfccp"            "carbrcr_pm"          "carbrcr_pmgs"        "carbpe_pmgs"         "carb_ep"             "carbrcr_state2"
# # [13] "carbrcr_state4_c1"   "carbrcr_state4_c12"  "carb_le"             "lipidpc_m"           "lipid_adp"           "lipid_cytoc"
# # [19] "lipid_g"             "lipid_s"             "lipid_omy"           "lipidfccp"           "lipidrcr_pcm"        "lipidrcr_pcmgs"
# # [25] "lipidpe_pcmgs"       "lipid_ep"            "lipidrcr_state2"     "lipidrcr_state4_c1"  "lipidrcr_state4_c12" "lipid_le"
# 
# ## Select Highly Variable Genes (HVGs)
# # results_total <- data.frame()
# # # for (oro in oro_vars) {
# # so_Hep$steatosis_cat <- factor(so_Hep$steatosis_cat)
# # so_Hep$steatosis_cat <- relevel(so_Hep$steatosis_cat,ref = "Low Steatosis (0+1)")
# # 
# # oro <- "carbp_m"
# # cells_to_keep <- !is.na(so_Hep@meta.data[[oro]])
# # so_celltype <- subset(so_Hep, cells = colnames(so_Hep)[cells_to_keep])
# # 
# # # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# # # hvgs <- VariableFeatures(so_celltype)
# # counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ])
# # genes_list <- hvgs
# # 
# # cl <- makeCluster(10)
# # registerDoParallel(cl)
# # 
# # start_time <- Sys.time()
# # 
# # nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
# #   tryCatch({
# #     count_gene <- counts_hvg[g, , drop = FALSE]
# #     meta_gene <- subset(so_celltype,features=g)@meta.data
# #     formula <- as.formula(paste("~", oro,"+ast"))
# #     pred_gene <- model.matrix(formula, data = meta_gene)
# #     # pred_gene <- model.matrix(~oro, data = meta_gene)
# #     # library <- meta_gene$pooled_offset
# #     library <- meta_gene$pooled_offset
# #     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
# #     
# #     if (is.null(data_g_gene)) {
# #       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
# #     }
# #     
# #     #With offset
# #     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
# #     
# #     list(gene = g, result = result)  # return both gene name and result
# #     
# #   }, error = function(e) {
# #     NULL
# #   })
# # }
# # 
# # stopCluster(cl)
# # end_time <- Sys.time()
# # print(end_time - start_time)
# 
# # set the names of results based on gene names
# nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
# names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
# nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
# 
# hep_nebula_converged <- map_dfr(
#   names(nebula_results_list),
#   function(gene_name) {
#     converged <- nebula_results_list[[gene_name]]$convergence
#     df <- data.frame(Gene = gene_name,
#                      Convergence_Code = converged)
#     return(df)
#   }
# )
# 
# nebula_summaries <- map_dfr(
#   names(nebula_results_list),
#   function(gene_name) {
#     df <- nebula_results_list[[gene_name]]$summary
#     df <- df %>% mutate(Gene = gene_name)
#     return(df)
#   }
# )
# nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
# ) 
# 
# full_results <- as.data.frame(nebula_summaries)
# colnames(full_results) <- c("logFC_Intercept","logFC","logFC_steatosis","se_Intercept","se","se_steatosis","p_Intercept","p_value","p_steatosis","gene_id","gene","Gene")
# full_results$Variable <- oro
# 
# #Calculate number of genes filtered out for low expression 
# low_exp <- length(genes_list)-length(full_results$gene)
# #Filter out non-converging genes
# full_results <- full_results %>% 
#   filter(!gene %in%  nonconverge_genes)
# #Calculate nonconvergence rate
# nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
# full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
# # mutate(fdr3=p.adjust(PValue3,method="fdr"))
# full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
# # results_total <- rbind(results_total,full_results)
# write.csv(full_results,fs::path(dir.results,paste0("NEBULA_Hepatocytes_",oro,"_ast_adj_2000_hvg.csv")))
# # }

# oro_vars <- c("lipidpe_pcmgs","lipid_ep","lipidrcr_state2","lipidrcr_state4_c1","lipidrcr_state4_c12","lipid_le")
# oro_vars <- colnames(meta)[85:114]
carb_vars <- oro_vars[c(1,2,5:7,9,10,15)]
# results_total <- data.frame()
for (oro in carb_vars) {
  # oro <- c("carb_cytoc")
  # full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hepatocytes_",oro,"_ast_adj_2000_hvg.csv")))
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- unique(full_results$Nuceli)
  # genes_list <- unique(full_results$Gene)
  # nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = "TCA Cycle Genes in Hepatocytes",
      subtitle = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(paste0("/home/hhampson/Results/Plot_NEBULA_Hepatocytes_",oro,"_TCA.png"),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
}

lipid_vars <- oro_vars[c(16,17,20:22,24,25,30)]
for (oro in lipid_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- unique(full_results$Nuceli)
  # genes_list <- unique(full_results$Gene)
  # nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = "TCA Cycle Genes in Hepatocytes",
      subtitle = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(paste0("/home/hhampson/Results/Plot_NEBULA_Hepatocytes_",oro,"_TCA.png"),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
}


#Plots
#Sig results
carb_vars <- oro_vars[c(1,2,5:7,9,10,15)]
results_total <- data.frame()
for (oro in carb_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
  full_results <- full_results %>% 
    dplyr::select(-X)
  results_total <- rbind(full_results,results_total)
}
results_total <- results_total %>% 
  mutate(sig = ifelse(fdr < 0.05,"*",""))

#Sig results
lipid_vars <- oro_vars[c(16,17,20:22,24,25,30)]
results_total2 <- data.frame()
for (oro in lipid_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
  full_results <- full_results %>% 
    dplyr::select(-X)
  results_total2 <- rbind(full_results,results_total2)
}
results_total2 <- results_total2 %>% 
  mutate(sig = ifelse(fdr < 0.05,"*",""))

all_results <- rbind(results_total,results_total2)
write.csv(all_results,"/home/hhampson/Results/Hepatocytes_oroboros_results_tca.csv")
```

###ii. Ox Phos
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 

#Filter out the Biobank participants with missing oroboros data
biobank_ids <- c("BSA_026","BSA_034")
so_Hep <- subset(so_Hep,!StudyID %in% biobank_ids)
unique(so_Hep$StudyID) #"MANGO-06" "MANGO-18" "MANGO-05" "MANGO-07" "IT2D-19"  "IT2D-14"  "IT2D-15"  "MANGO-04"
table(so_Hep$steatosis_cat,so_Hep$carbp_m)

nrow(so_Hep) #28964 genes before, now 11224 genes
ncol(so_Hep) #130124 nuclei before, now 81388 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]

# for (cell_name in HR_celltypes){
# oro <- "carbp_m"
for (oro in oro_vars) {
  # Clear any existing objects from previous iterations
  if (exists("nebula_results_list")) rm(nebula_results_list)
  if (exists("hep_nebula_converged")) rm(hep_nebula_converged)
  if (exists("nebula_summaries")) rm(nebula_summaries)
  if (exists("full_results")) rm(full_results)
  if (exists("cl")) {
    try(stopCluster(cl), silent = TRUE)
    rm(cl)
  }
  
  # Force garbage collection
  gc()
  
  print(paste("Processing:", oro))
  
  
  so_OX_PHOS <- subset(so_Hep, features = ox_phos)
  DefaultAssay(so_OX_PHOS) <- "RNA"
  StartGenes <- nrow(so_OX_PHOS) #28964 genes, now 28 OX_PHOS genes only
  Nuclei <- ncol(so_OX_PHOS) #130124 nuclei, now 81388 nuclei
  # counts_ox_phos <- round(GetAssayData(so_ox_phos, layer = "counts"))
  genes_list <- ox_phos
  cells_to_keep <- colnames(so_OX_PHOS)[!is.na(so_OX_PHOS@meta.data[[oro]])]
  so_subset <- subset(so_OX_PHOS, cells = cells_to_keep)
  DefaultAssay(so_subset) <- "RNA"
  counts_ox_phos <- round(GetAssayData(so_subset, layer = "counts"))
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_ox_phos[g, , drop = FALSE]
      meta_gene <- subset(so_subset,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  full_results$Celltype <- "Hepatocytes"
  
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  full_results$Nuceli <- Nuclei
  full_results$Genes <- length(full_results$Gene)
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
}


#Plots
carb_vars <- oro_vars[c(1,2,5:7,9,10,15)]
# results_total <- data.frame()
for (oro in carb_vars) {
  # oro <- c("carb_cytoc")
  # full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hepatocytes_",oro,"_ast_adj_2000_hvg.csv")))
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- unique(full_results$Nuceli)
  # genes_list <- unique(full_results$Gene)
  # nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = "Ox Phos Genes in Hepatocytes",
      subtitle = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(paste0("/home/hhampson/Results/Plot_NEBULA_Hepatocytes_",oro,"_OX_PHOS.png"),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
}
#Sig results
carb_vars <- oro_vars[c(1,2,5:7,9,10,15)]
results_total <- data.frame()
for (oro in carb_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
  full_results <- full_results %>% 
    dplyr::select(-X)
  results_total <- rbind(full_results,results_total)
}
results_total <- results_total %>% 
  mutate(sig = ifelse(fdr < 0.05,"*",""))

lipid_vars <- oro_vars[c(16,17,20:22,24,25,30)]
for (oro in lipid_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- unique(full_results$Nuceli)
  # genes_list <- unique(full_results$Gene)
  # nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = "Ox Phos Genes in Hepatocytes",
      subtitle = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(paste0("/home/hhampson/Results/Plot_NEBULA_Hepatocytes_",oro,"_OX_PHOS.png"),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
}

#Sig results
lipid_vars <- oro_vars[c(16,17,20:22,24,25,30)]
results_total2 <- data.frame()
for (oro in lipid_vars) {
  full_results <- read.csv(paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
  full_results <- full_results %>% 
    dplyr::select(-X)
  results_total2 <- rbind(full_results,results_total2)
}
results_total2 <- results_total2 %>% 
  mutate(sig = ifelse(fdr < 0.05,"*",""))

all_results <- rbind(results_total,results_total2)
write.csv(all_results,"/home/hhampson/Results/Hepatocytes_oroboros_results_ox_phos.csv")
```
## b. Hep subtypes
###i. TCA
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 

#Filter out the Biobank participants with missing oroboros data
biobank_ids <- c("BSA_026","BSA_034")
so_Hep <- subset(so_Hep,!StudyID %in% biobank_ids)
unique(so_Hep$StudyID) #"MANGO-06" "MANGO-18" "MANGO-05" "MANGO-07" "IT2D-19"  "IT2D-14"  "IT2D-15"  "MANGO-04"
table(so_Hep$steatosis_cat,so_Hep$carbp_m)

nrow(so_Hep) #28964 genes before, now 11224 genes
ncol(so_Hep) #130124 nuclei before, now 81388 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]

# for (cell_name in HR_celltypes){
# oro <- "carbp_m"
for (oro in oro_vars) {
  # Clear any existing objects from previous iterations
  if (exists("nebula_results_list")) rm(nebula_results_list)
  if (exists("hep_nebula_converged")) rm(hep_nebula_converged)
  if (exists("nebula_summaries")) rm(nebula_summaries)
  if (exists("full_results")) rm(full_results)
  if (exists("cl")) {
    try(stopCluster(cl), silent = TRUE)
    rm(cl)
  }
  
  # Force garbage collection
  gc()
  
  print(paste("Processing:", oro))
  
  
  so_TCA <- subset(so_Hep, features = tca)
  DefaultAssay(so_TCA) <- "RNA"
  StartGenes <- nrow(so_TCA) #28964 genes, now 28 TCA genes only
  Nuclei <- ncol(so_TCA) #130124 nuclei, now 81388 nuclei
  # counts_tca <- round(GetAssayData(so_TCA, layer = "counts"))
  genes_list <- tca
  cells_to_keep <- colnames(so_TCA)[!is.na(so_TCA@meta.data[[oro]])]
  so_subset <- subset(so_TCA, cells = cells_to_keep)
  DefaultAssay(so_subset) <- "RNA"
  counts_tca <- round(GetAssayData(so_subset, layer = "counts"))
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_tca[g, , drop = FALSE]
      meta_gene <- subset(so_subset,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  full_results$Celltype <- "Hepatocytes"
  
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  full_results$Nuceli <- Nuclei
  full_results$Genes <- length(full_results$Gene)
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_tca.csv"))
}
# }
# "carbp_m"             "carb_adp"            "carb_g"              "carb_cytoc"          "carb_s"              "carb_omy"
#  [7] "carbfccp"            "carbrcr_pm"          "carbrcr_pmgs"        "carbpe_pmgs"         "carb_ep"             "carbrcr_state2"
# [13] "carbrcr_state4_c1"   "carbrcr_state4_c12"  "carb_le"             "lipidpc_m"           "lipid_adp"           "lipid_cytoc"
# [19] "lipid_g"             "lipid_s"             "lipid_omy"           "lipidfccp"           "lipidrcr_pcm"        "lipidrcr_pcmgs"
# [25] "lipidpe_pcmgs"       "lipid_ep"            "lipidrcr_state2"     "lipidrcr_state4_c1"  "lipidrcr_state4_c12" "lipid_le"

## Select Highly Variable Genes (HVGs)
# results_total <- data.frame()
# # for (oro in oro_vars) {
# so_Hep$steatosis_cat <- factor(so_Hep$steatosis_cat)
# so_Hep$steatosis_cat <- relevel(so_Hep$steatosis_cat,ref = "Low Steatosis (0+1)")
# 
# oro <- "carbp_m"
# cells_to_keep <- !is.na(so_Hep@meta.data[[oro]])
# so_celltype <- subset(so_Hep, cells = colnames(so_Hep)[cells_to_keep])
# 
# # so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# # hvgs <- VariableFeatures(so_celltype)
# counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ])
# genes_list <- hvgs
# 
# cl <- makeCluster(10)
# registerDoParallel(cl)
# 
# start_time <- Sys.time()
# 
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- subset(so_celltype,features=g)@meta.data
#     formula <- as.formula(paste("~", oro,"+ast"))
#     pred_gene <- model.matrix(formula, data = meta_gene)
#     # pred_gene <- model.matrix(~oro, data = meta_gene)
#     # library <- meta_gene$pooled_offset
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }
# 
# stopCluster(cl)
# end_time <- Sys.time()
# print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
colnames(full_results) <- c("logFC_Intercept","logFC","logFC_steatosis","se_Intercept","se","se_steatosis","p_Intercept","p_value","p_steatosis","gene_id","gene","Gene")
full_results$Variable <- oro

#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
# results_total <- rbind(results_total,full_results)
write.csv(full_results,fs::path(dir.results,paste0("NEBULA_Hepatocytes_",oro,"_ast_adj_2000_hvg.csv")))
# }

# oro_vars <- c("lipidpe_pcmgs","lipid_ep","lipidrcr_state2","lipidrcr_state4_c1","lipidrcr_state4_c12","lipid_le")
oro_vars <- colnames(meta)[85:114]
# results_total <- data.frame()
for (oro in oro_vars) {
  oro <- c("carb_cytoc")
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hepatocytes_",oro,"_ast_adj_2000_hvg.csv")))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- ncol(so_celltype)
  # genes_list <- unique(full_results$Gene)
  # nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      subtitle = "Hepatocytes, Adj. AST (REML,Log Normal,Pooled Offset)",
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(fs::path(dir.results, paste0("Plot_NEBULA_Hepatocytes_",oro,"_adj_steatosis_2000_pooled_offset.png")),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
  
  #Gsea
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  # clean_names() %>% 
  # dplyr::select(-x) %>% 
  full_results <- full_results %>% 
    dplyr::select(-X) %>%
    dplyr::rename(LogFC=logFC)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_dHep <- full_results$LogFC
  names(rankings_dHep) <- full_results$Gene
  rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
  plot(rankings_dHep)
  min(rankings_dHep)
  max(rankings_dHep)
  
  set.seed(1234)
  
  kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                                stats = rankings_dHep,
                                scoreType = 'std', 
                                minSize = 3,
                                maxSize = 500,
                                nproc = 1)
  
  reactome_res_dHep <- fgsea(pathways = reactome,
                             stats = rankings_dHep,
                             scoreType = 'std', 
                             minSize = 3,
                             maxSize = 500,
                             nproc = 1)
  go_res_dHep <- fgsea(pathways = go,
                       stats = rankings_dHep,
                       scoreType = 'std', 
                       minSize = 5,
                       maxSize = 500,
                       nproc = 1)
  
  dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                           "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                           "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
  rownames(dHep_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_dHep, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hepatocytes Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_dHep, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hepatocytes Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,paste0(oro,"_Hepatocytes_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
  
  # results_total <- rbind(results_total,results)
}
# results_total <- results_total %>% 
#   dplyr::select(-X)

# write.csv(results_total,fs::path(dir.results,"NEBULA_Hepatocytes_Oroboros_unadjusted_2000_hvg.csv"))

# # Define significance stars
# results_total <- results_total %>%
#   mutate(signif = case_when(
#     fdr < 0.01 ~ "**",
#     fdr < 0.05 ~ "*",
#     TRUE ~ ""
#   ))
# 
# # Select only the needed columns and rename LogFC for clarity
# heatmap_data <- results_total %>%
#   dplyr::select(Gene, Variable, logFC, signif)
# 
# # custom_order <- oro_vars
# # heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
# # custom_labels <- str_to_title(str_replace_all(oro,"_"," "))
# 
# # Carb_cytoc
# # Carb_s
# # Carb_omy
# # Carb_fccp
# #  
# # Lipid_cytoc
# # Lipid_s
# # Lipid_omy
# # Lipid_fccp
# 
# 
# heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
#   geom_tile(color = "grey90") +
#   geom_text(aes(label = signif), size = 3, color = "black") +
#   scale_fill_gradient2(
#     low = "#264653", mid = "white", high = "darkred",
#     midpoint = 0,
#     name = "LogFC"
#   ) +
#   theme_minimal() +
#   labs(
#     # title = "TCA Cycle Genes vs. PET Variables (T2D)",
#     # subtitle = "Proximal Tubule Cells",
#     x = "Exposure",
#     y = "Gene") +
#   # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
#   theme(
#     text = element_text(face="bold"),
#     axis.text.y = element_text(size = 6),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.ticks.y = element_blank(),
#     axis.title.x = element_blank(),
#     panel.grid = element_blank()
#   )
# 
# # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
# 
# png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 1500, height = 2000, res = 300)
# print(heat_map_p)
# dev.off()

```

###ii. Ox Phos
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 

#Filter out the Biobank participants with missing oroboros data
biobank_ids <- c("BSA_026","BSA_034")
so_Hep <- subset(so_Hep,!StudyID %in% biobank_ids)
unique(so_Hep$StudyID) #"MANGO-06" "MANGO-18" "MANGO-05" "MANGO-07" "IT2D-19"  "IT2D-14"  "IT2D-15"  "MANGO-04"
table(so_Hep$steatosis_cat,so_Hep$carbp_m)

nrow(so_Hep) #28964 genes before, now 11224 genes
ncol(so_Hep) #130124 nuclei before, now 81388 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]

# for (cell_name in HR_celltypes){
# oro <- "carbp_m"
for (oro in oro_vars) {
  # Clear any existing objects from previous iterations
  if (exists("nebula_results_list")) rm(nebula_results_list)
  if (exists("hep_nebula_converged")) rm(hep_nebula_converged)
  if (exists("nebula_summaries")) rm(nebula_summaries)
  if (exists("full_results")) rm(full_results)
  if (exists("cl")) {
    try(stopCluster(cl), silent = TRUE)
    rm(cl)
  }
  
  # Force garbage collection
  gc()
  
  print(paste("Processing:", oro))
  
  
  so_OX_PHOS <- subset(so_Hep, features = ox_phos)
  DefaultAssay(so_OX_PHOS) <- "RNA"
  StartGenes <- nrow(so_OX_PHOS) #28964 genes, now 28 OX_PHOS genes only
  Nuclei <- ncol(so_OX_PHOS) #130124 nuclei, now 81388 nuclei
  # counts_ox_phos <- round(GetAssayData(so_ox_phos, layer = "counts"))
  genes_list <- ox_phos
  cells_to_keep <- colnames(so_OX_PHOS)[!is.na(so_OX_PHOS@meta.data[[oro]])]
  so_subset <- subset(so_OX_PHOS, cells = cells_to_keep)
  DefaultAssay(so_subset) <- "RNA"
  counts_ox_phos <- round(GetAssayData(so_subset, layer = "counts"))
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_ox_phos[g, , drop = FALSE]
      meta_gene <- subset(so_subset,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40 | hep_nebula_converged$Convergence_Code==-50 | hep_nebula_converged$Convergence_Code==-60)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  full_results$Celltype <- "Hepatocytes"
  
  #Calculate number of genes filtered out for low expression 
  full_results$low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  full_results$nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  full_results$Nuceli <- Nuclei
  full_results$Genes <- length(full_results$Gene)
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  write.csv(full_results,paste0("/home/hhampson/Results/NEBULA_",oro,"_Hepatocytes_ox_phos.csv"))
}

```


### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #130124 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)
# Use lapply to pull all summaries and add gene names
# nebula_summaries <- do.call(rbind, lapply(names(nebula_results_list), function(gene) {
#   if (!is.null(nebula_results_list[[gene]]$summary)) {
#     df <- nebula_results_list[[gene]]$summary
#     df$gene <- gene  # Add gene name as a new column
#     return(df)
#   } else {
#     NULL
#   }
# }))
nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hepatocytes_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hepatocytes, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hepatocytes_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```

## b. Hep-1
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_Hep) <- "RNA" 

nrow(so_Hep) #28964 genes
ncol(so_Hep) #130124 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]
# "carbp_m"             "carb_adp"            "carb_g"              "carb_cytoc"          "carb_s"              "carb_omy"
#  [7] "carbfccp"            "carbrcr_pm"          "carbrcr_pmgs"        "carbpe_pmgs"         "carb_ep"             "carbrcr_state2"
# [13] "carbrcr_state4_c1"   "carbrcr_state4_c12"  "carb_le"             "lipidpc_m"           "lipid_adp"           "lipid_cytoc"
# [19] "lipid_g"             "lipid_s"             "lipid_omy"           "lipidfccp"           "lipidrcr_pcm"        "lipidrcr_pcmgs"
# [25] "lipidpe_pcmgs"       "lipid_ep"            "lipidrcr_state2"     "lipidrcr_state4_c1"  "lipidrcr_state4_c12" "lipid_le"

## Select Highly Variable Genes (HVGs)
# results_total <- data.frame()
oro_vars <- colnames(meta)[95:114]
for (oro in oro_vars) {
  # oro <- "carbp_m"
  cells_to_keep <- !is.na(so_Hep@meta.data[[oro]])
  so_celltype <- subset(so_Hep, cells = colnames(so_Hep)[cells_to_keep])
  
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ])
  genes_list <- hvgs
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      # pred_gene <- model.matrix(~oro, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  # results_total <- rbind(results_total,full_results)
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_Hep_1_",oro,"_unadjusted_2000_hvg.csv")))
}

# oro_vars <- c("lipidpe_pcmgs","lipid_ep","lipidrcr_state2","lipidrcr_state4_c1","lipidrcr_state4_c12","lipid_le")
oro_vars <- colnames(meta)[85:114]
# results_total <- data.frame()
for (oro in oro_vars) {
  # oro <- c("lipid_ep")
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hep_1_",oro,"_unadjusted_2000_hvg.csv")))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- ncol(so_celltype)
  # Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      subtitle = "Hep_1, Unadjusted (REML,Log Normal,Pooled Offset)",
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(fs::path(dir.results, paste0("Plot_NEBULA_Hep_1_",oro,"_unadjusted_2000_pooled_offset.png")),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
  
  #Gsea
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  # clean_names() %>% 
  # dplyr::select(-x) %>% 
  full_results <- full_results %>% 
    dplyr::select(-X) %>%
    dplyr::rename(LogFC=logFC)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_Hep_1 <- full_results$LogFC
  names(rankings_Hep_1) <- full_results$Gene
  rankings_Hep_1 <- sort(rankings_Hep_1, decreasing = TRUE)
  plot(rankings_Hep_1)
  min(rankings_Hep_1)
  max(rankings_Hep_1)
  
  set.seed(1234)
  
  kegg_legacy_res_Hep_1 <- fgsea(pathways = kegg_legacy,
                                 stats = rankings_Hep_1,
                                 scoreType = 'std', 
                                 minSize = 3,
                                 maxSize = 500,
                                 nproc = 1)
  
  reactome_res_Hep_1 <- fgsea(pathways = reactome,
                              stats = rankings_Hep_1,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)
  go_res_Hep_1 <- fgsea(pathways = go,
                        stats = rankings_Hep_1,
                        scoreType = 'std', 
                        minSize = 5,
                        maxSize = 500,
                        nproc = 1)
  
  Hep_1_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep_1[, padj < 0.05]), sum(kegg_legacy_res_Hep_1[, pval < 0.05])),
                            "REACTOME"=c(sum(reactome_res_Hep_1[, padj < 0.05]), sum(reactome_res_Hep_1[, pval < 0.05])),
                            "GO"=c(sum(go_res_Hep_1[, padj < 0.05]), sum(go_res_Hep_1[, pval < 0.05])))
  rownames(Hep_1_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_Hep_1, title = "Hep_1 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_1_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_Hep_1, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_1 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_1_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_Hep_1, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_1 Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_1_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,paste0(oro,"_Hep_1_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
  
  # results_total <- rbind(results_total,results)
}
# results_total <- results_total %>% 
#   dplyr::select(-X)

# write.csv(results_total,fs::path(dir.results,"NEBULA_Hep_1_Oroboros_unadjusted_2000_hvg.csv"))

# # Define significance stars
# results_total <- results_total %>%
#   mutate(signif = case_when(
#     fdr < 0.01 ~ "**",
#     fdr < 0.05 ~ "*",
#     TRUE ~ ""
#   ))
# 
# # Select only the needed columns and rename LogFC for clarity
# heatmap_data <- results_total %>%
#   dplyr::select(Gene, Variable, logFC, signif)
# 
# # custom_order <- oro_vars
# # heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
# # custom_labels <- str_to_title(str_replace_all(oro,"_"," "))
# 
# # Carb_cytoc
# # Carb_s
# # Carb_omy
# # Carb_fccp
# #  
# # Lipid_cytoc
# # Lipid_s
# # Lipid_omy
# # Lipid_fccp
# 
# 
# heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
#   geom_tile(color = "grey90") +
#   geom_text(aes(label = signif), size = 3, color = "black") +
#   scale_fill_gradient2(
#     low = "#264653", mid = "white", high = "darkred",
#     midpoint = 0,
#     name = "LogFC"
#   ) +
#   theme_minimal() +
#   labs(
#     # title = "TCA Cycle Genes vs. PET Variables (T2D)",
#     # subtitle = "Proximal Tubule Cells",
#     x = "Exposure",
#     y = "Gene") +
#   # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
#   theme(
#     text = element_text(face="bold"),
#     axis.text.y = element_text(size = 6),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.ticks.y = element_blank(),
#     axis.title.x = element_blank(),
#     panel.grid = element_blank()
#   )
# 
# # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
# 
# png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 1500, height = 2000, res = 300)
# print(heat_map_p)
# dev.off()

```

```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_celltype) <- "RNA" 
so_celltype@assays
head(GetAssayData(so_celltype, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_celltype, layer = "data")[, 1:5])  

nrow(so_celltype) #11300 genes
ncol(so_celltype) #24808 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

```

### i. NEBULA
```{r}
#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~carbp_m, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg_reml.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-1, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)

print(volcano_plot)

dev.off()
```

### ii. Pathway Enrichment
```{r echo = F}
#Hep-1
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::select(c("gene","log_fc_steatosis_cat_high_steatosis_2_3","fdr")) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
sig_pos <- full_results %>% 
  filter(LogFC>0 & fdr<0.05)
sig_neg <- full_results %>% 
  filter(LogFC<0 & fdr<0.05)

#Run postive enricher analysis 
sig_pos_en <- enrichr(as.character(sig_pos$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[1]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[2]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Kegg")
# plotEnrich(as.data.frame(sig_pos_en[[2]]), title = "Model 1 Positive Hep-1 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Positive Hep-1 - Reactome '22")
# # plotEnrich(as.data.frame(sig_pos_en[[3]]), title = "Model 1 Positive Hep-1 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[5]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Positive Hep-1 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[4]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-1 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# # Arrange 6 plots in 3 rows x 2 columns
# combined_plot <- (p1 | p2) / 
#   (p3 | p4) 
# 
# # Display or save the plot
# figure <- combined_plot + 
#   plot_annotation(
#     title = "Positive Gene Set Enrichment Analysis for Hep-1 vs. Steatosis (High/Low)",
#     theme = theme(
#       plot.title = element_text(
#         hjust = 0.5,         # Center title
#         size = 18,           # Bigger font
#         face = "bold"        # Bold text
#       )
#     )
#   )

# ggsave(fs::path(dir.results, "Positive_Hep-1_gsea_figure.jpeg"), figure, width = 18, height = 10)

#Run negative enricher analysis 
sig_neg_en <- enrichr(as.character(sig_neg$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[1]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[2]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Kegg")
# plotEnrich(as.data.frame(sig_neg_en[[2]]), title = "Model 1 Negative Hep-1 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Negative Hep-1 - Reactome '22")
# # plotEnrich(as.data.frame(sig_neg_en[[3]]), title = "Model 1 Negative Hep-1 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[5]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Negative Hep-1 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[4]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-1 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-1 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# Arrange 6 plots in 3 rows x 2 columns
combined_plot <- (p1 | p2) / 
  (p3 | p4) 

# Display or save the plot
figure <- combined_plot + 
  plot_annotation(
    title = "Negative Gene Set Enrichment Analysis for Hep-1 vs. Steatosis (High/Low)",
    theme = theme(
      plot.title = element_text(
        hjust = 0.5,         # Center title
        size = 18,           # Bigger font
        face = "bold"        # Bold text
      )
    )
  )

ggsave(fs::path(dir.results, "NEBULA_Negative_Hep_1_gsea_figure.jpeg"), figure, width = 18, height = 10)

```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_hep1 <- full_results$LogFC
names(rankings_hep1) <- full_results$Gene
rankings_hep1 <- sort(rankings_hep1, decreasing = TRUE)
plot(rankings_hep1)
min(rankings_hep1)
max(rankings_hep1)

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_hep1, title = "Hep-1 Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"Hep1_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_hep1, title = "Hep-1 Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"Hep1_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_hep1, title = "Hep-1 Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"Hep1_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #130124 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_1_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-1, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hep_1_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```


## c. Hep-2
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype=="Hep-2")
DefaultAssay(so_Hep) <- "RNA" 

nrow(so_Hep) #28964 genes
ncol(so_Hep) #130124 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]
# "carbp_m"             "carb_adp"            "carb_g"              "carb_cytoc"          "carb_s"              "carb_omy"
#  [7] "carbfccp"            "carbrcr_pm"          "carbrcr_pmgs"        "carbpe_pmgs"         "carb_ep"             "carbrcr_state2"
# [13] "carbrcr_state4_c1"   "carbrcr_state4_c12"  "carb_le"             "lipidpc_m"           "lipid_adp"           "lipid_cytoc"
# [19] "lipid_g"             "lipid_s"             "lipid_omy"           "lipidfccp"           "lipidrcr_pcm"        "lipidrcr_pcmgs"
# [25] "lipidpe_pcmgs"       "lipid_ep"            "lipidrcr_state2"     "lipidrcr_state4_c1"  "lipidrcr_state4_c12" "lipid_le"

## Select Highly Variable Genes (HVGs)
# results_total <- data.frame()
oro_vars <- colnames(meta)[85:114]
for (oro in oro_vars) {
  # oro <- "carbp_m"
  cells_to_keep <- !is.na(so_Hep@meta.data[[oro]])
  so_celltype <- subset(so_Hep, cells = colnames(so_Hep)[cells_to_keep])
  
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ])
  genes_list <- hvgs
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      # pred_gene <- model.matrix(~oro, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  # results_total <- rbind(results_total,full_results)
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_Hep_2_",oro,"_unadjusted_2000_hvg.csv")))
}

# oro_vars <- c("lipidpe_pcmgs","lipid_ep","lipidrcr_state2","lipidrcr_state4_c1","lipidrcr_state4_c12","lipid_le")
oro_vars <- colnames(meta)[85:114]
# results_total <- data.frame()
for (oro in oro_vars) {
  # oro <- c("lipid_ep")
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hep_2_",oro,"_unadjusted_2000_hvg.csv")))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      subtitle = "Hep_2, Unadjusted (REML,Log Normal,Pooled Offset)",
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(fs::path(dir.results, paste0("Plot_NEBULA_Hep_2_",oro,"_unadjusted_2000_pooled_offset.png")),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
  
  #Gsea
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  # clean_names() %>% 
  # dplyr::select(-x) %>% 
  full_results <- full_results %>% 
    dplyr::select(-X) %>%
    dplyr::rename(LogFC=logFC)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_Hep_2 <- full_results$LogFC
  names(rankings_Hep_2) <- full_results$Gene
  rankings_Hep_2 <- sort(rankings_Hep_2, decreasing = TRUE)
  plot(rankings_Hep_2)
  min(rankings_Hep_2)
  max(rankings_Hep_2)
  
  set.seed(1234)
  
  kegg_legacy_res_Hep_2 <- fgsea(pathways = kegg_legacy,
                                 stats = rankings_Hep_2,
                                 scoreType = 'std', 
                                 minSize = 3,
                                 maxSize = 500,
                                 nproc = 1)
  
  reactome_res_Hep_2 <- fgsea(pathways = reactome,
                              stats = rankings_Hep_2,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)
  go_res_Hep_2 <- fgsea(pathways = go,
                        stats = rankings_Hep_2,
                        scoreType = 'std', 
                        minSize = 5,
                        maxSize = 500,
                        nproc = 1)
  
  Hep_2_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep_2[, padj < 0.05]), sum(kegg_legacy_res_Hep_2[, pval < 0.05])),
                            "REACTOME"=c(sum(reactome_res_Hep_2[, padj < 0.05]), sum(reactome_res_Hep_2[, pval < 0.05])),
                            "GO"=c(sum(go_res_Hep_2[, padj < 0.05]), sum(go_res_Hep_2[, pval < 0.05])))
  rownames(Hep_2_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_Hep_2, title = "Hep_2 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_2_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_Hep_2, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_2_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_Hep_2, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_2 Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_2_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,paste0(oro,"_Hep_2_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
  
  # results_total <- rbind(results_total,results)
}
# results_total <- results_total %>% 
#   dplyr::select(-X)

# write.csv(results_total,fs::path(dir.results,"NEBULA_Hep_2_Oroboros_unadjusted_2000_hvg.csv"))

# # Define significance stars
# results_total <- results_total %>%
#   mutate(signif = case_when(
#     fdr < 0.01 ~ "**",
#     fdr < 0.05 ~ "*",
#     TRUE ~ ""
#   ))
# 
# # Select only the needed columns and rename LogFC for clarity
# heatmap_data <- results_total %>%
#   dplyr::select(Gene, Variable, logFC, signif)
# 
# # custom_order <- oro_vars
# # heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
# # custom_labels <- str_to_title(str_replace_all(oro,"_"," "))
# 
# # Carb_cytoc
# # Carb_s
# # Carb_omy
# # Carb_fccp
# #  
# # Lipid_cytoc
# # Lipid_s
# # Lipid_omy
# # Lipid_fccp
# 
# 
# heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
#   geom_tile(color = "grey90") +
#   geom_text(aes(label = signif), size = 3, color = "black") +
#   scale_fill_gradient2(
#     low = "#264653", mid = "white", high = "darkred",
#     midpoint = 0,
#     name = "LogFC"
#   ) +
#   theme_minimal() +
#   labs(
#     # title = "TCA Cycle Genes vs. PET Variables (T2D)",
#     # subtitle = "Proximal Tubule Cells",
#     x = "Exposure",
#     y = "Gene") +
#   # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
#   theme(
#     text = element_text(face="bold"),
#     axis.text.y = element_text(size = 6),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.ticks.y = element_blank(),
#     axis.title.x = element_blank(),
#     panel.grid = element_blank()
#   )
# 
# # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
# 
# png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 1500, height = 2000, res = 300)
# print(heat_map_p)
# dev.off()

```
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #22983 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# Subset Seurat object to only HVGs
so_celltype_hvg <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype_hvg) <- "RNA" 
```

### i. NEBULA
```{r}
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)

end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_hvg_reml.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-2, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_Hep_2_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)

print(volcano_plot)

dev.off()
```

### ii. Pathway Enrichment
```{r echo = F}
#Hep-2
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::select(c("gene","log_fc_steatosis_cat_high_steatosis_2_3","fdr")) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)
sig_pos <- full_results %>% 
  filter(LogFC>0 & fdr<0.05)
sig_neg <- full_results %>% 
  filter(LogFC<0 & fdr<0.05)

#Run postive enricher analysis 
sig_pos_en <- enrichr(as.character(sig_pos$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[1]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[2]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - Kegg")
# plotEnrich(as.data.frame(sig_pos_en[[2]]), title = "Model 1 Positive Hep-2 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Positive Hep-2 - Reactome '22")
# # plotEnrich(as.data.frame(sig_pos_en[[3]]), title = "Model 1 Positive Hep-2 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-2 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[5]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Positive Hep-2 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-2 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[4]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hep-2 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hep-2 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# # Arrange 6 plots in 3 rows x 2 columns
# combined_plot <- (p1 | p2) / 
#   (p3 | p4) 
# 
# # Display or save the plot
# figure <- combined_plot + 
#   plot_annotation(
#     title = "Positive Gene Set Enrichment Analysis for Hep-2 vs. Steatosis (High/Low)",
#     theme = theme(
#       plot.title = element_text(
#         hjust = 0.5,         # Center title
#         size = 18,           # Bigger font
#         face = "bold"        # Bold text
#       )
#     )
#   )

# ggsave(fs::path(dir.results, "Positive_Hep-2_gsea_figure.jpeg"), figure, width = 18, height = 10)

#Run negative enricher analysis 
sig_neg_en <- enrichr(as.character(sig_neg$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[1]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[2]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - Kegg")
# plotEnrich(as.data.frame(sig_neg_en[[2]]), title = "Model 1 Negative Hep-2 - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Negative Hep-2 - Reactome '22")
# # plotEnrich(as.data.frame(sig_neg_en[[3]]), title = "Model 1 Negative Hep-2 - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-2 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[5]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Negative Hep-2 - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-2 - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[4]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hep-2 - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hep-2 - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# Arrange 6 plots in 3 rows x 2 columns
combined_plot <- (p1 | p2) / 
  (p3 | p4) 

# Display or save the plot
figure <- combined_plot + 
  plot_annotation(
    title = "Negative Gene Set Enrichment Analysis for Hep-2 vs. Steatosis (High/Low)",
    theme = theme(
      plot.title = element_text(
        hjust = 0.5,         # Center title
        size = 18,           # Bigger font
        face = "bold"        # Bold text
      )
    )
  )

ggsave(fs::path(dir.results, "NEBULA_Negative_Hep_2_gsea_figure.jpeg"), figure, width = 18, height = 10)

```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_2_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_hep2 <- full_results$LogFC
names(rankings_hep2) <- full_results$Gene
rankings_hep2 <- sort(rankings_hep2, decreasing = TRUE)
plot(rankings_hep2)
min(rankings_hep2)
max(rankings_hep2)


set.seed(1234)

kegg_legacy_res_hep2 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_hep2,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_hep2 <- fgsea(pathways = reactome,
                           stats = rankings_hep2,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_hep2 <- fgsea(pathways = go,
                     stats = rankings_hep2,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

hep2_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_hep2[, padj < 0.05]), sum(kegg_legacy_res_hep2[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_hep2[, padj < 0.05]), sum(reactome_res_hep2[, pval < 0.05])),
                         "GO"=c(sum(go_res_hep2[, padj < 0.05]), sum(go_res_hep2[, pval < 0.05])))
rownames(hep2_fgsea) <- c("adj.pval", "p.val")
hep2_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_hep2, title = "Hep-2 Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"hep2_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_hep2, title = "Hep-2 Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"hep2_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_hep2, title = "Hep-2 Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"hep2_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #130124 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_2_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-2, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hep_2_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```

## d. Hep-3
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype=="Hep-3")
DefaultAssay(so_Hep) <- "RNA" 

nrow(so_Hep) #28964 genes
ncol(so_Hep) #130124 nuclei
meta <- so_Hep@meta.data
oro_vars <- colnames(meta)[85:114]
# "carbp_m"             "carb_adp"            "carb_g"              "carb_cytoc"          "carb_s"              "carb_omy"
#  [7] "carbfccp"            "carbrcr_pm"          "carbrcr_pmgs"        "carbpe_pmgs"         "carb_ep"             "carbrcr_state2"
# [13] "carbrcr_state4_c1"   "carbrcr_state4_c12"  "carb_le"             "lipidpc_m"           "lipid_adp"           "lipid_cytoc"
# [19] "lipid_g"             "lipid_s"             "lipid_omy"           "lipidfccp"           "lipidrcr_pcm"        "lipidrcr_pcmgs"
# [25] "lipidpe_pcmgs"       "lipid_ep"            "lipidrcr_state2"     "lipidrcr_state4_c1"  "lipidrcr_state4_c12" "lipid_le"

## Select Highly Variable Genes (HVGs)
# results_total <- data.frame()
oro_vars <- colnames(meta)[85:114]
for (oro in oro_vars) {
  # oro <- "carbp_m"
  cells_to_keep <- !is.na(so_Hep@meta.data[[oro]])
  so_celltype <- subset(so_Hep, cells = colnames(so_Hep)[cells_to_keep])
  
  so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
  hvgs <- VariableFeatures(so_celltype)
  counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ])
  genes_list <- hvgs
  
  cl <- makeCluster(10)
  registerDoParallel(cl)
  
  start_time <- Sys.time()
  
  nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
    tryCatch({
      count_gene <- counts_hvg[g, , drop = FALSE]
      meta_gene <- subset(so_celltype,features=g)@meta.data
      formula <- as.formula(paste("~", oro))
      pred_gene <- model.matrix(formula, data = meta_gene)
      # pred_gene <- model.matrix(~oro, data = meta_gene)
      # library <- meta_gene$pooled_offset
      library <- meta_gene$pooled_offset
      data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
      
      if (is.null(data_g_gene)) {
        data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
      }
      
      #With offset
      result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
      
      list(gene = g, result = result)  # return both gene name and result
      
    }, error = function(e) {
      NULL
    })
  }
  
  stopCluster(cl)
  end_time <- Sys.time()
  print(end_time - start_time)
  
  # set the names of results based on gene names
  nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
  names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
  nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results
  
  hep_nebula_converged <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      converged <- nebula_results_list[[gene_name]]$convergence
      df <- data.frame(Gene = gene_name,
                       Convergence_Code = converged)
      return(df)
    }
  )
  
  nebula_summaries <- map_dfr(
    names(nebula_results_list),
    function(gene_name) {
      df <- nebula_results_list[[gene_name]]$summary
      df <- df %>% mutate(Gene = gene_name)
      return(df)
    }
  )
  nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
  ) 
  
  full_results <- as.data.frame(nebula_summaries)
  colnames(full_results) <- c("logFC_Intercept","logFC","se_Intercept","se","p_Intercept","p_value","gene_id","gene","Gene")
  full_results$Variable <- oro
  
  #Calculate number of genes filtered out for low expression 
  low_exp <- length(genes_list)-length(full_results$gene)
  #Filter out non-converging genes
  full_results <- full_results %>% 
    filter(!gene %in%  nonconverge_genes)
  #Calculate nonconvergence rate
  nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
  # nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
  # print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
  full_results$fdr <- p.adjust(full_results[,6],method="fdr")  
  # mutate(fdr3=p.adjust(PValue3,method="fdr"))
  full_results$PValue10 <- -log10(pmax(full_results[,6], 1e-10))
  # results_total <- rbind(results_total,full_results)
  write.csv(full_results,fs::path(dir.results,paste0("NEBULA_Hep_3_",oro,"_unadjusted_2000_hvg.csv")))
}

# oro_vars <- c("lipidpe_pcmgs","lipid_ep","lipidrcr_state2","lipidrcr_state4_c1","lipidrcr_state4_c12","lipid_le")
oro_vars <- colnames(meta)[85:114]
# results_total <- data.frame()
for (oro in oro_vars) {
  # oro <- c("lipid_ep")
  full_results <- read.csv(fs::path(dir.results,paste0("NEBULA_Hep_3_",oro,"_unadjusted_2000_hvg.csv")))
  full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$logFC > 0, "#990000",
                               ifelse(full_results$fdr < 0.05 & full_results$logFC < 0, "#003366", "lightgray"))
  
  # Identify significant points (fdr < 0.05)
  significant_df <- full_results[full_results$fdr < 0.05, ]
  
  Genes <- length(unique(full_results$gene))
  Nuclei <- ncol(so_celltype)
  Nonconvergence_Rate <- nebula_nonconverged_percent
  # full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 > 0, "lightcoral",
  #                               ifelse(full_results$fdr3 < 0.2 & full_results$logFC3 < 0, "lightblue", "gray"))
  # 
  # # Identify significant points (fdr < 0.05)
  # significant_df3 <- full_results[full_results$fdr3 < 0.2, ]
  
  max <- max(full_results$logFC)
  # max <- 3.1
  min <- min(full_results$logFC)
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = logFC, y = PValue10, color = color)) +
    geom_point(alpha = 0.7) +  # Plot points with transparency
    scale_color_identity() +  # Use the color column directly
    theme_minimal() +  # Minimal theme
    labs(
      title = paste0(str_to_title(str_replace_all(oro,"_"," "))),
      subtitle = "Hep_3, Unadjusted (REML,Log Normal,Pooled Offset)",
      x = "FC",
      y = "-log10(P-Value)",
      color = "FC Direction Direction",
      # caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
      caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
    ) +
    theme(
      plot.title = element_text(hjust = 0),
      axis.text.x = element_text(angle = 0, hjust = 1)
    )+
    xlim(min,max)+
    # xlim(-3,3)+
    # # Add labels for significant points
    geom_text(data = significant_df, aes(label = gene),
              vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  
  volcano_plot
  png(fs::path(dir.results, paste0("Plot_NEBULA_Hep_3_",oro,"_unadjusted_2000_pooled_offset.png")),
      width = 2500, height = 2100, res = 300)
  print(volcano_plot)
  dev.off()
  
  #Gsea
  # full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  # clean_names() %>% 
  # dplyr::select(-x) %>% 
  full_results <- full_results %>% 
    dplyr::select(-X) %>%
    dplyr::rename(LogFC=logFC)
  
  # Filter out the gmt files for KEGG, Reactome and GOBP
  list.files(bg_path)
  gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
  gmt_files
  kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
  reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
  go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
  
  # rank genes by t-stats in DiD
  rankings_Hep_3 <- full_results$LogFC
  names(rankings_Hep_3) <- full_results$Gene
  rankings_Hep_3 <- sort(rankings_Hep_3, decreasing = TRUE)
  plot(rankings_Hep_3)
  min(rankings_Hep_3)
  max(rankings_Hep_3)
  
  set.seed(1234)
  
  kegg_legacy_res_Hep_3 <- fgsea(pathways = kegg_legacy,
                                 stats = rankings_Hep_3,
                                 scoreType = 'std', 
                                 minSize = 3,
                                 maxSize = 500,
                                 nproc = 1)
  
  reactome_res_Hep_3 <- fgsea(pathways = reactome,
                              stats = rankings_Hep_3,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)
  go_res_Hep_3 <- fgsea(pathways = go,
                        stats = rankings_Hep_3,
                        scoreType = 'std', 
                        minSize = 5,
                        maxSize = 500,
                        nproc = 1)
  
  Hep_3_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep_3[, padj < 0.05]), sum(kegg_legacy_res_Hep_3[, pval < 0.05])),
                            "REACTOME"=c(sum(reactome_res_Hep_3[, padj < 0.05]), sum(reactome_res_Hep_3[, pval < 0.05])),
                            "GO"=c(sum(go_res_Hep_3[, padj < 0.05]), sum(go_res_Hep_3[, pval < 0.05])))
  rownames(Hep_3_fgsea) <- c("adj.pval", "p.val")
  
  ##### KEGG Legacy
  # a <- plot_fgsea_transpose(kegg_legacy_res_Hep_3, title = "Hep_3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_3_top30_kegg_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  ##### REACTOME
  b <- plot_fgsea_transpose(reactome_res_Hep_3, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)"), xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_3_top30_reactome_pathways_unadjusted.jpeg"),
  #        width = 13, height = 10, scale = 1)
  ##### GO
  c <- plot_fgsea_transpose(go_res_Hep_3, title = paste0(str_to_title(str_replace_all(oro,"_"," "))," in Hep_3 Unadjusted Top 30 GO (REML, Log Normal, Offset)"), xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
  
  # ggsave(fs::path(dir.results,"Hep_3_top30_go_pathways_unadjusted_reml_offset.jpeg"),
  #        width = 13, height = 10, scale = 1)
  
  combined_plot <- b + c + plot_layout(ncol = 1)
  print(combined_plot)
  ggsave(fs::path(dir.results,paste0(oro,"_Hep_3_top30_pathways_unadjusted.jpeg")),
         width = 15, height = 20, scale = 1)
  
  # results_total <- rbind(results_total,results)
}
# results_total <- results_total %>% 
#   dplyr::select(-X)

# write.csv(results_total,fs::path(dir.results,"NEBULA_Hep_3_Oroboros_unadjusted_2000_hvg.csv"))

# # Define significance stars
# results_total <- results_total %>%
#   mutate(signif = case_when(
#     fdr < 0.01 ~ "**",
#     fdr < 0.05 ~ "*",
#     TRUE ~ ""
#   ))
# 
# # Select only the needed columns and rename LogFC for clarity
# heatmap_data <- results_total %>%
#   dplyr::select(Gene, Variable, logFC, signif)
# 
# # custom_order <- oro_vars
# # heatmap_data$Variable <- factor(heatmap_data$Variable, levels = custom_order)
# # custom_labels <- str_to_title(str_replace_all(oro,"_"," "))
# 
# # Carb_cytoc
# # Carb_s
# # Carb_omy
# # Carb_fccp
# #  
# # Lipid_cytoc
# # Lipid_s
# # Lipid_omy
# # Lipid_fccp
# 
# 
# heat_map_p <- ggplot(heatmap_data, aes(x = Variable, y = Gene, fill = logFC)) +
#   geom_tile(color = "grey90") +
#   geom_text(aes(label = signif), size = 3, color = "black") +
#   scale_fill_gradient2(
#     low = "#264653", mid = "white", high = "darkred",
#     midpoint = 0,
#     name = "LogFC"
#   ) +
#   theme_minimal() +
#   labs(
#     # title = "TCA Cycle Genes vs. PET Variables (T2D)",
#     # subtitle = "Proximal Tubule Cells",
#     x = "Exposure",
#     y = "Gene") +
#   # scale_x_discrete(labels = setNames(custom_labels, custom_order))+
#   theme(
#     text = element_text(face="bold"),
#     axis.text.y = element_text(size = 6),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.ticks.y = element_blank(),
#     axis.title.x = element_blank(),
#     panel.grid = element_blank()
#   )
# 
# # custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")
# 
# png(fs::path(dir.results, "Heatmap_TCA_cycle_NEBULA_PT_PET_unadjusted_pooled_offset_T2D.png"), 
#     width = 1500, height = 2000, res = 300)
# print(heat_map_p)
# dev.off()

```

```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-3")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #22983 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# Subset Seurat object to only HVGs
so_celltype_hvg <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype_hvg) <- "RNA" 
```

### i. NEBULA
```{r}
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)

end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_3_Steatosis_unadjusted_2000_hvg_reml.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-3, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_Hep_3_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_3_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep3 <- full_results$LogFC
names(rankings_Hep3) <- full_results$Gene
rankings_Hep3 <- sort(rankings_Hep3, decreasing = TRUE)
plot(rankings_Hep3)
min(rankings_Hep3)
max(rankings_Hep3)


set.seed(1234)

kegg_legacy_res_Hep3 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep3,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep3 <- fgsea(pathways = reactome,
                           stats = rankings_Hep3,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_Hep3 <- fgsea(pathways = go,
                     stats = rankings_Hep3,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

Hep3_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep3[, padj < 0.05]), sum(kegg_legacy_res_Hep3[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep3[, padj < 0.05]), sum(reactome_res_Hep3[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep3[, padj < 0.05]), sum(go_res_Hep3[, pval < 0.05])))
rownames(Hep3_fgsea) <- c("adj.pval", "p.val")
Hep3_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_Hep3, title = "Hep-3 Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"Hep3_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_Hep3, title = "Hep-3 Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"Hep3_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_Hep3, title = "Hep-3 Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"Hep3_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-3")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #130124 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_3_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-3, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hep_3_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```

## e. Hep-4
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-4")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #22983 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# Subset Seurat object to only HVGs
so_celltype_hvg <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype_hvg) <- "RNA" 
```

### i. NEBULA
```{r}
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)

end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_4_Steatosis_unadjusted_2000_hvg_reml.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-4, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_Hep_4_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_4_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep4 <- full_results$LogFC
names(rankings_Hep4) <- full_results$Gene
rankings_Hep4 <- sort(rankings_Hep4, decreasing = TRUE)
plot(rankings_Hep4)
min(rankings_Hep4)
max(rankings_Hep4)


set.seed(1234)

kegg_legacy_res_Hep4 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep4,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep4 <- fgsea(pathways = reactome,
                           stats = rankings_Hep4,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_Hep4 <- fgsea(pathways = go,
                     stats = rankings_Hep4,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

Hep4_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep4[, padj < 0.05]), sum(kegg_legacy_res_Hep4[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep4[, padj < 0.05]), sum(reactome_res_Hep4[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep4[, padj < 0.05]), sum(go_res_Hep4[, pval < 0.05])))
rownames(Hep4_fgsea) <- c("adj.pval", "p.val")
Hep4_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_Hep4, title = "Hep-4 Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"Hep4_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_Hep4, title = "Hep-4 Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"Hep4_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_Hep4, title = "Hep-4 Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"Hep4_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-4")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #19319 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_4_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-4, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hep_4_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```

## f. Hep-5
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-5")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #22983 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# Subset Seurat object to only HVGs
so_celltype_hvg <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype_hvg) <- "RNA" 
```

### i. NEBULA
```{r}
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)

end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_hvg_reml.csv"))
# full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
#   dplyr::select(-X) %>% 
#   clean_names() %>% 
#   dplyr::rename(`logFC_steatosis_catHigh Steatosis (2+3)`=log_fc_steatosis_cat_high_steatosis_2_3,
#                 PValue10=p_value10)

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-5, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_Hep_5_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_5_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hep5 <- full_results$LogFC
names(rankings_Hep5) <- full_results$Gene
rankings_Hep5 <- sort(rankings_Hep5, decreasing = TRUE)
plot(rankings_Hep5)
min(rankings_Hep5)
max(rankings_Hep5)


set.seed(1234)

kegg_legacy_res_Hep5 <- fgsea(pathways = kegg_legacy,
                              stats = rankings_Hep5,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_Hep5 <- fgsea(pathways = reactome,
                           stats = rankings_Hep5,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_Hep5 <- fgsea(pathways = go,
                     stats = rankings_Hep5,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

Hep5_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hep5[, padj < 0.05]), sum(kegg_legacy_res_Hep5[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_Hep5[, padj < 0.05]), sum(reactome_res_Hep5[, pval < 0.05])),
                         "GO"=c(sum(go_res_Hep5[, padj < 0.05]), sum(go_res_Hep5[, pval < 0.05])))
rownames(Hep5_fgsea) <- c("adj.pval", "p.val")
Hep5_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_Hep5, title = "Hep-5 Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"Hep5_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_Hep5, title = "Hep-5 Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"Hep5_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_Hep5, title = "Hep-5 Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"Hep5_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-5")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #19319 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_5_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-5, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_Hep_5_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```

## g. dHep
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #11300 genes
ncol(so_celltype) #22983 nuclei

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# Subset Seurat object to only HVGs
so_celltype_hvg <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype_hvg) <- "RNA" 
```

### i. NEBULA
```{r}
counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)

end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 
# end_time <- Sys.time()
# print(end_time - start_time)

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_hvg_reml.csv"))
# full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
#   dplyr::select(-X) %>% 
#   clean_names() %>% 
#   dplyr::rename(`logFC_steatosis_catHigh Steatosis (2+3)`=log_fc_steatosis_cat_high_steatosis_2_3,
#                 PValue10=p_value10)

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype_hvg)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_steatosis_catHigh Steatosis (2+3)`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# max <- 3.1
min <- min(full_results$`logFC_steatosis_catHigh Steatosis (2+3)`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "dHep, Unadjusted (REML)",
    x = "logFC",
    y = "-log10(P-Value)",
    color = "LogFC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hepatocytes_Steatosis_unadjusted_2000_hvg_reml.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()

png(fs::path(dir.results, "Plot_NEBULA_dHep_Steatosis_unadjusted_2000_hvg.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_dHep_Steatosis_unadjusted_2000_hvg_reml.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_dHep <- full_results$LogFC
names(rankings_dHep) <- full_results$Gene
rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
plot(rankings_dHep)
min(rankings_dHep)
max(rankings_dHep)


set.seed(1234)

kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                              stats = rankings_dHep,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_dHep <- fgsea(pathways = reactome,
                           stats = rankings_dHep,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_dHep <- fgsea(pathways = go,
                     stats = rankings_dHep,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                         "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
rownames(dHep_fgsea) <- c("adj.pval", "p.val")
dHep_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"dHep_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_dHep, title = "dHep Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"dHep_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_dHep, title = "dHep Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"dHep_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="dHep")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #28964 genes
Nuclei <- ncol(so_celltype) #19319 nuclei

# # Subset Seurat object to targeted genes
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features = target_genes)
DefaultAssay(so_celltype_hvg) <- "RNA"

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")


# With parallelization
# List of genes
genes_list <- rownames(counts_hvg)

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg, features = g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene)
    
    result <- nebula(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, ncore = 1,output_re = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_steatosis_catHigh Steatosis (2+3)`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_steatosis_catHigh Steatosis (2+3)`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_dHep_Steatosis_unadjusted_reml.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_steatosis_catHigh Steatosis (2+3)` - 1.96 * `se_steatosis_catHigh Steatosis (2+3)`,
    CI_Upper = `logFC_steatosis_catHigh Steatosis (2+3)` + 1.96 * `se_steatosis_catHigh Steatosis (2+3)`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_steatosis_catHigh Steatosis (2+3)`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_steatosis_catHigh Steatosis (2+3)`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "dHep, Unadjusted (REML)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot
ggsave(fs::path(dir.results, "NEBULA_Targeted_dHep_Steatosis_unadjusted_reml.jpeg"), dot_plot, width = 7, height = 6)

```


#5. Pseudotime Analysis 
##A. Hepatocytes
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 

#Make seurat object into a single cell experiment object
sce <- as.SingleCellExperiment(so_Hep)

# We set this minimum cluster size to 10 cells and define a gene as being “robustly expressed” if it has a simulated count of at least 3 reads.
#filter genes down to potential cell-type markers
# at least M (15) reads in at least N (15) cells
geneFilter <- apply(assays(sce)$counts,1,function(x){
  sum(x >= 3) >= 10
})
sce <- sce[geneFilter, ]

#Full quantile normalization, a well-established method which forces each cell to have the same distribution of expression values.
FQnorm <- function(counts){
  rk <- apply(counts,2,rank,ties.method='min')
  counts.sort <- apply(counts,2,sort)
  refdist <- apply(counts.sort,1,median)
  norm <- apply(rk,2,function(r){ refdist[r] })
  rownames(norm) <- rownames(counts)
  return(norm)
}
assays(sce)$norm <- FQnorm(assays(sce)$counts)

#Dimensionality reduction using PCA
# pca <- prcomp(t(log1p(assays(sce)$norm)), scale. = FALSE)
####
library(irlba)
pca <- irlba(t(log1p(assays(sce)$norm)), nv = 50, center = TRUE, scale = FALSE)
# rd1 <- pca$u[, 1:2]  # Note: $u instead of $x
# rownames(rd1) <- colnames(sce)
# colnames(rd1) <- c("PC1", "PC2")

# Use more PCs (e.g., first 10, 20, or even all 50)
# rd1 <- pca$u[, 1:10]  # Use first 10 PCs
# or
rd1 <- pca$u[, 1:15]  # Use first 20 PCs
# or
# rd1 <- pca$u  # Use all 50 PCs

rownames(rd1) <- colnames(sce)
colnames(rd1) <- paste0("PC", 1:ncol(rd1))

# Add to SingleCellExperiment object
reducedDim(sce, "PCA") <- rd1

# # Check variance explained by each PC
# var_explained <- pca$d^2 / sum(pca$d^2)
# cumsum_var <- cumsum(var_explained)
# 
# # Plot to visualize
# plot(1:50, cumsum_var, type = "b", 
#      xlab = "Number of PCs", 
#      ylab = "Cumulative Variance Explained",
#      main = "Scree Plot")
# abline(h = 0.8, col = "red", lty = 2)  # 80% variance line
# 
# # Find number of PCs for desired variance (e.g., 80%)
# n_pcs <- which(cumsum_var >= 0.8)[1]
# print(paste("Need", n_pcs, "PCs to explain 80% variance"))
# 
# # Calculate individual variance for each PC
# var_explained <- (pca$d^2) / sum(pca$d^2) * 100
# 
# # Plot individual variance (traditional elbow plot)
# plot(1:30, var_explained[1:30], 
#      type = "b", 
#      pch = 19,
#      xlab = "Principal Component", 
#      ylab = "% Variance Explained (Individual)",
#      main = "Traditional Elbow Plot")
# 
# # This will show where each PC's contribution drops off


####
# rd1 <- pca$x[,1:2]

#Plot pca
pdf(fs::path(dir.results,"PCA_Slingshot.pdf"),width=10,height=10)
plot(rd1, col = rgb(0,0,0,.5), pch=16, asp = 1)
dev.off()

# Basic pairs plot for first few PCs
pairs(rd1[, 1:6], 
      col = rgb(0,0,0,.5), 
      pch = 16,
      cex = 0.3,
      main = "First 6 Principal Components")

# Or with color by cluster
pairs(rd1[, 1:6], 
      col = as.factor(colData(sce)$your_cluster_column), 
      pch = 16,
      cex = 0.3)

# Add PCA to your SCE object first
reducedDim(sce, "PCA") <- rd1

# Method 1: k-means clustering
set.seed(123)
k <- 8  # Choose number of clusters based on your data
kmeans_clusters <- kmeans(rd1, centers = k)$cluster
colData(sce)$kmeans_cluster <- as.factor(kmeans_clusters)

# Method 2: Graph-based clustering (recommended for scRNA-seq)
library(scran)
library(igraph)

# Build shared nearest neighbor graph
snn.gr <- buildSNNGraph(sce, use.dimred = "PCA", k = 20)

# Perform Louvain clustering
clusters <- cluster_louvain(snn.gr)$membership
colData(sce)$clusters <- as.factor(clusters)

print(paste("Found", length(unique(clusters)), "clusters"))
print(table(clusters))

# Plot with cluster colors
plot(rd1[, 1:2], 
     col = colData(sce)$clusters,
     pch = 16,
     main = "PCA with clusters",
     xlab = "PC1", ylab = "PC2")

# Add cluster labels
cluster_centers <- aggregate(rd1[, 1:2], 
                             by = list(colData(sce)$clusters), 
                             FUN = mean)
text(cluster_centers[,2], cluster_centers[,3], 
     labels = cluster_centers[,1], 
     cex = 1.5, font = 2)

# Create a color palette for 11 clusters
colors_11 <- c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", 
               "#FFFF33", "#A65628", "#F781BF", "#999999", "#66C2A5", "#FC8D62")

# Plot with cluster colors
plot(rd1[, 1:2], 
     col = colors_11[clusters],
     pch = 16,
     cex = 0.5,  # Smaller points since you have many cells
     main = "PCA with 11 clusters",
     xlab = "PC1", ylab = "PC2")

# Add legend
legend("topright", 
       legend = 1:11,
       col = colors_11,
       pch = 16,
       title = "Clusters",
       cex = 0.8)

# Plot points
plot(rd1[, 1:2], 
     col = colors_11[clusters],
     pch = 16,
     cex = 0.3,
     main = "PCA with 11 clusters (n = 104,299 cells)",
     xlab = paste0("PC1 (", round(var_explained[1], 1), "% variance)"),
     ylab = paste0("PC2 (", round(var_explained[2], 1), "% variance)"))

# Calculate and add cluster centroids
cluster_centers <- aggregate(rd1[, 1:2], 
                             by = list(clusters), 
                             FUN = mean)

# Add cluster numbers at centroids
text(cluster_centers[,2], cluster_centers[,3], 
     labels = cluster_centers[,1], 
     cex = 1.2, 
     font = 2,
     bg = "white",
     col = "black")

# Add cluster sizes to legend
cluster_sizes <- table(clusters)
legend_labels <- paste0("Cluster ", 1:11, " (n=", cluster_sizes, ")")
legend("topright", 
       legend = legend_labels,
       col = colors_11,
       pch = 16,
       cex = 0.6,
       ncol = 2)  # Two columns for space

# First, check if there's continuous variation vs discrete states
# Plot PC1 vs PC3, PC2 vs PC3, etc.
par(mfrow = c(2, 3))
pc_pairs <- list(c(1,3), c(2,3), c(1,4), c(2,4), c(3,4), c(4,5))

for (i in 1:length(pc_pairs)) {
  plot(rd1[, pc_pairs[[i]][1]], rd1[, pc_pairs[[i]][2]],
       col = colors_11[clusters],
       pch = 16, cex = 0.3,
       xlab = paste0("PC", pc_pairs[[i]][1]),
       ylab = paste0("PC", pc_pairs[[i]][2]))
}

# Try different k values for SNN graph
for (k_val in c(10, 30, 50)) {
  snn.gr <- buildSNNGraph(sce, use.dimred = "PCA", k = k_val)
  clusters_test <- cluster_louvain(snn.gr)$membership
  
  print(paste("k =", k_val, "gives", length(unique(clusters_test)), "clusters"))
  
  # Plot to see if separation improves
  plot(rd1[, 1:2], 
       col = rainbow(length(unique(clusters_test)))[clusters_test],
       pch = 16, cex = 0.3,
       main = paste("k =", k_val))
}

# # Try different clustering resolutions with Leiden
# library(leiden)
# for (res in c(0.5, 1, 1.5, 2)) {
#     clusters_leiden <- leiden(snn.gr, resolution = res)
#     print(paste("Resolution", res, "gives", length(unique(clusters_leiden)), "clusters"))
# }

# Use k=10 clustering since it shows the clearest structure
snn.gr <- buildSNNGraph(sce, use.dimred = "PCA", k = 10)
clusters_k10 <- cluster_louvain(snn.gr)$membership
colData(sce)$clusters <- as.factor(clusters_k10)

# The yellow cluster (likely cluster 1) might be your starting point
table(clusters_k10)

# Run slingshot - let it discover the trajectory
sce <- slingshot(sce, 
                 clusterLabels = 'clusters',
                 reducedDim = 'PCA',
                 start.clus = 1,  # Yellow cluster as start (adjust based on your biology)
                 omega = TRUE,
                 extend = 'y')

# Visualize the trajectory
colors_12 <- c("#FFFF00", "#1CE6FF", "#FF34FF", "#FF4A46", "#008941", "#006FA6", 
               "#A30059", "#FFDBE5", "#7A4900", "#0000A6", "#63FFAC", "#B79762")

plot(rd1[, 1:2], 
     col = colors_12[clusters_k10],
     pch = 16, cex = 0.3,
     main = "Slingshot trajectory on hepatocyte gradient")

# Add trajectory lines
lines(SlingshotDataSet(sce), lwd = 3, col = 'black')

# Use fewer clusters for a cleaner trajectory
set.seed(123)
simple_clusters <- kmeans(rd1, centers = 5)$cluster
colData(sce)$simple_clusters <- as.factor(simple_clusters)

# Visualize the simpler clustering
plot(rd1[, 1:2], 
     col = rainbow(5)[simple_clusters],
     pch = 16, cex = 0.3,
     main = "Simplified clustering (k=5)")

# Force a simpler trajectory
sce_clean <- slingshot(sce, 
                       clusterLabels = 'simple_clusters',
                       reducedDim = 'PCA',
                       omega = FALSE,  # Stricter curve fitting
                       extend = 'n',   # Don't extend to disconnected clusters
                       shrink = 1,     # Keep curves close to cluster centers
                       thresh = 0.001) # Stricter convergence

# Plot the cleaner result
plot(rd1[, 1:2], 
     col = rainbow(5)[simple_clusters],
     pch = 16, cex = 0.3,
     main = "Simplified trajectory")
lines(SlingshotDataSet(sce_clean), lwd = 3, col = 'black')

# See how many lineages you have with the simplified approach
sds_simple <- SlingshotDataSet(sce_clean)
lineages_simple <- slingLineages(sds_simple)
print(paste("Number of lineages:", length(lineages_simple)))
print(lineages_simple)

# Extract just the first lineage curve
sds <- SlingshotDataSet(sce_clean)
curves <- slingCurves(sds)

# Plot your data
plot(rd1[, 1:2], 
     col = rainbow(5)[simple_clusters],
     pch = 16, cex = 0.3,
     main = "First lineage only")

# Add only the first curve
lines(curves[[2]]$s, lwd = 4, col = 'black')

# First recreate the plot
plot(rd1[, 1:2], 
     col = rainbow(5)[simple_clusters],
     pch = 16, cex = 0.3,
     main = "First lineage only")

# Add the trajectory curve
lines(curves[[2]]$s, lwd = 4, col = 'black')

# Calculate cluster centers
cluster_centers <- aggregate(rd1[, 1:2], 
                             by = list(simple_clusters), 
                             FUN = mean)
names(cluster_centers)[1] <- "cluster"

# Add cluster numbers
text(cluster_centers[,2], cluster_centers[,3], 
     labels = cluster_centers$cluster, 
     cex = 1.5, 
     font = 2,
     bg = "white",
     col = "black")

# Define lineage clusters
lineage_clusters <- c(4, 2, 5, 3)

# Create a subset of cells that belong to lineage clusters
cells_in_lineage <- which(simple_clusters %in% lineage_clusters)

# Create subset data
rd1_lineage <- rd1[cells_in_lineage, ]
clusters_lineage <- simple_clusters[cells_in_lineage]

png(fs::path(dir.results,"PCA_Slingshot_Lineage2.png"),width=2000,height=2000,res=300)
# Plot only lineage cells
plot(rd1_lineage[, 1:2], 
     col = rainbow(5)[clusters_lineage],
     pch = 16, cex = 0.3,
     main = "Lineage 4 → 5 → 2 → 3",
     xlab = "PC1", ylab = "PC2")

# Add trajectory line (you might need to recalculate for subset)
lines(curves[[2]]$s, lwd = 4, col = 'black')

# Add cluster centers for lineage clusters only
cluster_centers_lineage <- aggregate(rd1_lineage[, 1:2], 
                                     by = list(clusters_lineage), 
                                     FUN = mean)
text(cluster_centers_lineage[,2], cluster_centers_lineage[,3], 
     labels = cluster_centers_lineage[,1], 
     cex = 1.5, font = 2, bg = "white")

# Add legend
cluster_sizes <- table(clusters_lineage)
legend_text <- paste0("Cluster ", names(cluster_sizes), " (n=", cluster_sizes, ")")
legend("topright", 
       legend = legend_text,
       col = rainbow(5)[as.numeric(names(cluster_sizes))],
       pch = 16,
       title = "Clusters in Lineage",
       cex = 0.8,
       bg = "white")
dev.off()

# Assuming your Seurat cell type info is in metadata
# You'll need to match the cell names between SCE and Seurat

# Get cell types (adjust column name as needed)
cell_types <- colData(sce)$celltype  # or whatever your column is called

# If you need to transfer from Seurat object:
# cell_types <- seurat_obj@meta.data$celltype[match(colnames(sce), colnames(seurat_obj))]

# Create plot colored by cell type instead of clusters
cell_types_lineage <- cell_types[cells_in_lineage]

# Define colors for cell types
unique_types <- unique(cell_types_lineage)
type_colors <- rainbow(length(unique_types))
names(type_colors) <- unique_types

plot(rd1_lineage[, 1:2], 
     col = type_colors[cell_types_lineage],
     pch = 16, cex = 0.3,
     main = "Lineage colored by cell type",
     xlab = "PC1", ylab = "PC2")

# Add legend for cell types
legend("topright", 
       legend = names(type_colors),
       col = type_colors,
       pch = 16,
       title = "Cell Types",
       cex = 0.7,
       bg = "white")

# Create a two-panel plot
png(fs::path(dir.results,"Slingshot_Hepatocytes.png"),width=4000,height=2000,res=300)
par(mfrow = c(1, 2))
# Panel 1: Colored by clusters
plot(rd1_lineage[, 1:2],
     col = rainbow(5)[clusters_lineage],
     pch = 16, cex = 0.3,
     main = "Colored by Clusters")
text(cluster_centers_lineage[,2], cluster_centers_lineage[,3],
     labels = cluster_centers_lineage[,1],
     cex = 1.5, font = 2, bg = "white")

# Panel 2: Colored by cell types
plot(rd1_lineage[, 1:2], 
     col = type_colors[cell_types_lineage],
     pch = 16, cex = 0.3,
     main = "Colored by Cell Types")

# Add cell type labels at centroids
type_centers <- aggregate(rd1_lineage[, 1:2], 
                          by = list(cell_types_lineage), 
                          FUN = mean)
text(type_centers[,2], type_centers[,3],
     labels = type_centers[,1],
     cex = 0.8, font = 2, bg = "white")

dev.off()

# Create a table showing cell type composition per cluster
cluster_celltype_table <- table(clusters_lineage, cell_types_lineage)
print(cluster_celltype_table)

# Convert to proportions to see percentages
prop_table <- prop.table(cluster_celltype_table, margin = 1) * 100
print(round(prop_table, 1))
###############################################################################

library(uwot)
rd2 <- uwot::umap(t(log1p(assays(sce)$norm)))
colnames(rd2) <- c('UMAP1', 'UMAP2')

pdf(fs::path(dir.results,"UMAP_Slingshot.pdf"),width=10,height=10)
plot(rd2, col = rgb(0,0,0,.5), pch=16, asp = 1)
dev.off()

reducedDims(sce) <- SimpleList(PCA = rd1, UMAP = rd2)

#Clustering cells
library(mclust, quietly = TRUE)
cl1 <- Mclust(rd1)$classification
colData(sce)$GMM <- cl1

library(RColorBrewer)
pdf(fs::path(dir.results,"PCA_Cluster_Plot.pdf"),width=10,height=10)
plot(rd1, col = brewer.pal(9,"Set1")[cl1], pch=16, asp = 1)
dev.off()

cl2 <- kmeans(rd1, centers = 4)$cluster
colData(sce)$kmeans <- cl2
pdf(fs::path(dir.results,"PCA_Cluster_Plot2.pdf"),width=10,height=10)
plot(rd1, col = brewer.pal(9,"Set1")[cl2], pch=16, asp = 1)
dev.off()

#Perform Slingshot
sce_gmm <- slingshot(sce, clusterLabels = 'GMM', reducedDim = 'PCA')

colData(sce)$celltype <- so_Hep$celltype
sce_celltype <- slingshot(sce, clusterLabels = 'celltype', reducedDim = 'PCA')

summary(sce_celltype$slingPseudotime_1)
library(grDevices)
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce_celltype$slingPseudotime_1, breaks=100)]

pdf(fs::path(dir.results,"PCA_Cluster_Lineage.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$PCA, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce_celltype), lwd=2, col='black')
dev.off()

pdf(fs::path(dir.results,"PCA_Cluster_Lineage2.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$PCA, col = brewer.pal(9,'Set1')[sce_celltype$GMM], pch=16, asp = 1)
lines(SlingshotDataSet(sce_celltype), lwd=2, type = 'lineages', col = 'black')
dev.off()

pdf(fs::path(dir.results,"PCA_Cluster_Lineage3.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$PCA, asp=1, col = 'grey75', pch = 16)
points(reducedDims(sce_celltype)$PCA, col = hcl.colors(100)[cut(slingPseudotime(sce_celltype)[,1], 100)], pch=16)
legend('topleft', title = 'Lineage 1', col = hcl.colors(4), legend=c('0%','25%','50%','100%'), pch=16)
dev.off()

pca_df <- as.data.frame(reducedDims(sce_celltype)$PCA)
pca_df$celltype <- colData(sce_celltype)$celltype
pca_df$pseudotime <- slingPseudotime(sce_celltype)[,1]  # choose a lineage if >1

# Optional: get curve
curves <- slingCurves(sce_celltype)
pca_df$celltype <- factor(pca_df$celltype, levels = c("Hep-1", "Hep-2", "Hep-3", "Hep-4", "Hep-5","dHep","Hep/Immune"))
slingshot::slingLineages(sce_celltype)
# Plot
ggplot(pca_df, aes(x = PC1, y = PC2, color = celltype)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_path(data = as.data.frame(curves[[1]]$s), aes(x = PC1, y = PC2), color = "black", size = 1.2) +
  labs(title = "Hepatocyte cell types along Slingshot trajectory") +
  theme_bw() + 
  theme(panel.grid = element_blank()) + 
  labs(color = NULL)

# temp_file <- tempfile(fileext = ".jpeg") # need to create a temporary file
# ggsave(filename = temp_file, width = 7, height = 5)
# s3$upload_file(temp_file, "attempt", "slingshot/attempt_pca_pt_slingshot.jpeg")


#Use umap
#Perform Slingshot
sce_gmm <- slingshot(sce, clusterLabels = 'GMM', reducedDim = 'UMAP')

colData(sce)$celltype <- so_Hep$celltype
sce_celltype <- slingshot(sce, clusterLabels = 'celltype', reducedDim = 'UMAP')

summary(sce_celltype$slingPseudotime_1)
library(grDevices)
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce_celltype$slingPseudotime_1, breaks=100)]

pdf(fs::path(dir.results,"UMAP_Cluster_Lineage.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce_celltype), lwd=2, col='black')
dev.off()

pdf(fs::path(dir.results,"UMAP_Cluster_Lineage2.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$UMAP, col = brewer.pal(9,'Set1')[sce_celltype$GMM], pch=16, asp = 1)
lines(SlingshotDataSet(sce_celltype), lwd=2, type = 'lineages', col = 'black')
dev.off()

pdf(fs::path(dir.results,"UMAP_Cluster_Lineage3.pdf"),width=10,height=10)
plot(reducedDims(sce_celltype)$UMAP, asp=1, col = 'grey75', pch = 16)
points(reducedDims(sce_celltype)$UMAP, col = hcl.colors(100)[cut(slingPseudotime(sce_celltype)[,1], 100)], pch=16)
legend('topleft', title = 'Lineage 1', col = hcl.colors(4), legend=c('0%','25%','50%','100%'), pch=16)
dev.off()


# Your existing code setup
colData(sce)$celltype <- so_Hep$celltype
sce_celltype <- slingshot(sce, clusterLabels = 'celltype', reducedDim = 'UMAP')

# Get UMAP coordinates
umap_coords <- reducedDims(sce_celltype)$UMAP
celltypes <- colData(sce_celltype)$celltype

# =============================================================================
# METHOD 1: Add celltype labels at centroids (RECOMMENDED)
# =============================================================================

# Calculate centroids for each celltype
centroids <- aggregate(umap_coords, by = list(celltype = celltypes), FUN = mean)
rownames(centroids) <- centroids$celltype
centroids <- centroids[, -1]  # Remove the celltype column

# Your existing plot with celltype labels added
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce_celltype$slingPseudotime_1, breaks=100)]

pdf(fs::path(dir.results,"UMAP_Cluster_Lineage_with_labels.pdf"), width=10, height=10)
plot(umap_coords, col = plotcol, pch=16, asp = 1,
     xlab = "UMAP1", ylab = "UMAP2", 
     main = "UMAP - Slingshot Trajectory with Cell Type Labels")
lines(SlingshotDataSet(sce_celltype), lwd=2, col='black')

# Add celltype labels at centroids
text(centroids, labels = rownames(centroids), 
     col = "black", font = 2, cex = 1.2,
     bg = "white", adj = c(0.5, 0.5))

dev.off()
```

##a. Prepare for Analysis 
```{r}
## Make SO into SCE object for pseudotime analysis
sce_HEP <- as.SingleCellExperiment(subset(so_liver_sn,celltype2=="Hep"), assay = "RNA")

#Barcharts by Steatosis Groups
n_low <- nrow(so_liver_sn@meta.data %>% filter(celltype2=="Hep" & steatosis_cat=="Low Steatosis (0+1)"))
n_high <- nrow(so_liver_sn@meta.data %>% filter(celltype2=="Hep" & steatosis_cat=="High Steatosis (2+3)"))

# By PT subtypes (by celltype)
cellcount<- so_liver_sn@meta.data %>% 
  filter(celltype2=="Hep") %>%
  dplyr::group_by(steatosis_cat, celltype) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(n = case_when(steatosis_cat == "Low Steatosis (0+1)" ~ n_low, steatosis_cat == "High Steatosis (2+3)" ~ n_high),
                ratio = count / n) %>% ungroup() %>%
  group_by(celltype) %>%
  dplyr::mutate(proportion = ratio/sum(ratio)) %>%
  dplyr::select(proportion, steatosis_cat, celltype) %>%
  ggplot(aes(x= celltype, y= proportion, fill = steatosis_cat)) + 
  geom_bar(stat = "identity", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Steatosis Grade") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))

cellcount
png(fs::path(dir.results, "Barchart_Hep_Cells_by_Steatosis_Cat.png"),
    width = 2500, height = 2000, res = 300)
print(cellcount)
dev.off()

n_hep1 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-1"))
n_hep2 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-2"))
n_hep3 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-3"))
n_hep4 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-4"))
n_hep5 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-5"))
n_dhep <- nrow(so_liver_sn@meta.data %>% filter(celltype == "dHep"))

# By PT subtypes (by celltype)
cellcount2 <- so_liver_sn@meta.data %>% 
  filter(!is.na(steatosis_cat)) %>%
  filter(celltype2 == "Hep") %>%
  dplyr::group_by(steatosis_cat, celltype) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(n = case_when(celltype == "Hep-1" ~ n_hep1, 
                              celltype == "Hep-2" ~ n_hep2,
                              celltype == "Hep-3" ~ n_hep3, 
                              celltype == "Hep-4" ~ n_hep4,
                              celltype == "Hep-5" ~ n_hep5,
                              celltype == "dHep" ~ n_dhep),
                ratio = count / n) %>% ungroup() %>%
  group_by(steatosis_cat) %>%
  dplyr::mutate(proportion = ratio/sum(ratio)) %>%
  dplyr::select(proportion, steatosis_cat, celltype) %>%
  ggplot(aes(x= steatosis_cat, y= proportion, fill = celltype)) + 
  geom_bar(stat = "identity", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = NULL,
       fill = "celltype") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold", size = 15),
        text = element_text(size = 20)) +
  ggtitle("Proportion of Cells by Steatosis Category") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

cellcount2
png(fs::path(dir.results, "Barchart_Hep_Cells_by_Steatosis.png"),
    width = 1500, height = 2500, res = 300)
print(cellcount2)
dev.off()

#By ALT
so_liver_sn$alt_cat <- factor(so_liver_sn$alt)
n_hep1 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-1"))
n_hep2 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-2"))
n_hep3 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-3"))
n_hep4 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-4"))
n_hep5 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-5"))
n_dhep <- nrow(so_liver_sn@meta.data %>% filter(celltype == "dHep"))

# By PT subtypes (by celltype)
cellcount_alt <- so_liver_sn@meta.data %>% 
  filter(!is.na(alt_cat)) %>%
  filter(celltype2 == "Hep") %>%
  dplyr::group_by(alt_cat, celltype) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(n = case_when(celltype == "Hep-1" ~ n_hep1, 
                              celltype == "Hep-2" ~ n_hep2,
                              celltype == "Hep-3" ~ n_hep3, 
                              celltype == "Hep-4" ~ n_hep4,
                              celltype == "Hep-5" ~ n_hep5,
                              celltype == "dHep" ~ n_dhep),
                ratio = count / n) %>% ungroup() %>%
  group_by(alt_cat) %>%
  dplyr::mutate(proportion = ratio/sum(ratio)) %>%
  dplyr::select(proportion, alt_cat, celltype) %>%
  ggplot(aes(x= alt_cat, y= proportion, fill = celltype)) + 
  geom_bar(stat = "identity", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = NULL,
       fill = "celltype") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold", size = 15),
        text = element_text(size = 20)) +
  ggtitle("ALT") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

cellcount_alt
png(fs::path(dir.results, "Barchart_Hep_Cells_by_ALT.png"),
    width = 2500, height = 2000, res = 300)
print(cellcount_alt)
dev.off()

#By AST
so_liver_sn$ast_cat <- factor(so_liver_sn$ast)
n_hep1 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-1"))
n_hep2 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-2"))
n_hep3 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-3"))
n_hep4 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-4"))
n_hep5 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-5"))
n_dhep <- nrow(so_liver_sn@meta.data %>% filter(celltype == "dHep"))

# By Hep subtypes (by celltype)
cellcount_ast <- so_liver_sn@meta.data %>% 
  filter(!is.na(ast_cat)) %>%
  filter(celltype2 == "Hep") %>%
  dplyr::group_by(ast_cat, celltype) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(n = case_when(celltype == "Hep-1" ~ n_hep1, 
                              celltype == "Hep-2" ~ n_hep2,
                              celltype == "Hep-3" ~ n_hep3, 
                              celltype == "Hep-4" ~ n_hep4,
                              celltype == "Hep-5" ~ n_hep5,
                              celltype == "dHep" ~ n_dhep),
                ratio = count / n) %>% ungroup() %>%
  group_by(ast_cat) %>%
  dplyr::mutate(proportion = ratio/sum(ratio)) %>%
  dplyr::select(proportion, ast_cat, celltype) %>%
  ggplot(aes(x= ast_cat, y= proportion, fill = celltype)) + 
  geom_bar(stat = "identity", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = NULL,
       fill = "celltype") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold", size = 15),
        text = element_text(size = 20)) +
  ggtitle("AST") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_Hep_Cells_by_AST.png"),
    width = 2500, height = 2000, res = 300)
print(cellcount_ast)
dev.off()

#By ggt
so_liver_sn$ggt_cat <- factor(so_liver_sn$ggt)
n_hep1 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-1"))
n_hep2 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-2"))
n_hep3 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-3"))
n_hep4 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-4"))
n_hep5 <- nrow(so_liver_sn@meta.data %>% filter(celltype == "Hep-5"))
n_dhep <- nrow(so_liver_sn@meta.data %>% filter(celltype == "dHep"))

# By PT subtypes (by celltype)
cellcount_ggt <- so_liver_sn@meta.data %>% 
  filter(!is.na(ggt_cat)) %>%
  filter(celltype2 == "Hep") %>%
  dplyr::group_by(ggt_cat, celltype) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(n = case_when(celltype == "Hep-1" ~ n_hep1, 
                              celltype == "Hep-2" ~ n_hep2,
                              celltype == "Hep-3" ~ n_hep3, 
                              celltype == "Hep-4" ~ n_hep4,
                              celltype == "Hep-5" ~ n_hep5,
                              celltype == "dHep" ~ n_dhep),
                ratio = count / n) %>% ungroup() %>%
  group_by(ggt_cat) %>%
  dplyr::mutate(proportion = ratio/sum(ratio)) %>%
  dplyr::select(proportion, ggt_cat, celltype) %>%
  ggplot(aes(x= ggt_cat, y= proportion, fill = celltype)) + 
  geom_bar(stat = "identity", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = NULL,
       fill = "celltype") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold", size = 15),
        text = element_text(size = 20)) +
  ggtitle("GGT") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_Hep_Cells_by_ggt.png"),
    width = 2500, height = 2000, res = 300)
print(cellcount_ggt)
dev.off()

#Marker genes of healthy hepatocytes: 
healthy_hepatocyte_genes <- c("ALB", "CYP3A4", "ARG1", "IGF1", "HNF4A", "APOE", "SLC10A2", "FASN", "ABCB1", "GLUL")

#Marker genes of adaptive/mal adaptive hepatocytes: 
adaptive_maladaptive_genes <- c("COL1A1", "ACTA2", "TNF", "IL6", "FASN", "CASP3", "SOD1", "CAT", "HGF", "PCNA")

# Healthy markers
DotPlot(so_Hep, features = healthy_hepatocyte_genes, group.by = "celltype") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Healthy Hepatocyte Marker Expression")

# Adaptive/maladaptive markers
DotPlot(so_Hep, features = adaptive_maladaptive_genes, group.by = "celltype") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Adaptive/Maladaptive Hepatocyte Marker Expression")

```

##b. Visualize 
###i. PCA
```{r}
#Filter to Hep Cells
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 


# Step 1: Prepare your Seurat object
so_Hep <- FindVariableFeatures(object = so_Hep)
so_Hep <- RunPCA(so_Hep, features = VariableFeatures(object = so_Hep),assay="RNA")
# so_Hep <- RunPCA(so_Hep, features = VariableFeatures(object = so_Hep))

# Find clusters using PCA
so_Hep <- FindNeighbors(so_Hep, dims = 1:10, reduction = "pca")
so_Hep <- FindClusters(so_Hep, resolution = 0.5)

#Visualize clusters
DimPlot(so_Hep, reduction = "pca", dims = c(1, 2), 
        group.by = "celltype", label = TRUE, label.size = 6) +
  labs(title = "PCA: PC1 vs PC2 - Clusters")

# Visualize clusters on PCA
DimPlot(so_Hep, 
        reduction = "pca", 
        dims = c(1, 2), group.by = "celltype",label = TRUE,raster=F)

#       label.size = 6) +
# labs(title = "PCA: PC1 vs PC2 - Cell Types")

```

###ii. UMAP
```{r, echo = F}
# so_liver_sn <- FindVariableFeatures(object = so_liver_sn)
# so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn),assay="RNA")
# ElbowPlot(so_liver_sn)
# 
# # # Find neighbors and clusters (again using integrated data)
# so_liver_sn <- FindNeighbors(so_liver_sn, assay = "RNA", dims = 1:20)
# so_liver_sn <- FindClusters(so_liver_sn, resolution = 0.5)
# 
# # Perform UMAP 
# #Print plot
# png(fs::path(dir.results, "UMAP_by_celltype.png"),
#     width = 4500, height = 3000, res = 300)
# p <- DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
#   ggtitle("UMAP Plot by Cell Type")
# print(p)
# dev.off()
# 
# 
# #Print plot
# png(fs::path(dir.results, "UMAP_by_Steatosis.png"),
#     width = 4500, height = 3000, res = 300)
# p <- DimPlot(
#   so_liver_sn,
#   reduction = "umap",
#   group.by = "steatosis_cat",
#   label = FALSE,
#   raster = FALSE
# ) +
#   scale_color_manual(values = c("darkblue","lightgray")) +
#   ggtitle("UMAP by Steatosis Status")
# print(p)
# dev.off()
# 
# #Barcharts of proportions
# cellcount <- so_liver_sn@meta.data
# prop_plot <- ggplot(data=cellcount,aes(StudyID, fill = celltype)) + 
#   geom_bar(stat = "count", position = "fill") +
#   theme_classic() +
#   labs(x = NULL,
#        y = "Proportion of Cells",
#        fill = "Cell type") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
#   theme(plot.title = element_text(hjust=0.5, face="bold"),
#         text = element_text(size = 20)) 
# # ggtitle("PT Cells") +
# # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
# png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
# print(prop_plot)
# dev.off()
# 
# prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype)) + 
#   geom_bar(stat = "count", position = "fill") +
#   theme_classic() +
#   labs(x = NULL,
#        y = "Proportion of Cells",
#        fill = "Cell Type") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
#   theme(plot.title = element_text(hjust=0.5, face="bold"),
#         text = element_text(size = 20)) 
# png(fs::path(dir.results, "Barchart_Steatosis_Cat_All_Cells.png"),width = 3000, height = 3000, res = 300)
# print(prop_plot)
# dev.off()

#Hep cells (Hep-1 thru dHep)
so_liver_sn
so_Hep <- subset(so_liver_sn, celltype2 == "Hep")
so_Hep
DefaultAssay(so_Hep) <- "RNA"
so_Hep <- NormalizeData(so_Hep)
so_Hep <- ScaleData(so_Hep)
so_Hep <- FindVariableFeatures(object = so_Hep)
# so_Hep <- RunPCA(so_Hep, features = VariableFeatures(object = so_Hep),assay="RNA")
ElbowPlot(so_Hep)

# # Find neighbors and clusters (again using integrated data)
so_Hep <- FindNeighbors(so_Hep, assay = "RNA", dims = 1:20)
so_Hep@graphs
so_Hep <- FindClusters(so_Hep, resolution = 0.5)
DefaultAssay(so_Hep) <- "RNA"
# Perform UMAP 
#Print plot
png(fs::path(dir.results, "UMAP_by_Hep_Celltypes.png"),
    width = 4000, height = 3000, res = 300)
p <- DimPlot(so_Hep, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")
print(p)
dev.off()


#Print plot
png(fs::path(dir.results, "UMAP_by_Steatosis_Hep.png"),
    width = 4000, height = 3000, res = 300)
p <- DimPlot(
  so_Hep,
  reduction = "umap",
  group.by = "steatosis_cat",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("darkblue","lightgray")) +
  ggtitle("UMAP by Steatosis Status")+
  theme(legend.position = "none")
print(p)
dev.off()

#Barcharts of proportions
cellcount <- so_Hep@meta.data
prop_plot <- ggplot(data=cellcount,aes(StudyID, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  # ggtitle("PT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_All_Participants_Hep_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(steatosis_cat, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_Steatosis_Cat_All_Cells.png"),width = 3000, height = 3000, res = 300)
print(prop_plot)
dev.off()


# so_Hep <- NormalizeData(so_Hep)
# so_Hep <- ScaleData(so_Hep)
# 
# so_Hep <- FindVariableFeatures(object = so_Hep)
# so_Hep <- RunPCA(so_Hep, features = VariableFeatures(object = so_Hep),assay="RNA")
# ElbowPlot(so_Hep)
# 
# # # Find neighbors and clusters (again using integrated data)
# so_Hep <- FindNeighbors(so_Hep, assay = "RNA", dims = 1:20)
# so_Hep <- FindClusters(so_Hep, resolution = 0.5)
# 
# so_Hep <- RunUMAP(so_Hep, dims = 1:20)
# so_Hep <- RunTSNE(so_Hep, dimred = "UMAP")
# 
DimPlot(object = so_Hep, reduction = "umap")
DimPlot(object = so_Hep, reduction = "umap", group.by = "steatosis_grade")
DimPlot(object = so_Hep, reduction = "umap", group.by = "celltype")

DimPlot(so_Hep, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")

umap_df <- as.data.frame(so_Hep@reductions$umap@cell.embeddings)
umap_df <- umap_df %>% 
  filter(UMAP_1 < 5) %>% 
  filter(UMAP_2 > -8)
umap_keep <- rownames(umap_df)
length(umap_keep)  # confirm how many cells are kept - 103031

so_Hep_filtered <- subset(so_Hep, cells = umap_keep)
nrow(so_Hep_filtered)
ncol(so_Hep_filtered)
# png(fs::path(dir.results, "UMAP_by_Hep_Filtered_5_neg8.png"),
# width = 4000, height = 3000, res = 300)
p <- DimPlot(so_Hep_filtered, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")
print(p)
# dev.off()

# png(fs::path(dir.results, "UMAP_by_Hep_Unfiltered.png"),
# width = 4000, height = 3000, res = 300)
p <- DimPlot(so_Hep, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")
# print(p)
# dev.off()

umap_df <- as.data.frame(so_Hep@reductions$umap@cell.embeddings)
umap_df <- umap_df %>% 
  filter(UMAP_1 < 4) %>% 
  filter(UMAP_2 > -7)
umap_keep <- rownames(umap_df)
length(umap_keep)

so_Hep_filtered <- subset(so_Hep, cells = umap_keep)
nrow(so_Hep_filtered)
ncol(so_Hep_filtered)
# png(fs::path(dir.results, "UMAP_by_Hep_Filtered_5_neg8.png"),
# width = 4000, height = 3000, res = 300)
p <- DimPlot(so_Hep_filtered, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")
print(p)
# dev.off()

umap_df <- as.data.frame(so_Hep@reductions$umap@cell.embeddings)
umap_df <- umap_df %>% 
  filter(UMAP_1 < 4.6) %>% 
  filter(UMAP_2 > -7)
umap_keep <- rownames(umap_df)
length(umap_keep)

so_Hep_filtered <- subset(so_Hep, cells = umap_keep)
nrow(so_Hep_filtered)
ncol(so_Hep_filtered)
# png(fs::path(dir.results, "UMAP_by_Hep_Filtered_5_neg8.png"),
# width = 4000, height = 3000, res = 300)
p <- DimPlot(so_Hep_filtered, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type")+
  theme(legend.position = "none")
print(p)

# png(fs::path(dir.results, "UMAP_by_Hep_Celltypes2.png"),
# width = 4000, height = 3000, res = 300)
# 
# so_Hep <- so_Hep[, umap_keep]
# DimPlot(object = so_Hep, reduction = "umap")
# DimPlot(object = so_Hep, reduction = "umap", group.by = "steatosis_cat")
# DimPlot(object = so_Hep, reduction = "umap", group.by = "celltype")
# 
# #Print plot
# png(fs::path(dir.results, "UMAP_by_Hep_Celltypes2.png"),
# width = 4000, height = 3000, res = 300)
# p <- DimPlot(so_Hep, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
#   ggtitle("UMAP Plot by Cell Type")+
#    theme(legend.position = "none")
# print(p)
# dev.off()
# 
# 
# #Print plot
# png(fs::path(dir.results, "UMAP_by_Steatosis_Hep2.png"),
#     width = 4000, height = 3000, res = 300)
# p <- DimPlot(
#   so_Hep,
#   reduction = "umap",
#   group.by = "steatosis_cat",
#   label = FALSE,
#   raster = FALSE
# ) +
#   scale_color_manual(values = c("darkblue","lightgray")) +
#   ggtitle("UMAP by Steatosis Status")+
#    theme(legend.position = "none")
# print(p)
# dev.off()
```

##c. Totem Clustering
```{r}
# # Totem clustering for trajectory analysis
so_Hep <- subset(so_liver_sn, celltype2 == "Hep")
DefaultAssay(so_Hep) <- "RNA"

so_Hep <- FindVariableFeatures(so_Hep, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_Hep)


so_Hep <- NormalizeData(so_Hep)
so_Hep <- ScaleData(so_Hep)
sce_HEP <- as.SingleCellExperiment(so_Hep)
gc()
sce_HEP <- PrepareTotem(sce_HEP)
sce_HEP <- RunDimRed(object = sce_HEP,
                     dim.red.method = "pca",
                     dim.red.features = hvgs,
                     dim.reduction.par.list = list(ndim=5))
# 
## where so@assays$RNA@counts is the normalized expression count
# gc()
# dim_red <- dimred_pca(t(subset(so, generaltype == "PT" & celltype != "PT_lowQuality")@assays$RNA@counts), ndim=2)
dim_red <- reducedDim(sce_HEP, type = "pca")
# 
sce_HEP <- RunClustering(sce_HEP,
                         k.range = 3:20,
                         min.cluster.size = 5,
                         N.clusterings=10000)
gc()
viz_cell <- VizCellConnectivity(sce_HEP,viz.dim.red = dim_red)

# 
pushover(message = "done w/ VizCellConnectivity")

sce_HEP <- SelectClusterings(sce_HEP,selection.method = 1,
                             selection.N.models = 10,
                             selection.stratified=FALSE,
                             prior.clustering = NULL)
VizMST(sce_HEP,clustering.names = ReturnTrajNames(sce_HEP),viz.dim.red = dim_red)
# VizMST(sce_HEP,clustering = so_Hep$celltype,viz.dim.red = dim_red)

ReturnMSTNetwork(sce_HEP,clustering.name = "3.367")
sce_HEP <- RunSmoothing(sce_HEP)

VizClustering(sce_HEP,clustering = so_Hep$celltype,viz.dim.red = dim_red)


# Step 1: Get cell types with names
celltypes <- so_Hep$celltype
names(celltypes) <- colnames(so_Hep)  # make sure they have cell names

# Step 2: Subset to match sce_HEP
common_cells <- intersect(colnames(sce_HEP), names(celltypes))
celltypes <- celltypes[common_cells]

# Step 3: Make sure the order matches sce_HEP
celltypes <- celltypes[colnames(sce_HEP)]
celltypes <- as.factor(celltypes)
all(names(celltypes) == colnames(sce_HEP))  # should be TRUE
# If not, fix it:
celltypes <- celltypes[colnames(sce_HEP)]

# Assume dim_red is already defined like this:
# dim_red <- reducedDims(sce_HEP)[["<your-dim-reduction>"]]  # already done

# Check cell names in both
head(rownames(dim_red))          # cell names from dim_red
head(names(celltypes))           # cell names from celltypes

# Ensure both are character vectors of matching cell IDs
common_cells <- intersect(rownames(dim_red), names(celltypes))

# Subset both to shared cells
dim_red <- dim_red[common_cells, , drop = FALSE]
celltypes <- celltypes[common_cells]

# Confirm order
celltypes <- celltypes[rownames(dim_red)]

# Confirm 1:1 matching
stopifnot(all(names(celltypes) == rownames(dim_red)))
table(is.na(celltypes))  # Should show no NAs
length(celltypes) == nrow(dim_red)  # Should be TRUE

length(celltypes)          # should equal
nrow(dim_red)              # the number of rows in dim_red
# Remove NA entries
valid <- !is.na(celltypes)
celltypes <- celltypes[valid]
dim_red <- dim_red[valid, , drop = FALSE]
sce_HEP <- sce_HEP[, rownames(dim_red)]

# Step 4: Visualize
VizClustering(sce_HEP, clustering = celltypes, viz.dim.red = dim_red)
VizMST(sce_HEP, clustering = celltypes, viz.dim.red = dim_red)

# Debug your slingshot clustering visualization

# Step 1: Check dimensions and data integrity
cat("=== Debugging Data Dimensions ===\n")
cat("Original celltypes length:", length(celltypes), "\n")
cat("sce_HEP columns:", ncol(sce_HEP), "\n")
cat("dim_red rows:", nrow(dim_red), "\n")

# Check for NA values
cat("NA values in celltypes:", sum(is.na(celltypes)), "\n")

# Step 2: Ensure all dimensions match
cat("\n=== Checking Dimension Alignment ===\n")

# Make sure all objects have the same number of cells
n_cells_sce <- ncol(sce_HEP)
n_cells_dimred <- nrow(dim_red)
n_celltypes <- length(celltypes)

cat("Cells in sce_HEP:", n_cells_sce, "\n")
cat("Cells in dim_red:", n_cells_dimred, "\n")
cat("Cells in celltypes:", n_celltypes, "\n")

# Check if dimensions match
if (n_cells_sce != n_cells_dimred || n_cells_sce != n_celltypes) {
  cat("WARNING: Dimension mismatch detected!\n")
}

# Step 3: Check clustering integrity
cat("\n=== Checking Clustering Integrity ===\n")
cat("Unique cell types:", length(unique(celltypes)), "\n")
cat("Cell type distribution:\n")
print(table(celltypes))

# Check for empty or problematic groups
empty_groups <- names(table(celltypes))[table(celltypes) == 0]
if (length(empty_groups) > 0) {
  cat("Empty groups found:", empty_groups, "\n")
}

# Step 4: Fix the data alignment
cat("\n=== Fixing Data Alignment ===\n")

# Method 1: If you have cell names/barcodes, use them for alignment
if (!is.null(colnames(sce_HEP)) && !is.null(rownames(dim_red))) {
  # Find common cells
  common_cells <- intersect(colnames(sce_HEP), rownames(dim_red))
  cat("Common cells found:", length(common_cells), "\n")
  
  if (length(common_cells) > 0) {
    # Subset to common cells
    sce_HEP_aligned <- sce_HEP[, common_cells]
    dim_red_aligned <- dim_red[common_cells, , drop = FALSE]
    
    # If celltypes has names, align by names
    if (!is.null(names(celltypes))) {
      celltypes_aligned <- celltypes[common_cells]
    } else {
      # If no names, you'll need to manually align
      cat("WARNING: celltypes has no names - manual alignment needed\n")
      celltypes_aligned <- celltypes[1:length(common_cells)]
    }
  }
} else {
  # Method 2: If no cell names, ensure same order and length
  cat("No cell names found - using positional alignment\n")
  
  # Find minimum length
  min_length <- min(ncol(sce_HEP), nrow(dim_red), length(celltypes))
  cat("Using first", min_length, "cells\n")
  
  sce_HEP_aligned <- sce_HEP[, 1:min_length]
  dim_red_aligned <- dim_red[1:min_length, , drop = FALSE]
  celltypes_aligned <- celltypes[1:min_length]
}

# Step 5: Remove any remaining NA values
valid_cells <- !is.na(celltypes_aligned)
sce_HEP_final <- sce_HEP_aligned[, valid_cells]
dim_red_final <- dim_red_aligned[valid_cells, , drop = FALSE]
celltypes_final <- celltypes_aligned[valid_cells]

cat("\n=== Final Data Check ===\n")
cat("Final sce_HEP columns:", ncol(sce_HEP_final), "\n")
cat("Final dim_red rows:", nrow(dim_red_final), "\n")
cat("Final celltypes length:", length(celltypes_final), "\n")
cat("Final cell type distribution:\n")
print(table(celltypes_final))

# Step 6: Try visualization with cleaned data
cat("\n=== Attempting Visualization ===\n")

# First try VizMST (usually more robust)
tryCatch({
  VizMST(sce_HEP_final, clustering = celltypes_final, viz.dim.red = dim_red_final)
  cat("VizMST successful!\n")
}, error = function(e) {
  cat("VizMST failed:", e$message, "\n")
})

# Then try VizClustering
tryCatch({
  VizClustering(sce_HEP_final, clustering = celltypes_final, viz.dim.red = dim_red_final)
  cat("VizClustering successful!\n")
}, error = function(e) {
  cat("VizClustering failed:", e$message, "\n")
})

# Alternative visualization approach
cat("\n=== Alternative Visualization ===\n")
library(ggplot2)

# Create a simple scatter plot
plot_df <- data.frame(
  dim_red_final,
  celltype = as.factor(celltypes_final)
)

p <- ggplot(plot_df, aes(x = X1, y = X2, color = celltype)) +
  geom_point(alpha = 0.7, size = 0.8) +
  theme_minimal() +
  labs(title = "Cell Types on Dimensionality Reduction",
       x = "Dimension 1", y = "Dimension 2",
       color = "Cell Type") +
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))

print(p)

# If you want to add trajectory information
if (exists("sds")) {  # sds is your SlingshotDataSet
  tryCatch({
    # Extract trajectory information
    curves <- slingCurves(sds)
    
    # Add curves to plot
    for (i in seq_along(curves)) {
      curve_coords <- curves[[i]]$s[curves[[i]]$ord, ]
      p <- p + geom_path(data = data.frame(X1 = curve_coords[,1], 
                                           X2 = curve_coords[,2]),
                         aes(x = X1, y = X2), 
                         color = "black", size = 1, inherit.aes = FALSE)
    }
    print(p)
  }, error = function(e) {
    cat("Could not add trajectories:", e$message, "\n")
  })
}
```

##d. Fit Slingshot
```{r echo = F}
# After visualizing UMAP by cell type clusters, we fit slingshot two ways: 
#   i) setting start cluster as PT-3, ending cluster as PT-4 (PT-3 having the most "healthy" cells, PT-4 having the most "diseased" cells),
#   ii) unsupervised.
#   
# The first method resulted in two trajectories (lineage 1: PT-3  PT-2  PT-5  PT-4; lineage 2: PT-3  PT-2  PT-1), and the second method also resulted in two trajectories (lineage 1: PT-4  PT-5  PT-2  PT-3; lineage 2: PT-4  PT-5  PT-2  PT-1).
# 
# Lineage 1 of the unsupervised method was the exact inverse of lineage 1 of the supervised method. Therefore, we moved forward with the initial method.

# End with Hep-5
sce_HEP <- as.SingleCellExperiment(so_Hep)
reducedDim(sce_HEP, "pca") <- Embeddings(so_Hep, reduction = "pca")

sce_HEP <- slingshot(sce_HEP, reducedDim = 'pca', clusterLabels = colData(sce_HEP)$celltype, start.clus = 'Hep-3',end.clus = 'Hep-5')
shuffle <- sample(ncol(sce_HEP))

# jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_hep5.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "PCA-1", ylab = "PCA-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
# dev.off()

SlingshotDataSet(sce_HEP)


# #start point hep-1
# sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = 'Hep-1')
# shuffle <- sample(ncol(sce_HEP))
# 
# jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_dHep.jpeg"), width = 1000, height =800, quality = 100)
# par(mar = c(5, 6, 1, 1))
# plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
#      xlab = "UMAP-1", ylab = "UMAP-2",
#      col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
#      cex.lab = 3, cex.axis = 2)
# lines(SlingshotDataSet(sce_HEP), type = "lineages")
# lines(SlingshotDataSet(sce_HEP))
# dev.off()
# 
# SlingshotDataSet(sce_HEP)
# 
# #start point hep-2
# sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = 'Hep-2')
# shuffle <- sample(ncol(sce_HEP))
# 
# jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_dHep.jpeg"), width = 1000, height =800, quality = 100)
# par(mar = c(5, 6, 1, 1))
# plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
#      xlab = "UMAP-1", ylab = "UMAP-2",
#      col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
#      cex.lab = 3, cex.axis = 2)
# lines(SlingshotDataSet(sce_HEP), type = "lineages")
# lines(SlingshotDataSet(sce_HEP))
# dev.off()
# 
# SlingshotDataSet(sce_HEP)

#Hep-5 after filtering
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")

sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, end.clus = 'Hep-5')
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_hep5_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

#dHep after filtering
# sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
# reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")

sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, end.clus = 'dHep')
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_dHep_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

#Try start and end point
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")
sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = "Hep-1", end.clus = 'dHep')
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_start_hep1_end_dHep_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

#Just hep-1 start point
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")
sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = "Hep-1")
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_start_hep1_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)


#Just hep2 start point
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")
sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = "Hep-2")
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_start_hep2_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

#Just hep2 start point to Hep-5
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")
sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = "Hep-2",end.clus="Hep-5")
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_start_hep2_end_hep5_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

#Just hep1 start point to Hep-5
sce_HEP <- as.SingleCellExperiment(so_Hep_filtered)
reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered, reduction = "umap")
sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, start.clus = "Hep-1",end.clus="Hep-5")
shuffle <- sample(ncol(sce_HEP))

jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_start_hep1_end_hep5_filtered.jpeg"), width = 1000, height =800, quality = 100)
par(mar = c(5, 6, 1, 1))
plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
     xlab = "UMAP-1", ylab = "UMAP-2",
     col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
     cex.lab = 3, cex.axis = 2)
lines(SlingshotDataSet(sce_HEP), type = "lineages")
lines(SlingshotDataSet(sce_HEP))
dev.off()

SlingshotDataSet(sce_HEP)

# #Remove dHep
# so_Hep_filtered2 <- subset(so_Hep_filtered,celltype!="dHep")
# sce_HEP <- as.SingleCellExperiment(so_Hep_filtered2)
# reducedDim(sce_HEP, "UMAP") <- Embeddings(so_Hep_filtered2, reduction = "umap")
# 
# sce_HEP <- slingshot(sce_HEP, reducedDim = 'UMAP', clusterLabels = colData(sce_HEP)$celltype, end.clus = 'Hep-5')
# shuffle <- sample(ncol(sce_HEP))

# jpeg(fs::path(dir.results,"Hep_slingshot_UMAP_end_hep5_filtered_no_dHep.jpeg"), width = 1000, height =800, quality = 100)
# par(mar = c(5, 6, 1, 1))
# plot(reducedDims(sce_HEP)$UMAP[shuffle, ], asp = 1, pch = 16,
#      xlab = "UMAP-1", ylab = "UMAP-2",
#      col = hcl.colors(100, alpha = .5, palette = "PinkYl")[cut(sce_HEP$slingPseudotime_1, breaks = 100)][shuffle],
#      cex.lab = 3, cex.axis = 2)
# lines(SlingshotDataSet(sce_HEP), type = "lineages")
# lines(SlingshotDataSet(sce_HEP))
# dev.off()
# 
# SlingshotDataSet(sce_HEP)

# 
# plot_df <- as.data.frame(slingPseudotime(sce_Hep_unsupervised)) %>%
#   dplyr::mutate(Group = colData(sce_Hep_unsupervised)$Group,
#                 gbm_thick_quartile = colData(sce_Hep_unsupervised)$gbm_thick_quartile,
#                 bmi_quartile = colData(sce_Hep_unsupervised)$bmi_quartile,
#                 bmi_manual_cat = colData(sce_Hep_unsupervised)$bmi_manual_cat,
#                 diabetes_duration_quartile = colData(sce_Hep_unsupervised)$diabetes_duration_quartile,
#                 diabetes_duration_manual_cat = colData(sce_Hep_unsupervised)$diabetes_duration_manual_cat,
#                 age_quartile = colData(sce_Hep_unsupervised)$age_quartile,
#                 raw_m_quartile = colData(sce_Hep_unsupervised)$raw_m_quartile)
# lines(SlingshotDataSet(sce_Hep_unsupervised))

# plot(reducedDims(sce_Hep_unsupervised)$UMAP[shuffle, ], asp = 1, pch = 16,
#      xlab = "UMAP-1", ylab = "UMAP-2",
#      col = sce_Hep_unsupervised$Group)
# 
# lines(SlingshotDataSet(sce_Hep_unsupervised), type = "lineages")
# legend("topright", pch = 16, col = alpha(c("HC" = "#ffcb77", "T1D" = "#fe6d73"), 0.4), bty = "n",
#        legend = levels(factor(colData(sce)$Group)))
# 
# plotUMAP(sce_Hep_unsupervised, colour_by="pseudotime", point_alpha=0.3) +
#     geom_segment(data=grid.df,
#         mapping=aes(x=start.1, y=start.2, xend=end.1, yend=end.2),
#         arrow=arrow(length=unit(0.05, "inches"), type="closed"))
```

```{r echo = F}
# Function to plot all smooth after fitGAM
plot_smooth <- function(sce, gene, title = gene) {
  non_missing_cells <- (colData(sce)$tradeSeq$conditions != "NA")
  non_missing_cells <- as.data.frame(non_missing_cells) %>% 
    dplyr::mutate(non_missing_cells = case_when(non_missing_cells == T ~ 1))
  cnt <- assays(sce)$counts[gene, , drop=F]
  cnt <- as.data.frame(t(cnt))
  cnt <- cnt*non_missing_cells
  colnames(cnt) <- "exp"
  cnt <- cnt %>% filter(!is.na(exp))
  pseudotime <- (colData(sce)$crv$pseudotime.Lineage1 * non_missing_cells %>%
                   filter(!is.na(non_missing_cells)))$non_missing_cells
  condition <- colData(sce)$tradeSeq$conditions
  
  if ("NA" %in% condition){
    condition <- condition[condition != "NA"]
  }
  
  ncondition <- length(unique(condition))
  
  if (ncondition == 2){
    colors = c("#007e5d",  "#ff8989")
  }
  if (ncondition == 3){
    colors = c("#ef767a", "#456990", "#49beaa")
  }
  if(ncondition == 4){
    colors = c("#003049", "#d62828", "#f77f00", "#fcbf49")
  }
  if(ncondition == 5){
    colors = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51")
  }
  
  cnt_smooth <- predictSmooth(sce, gene, nPoints=100) %>%
    filter(lineage == 1) %>% dplyr::select(-lineage)
  cnt_smooth <- cnt_smooth[, c("yhat", "time", "condition")]
  colnames(cnt_smooth) <- c("exp", "pseudotime", "condition")
  cnt_smooth <- cnt_smooth %>% filter(condition!="NA")
  
  p <- ggplot(NULL, aes(x=pseudotime, y=log1p(exp), color=condition)) + 
    geom_point(data=cnt, size=1, alpha = 0.3) +
    geom_line(data=cnt_smooth, linewidth=1.5) +
    labs(x = "Pseudotime",
         y = "Log(expression + 1)", 
         title = title,
         color = "Group") +
    theme_minimal() +
    theme(panel.border = element_blank(), panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) +
    scale_color_manual(values = colors)
  return(p)
}
```

##B. All Celltypes
###i. PCA
```{r}
#Filter to Hep Cells
# so_Hep <- subset(so_liver_sn,celltype2=="Hep")
# DefaultAssay(so_Hep) <- "RNA" 
# Step 1: Prepare your Seurat object
so_liver_sn <- FindVariableFeatures(object = so_liver_sn)
so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn),assay="RNA")
# so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn))

# Find clusters using PCA
so_liver_sn <- FindNeighbors(so_liver_sn, dims = 1:10, reduction = "pca")
so_liver_sn <- FindClusters(so_liver_sn, resolution = 0.5)

#Visualize clusters
DimPlot(so_liver_sn, reduction = "pca", dims = c(1, 2), 
        group.by = "celltype", label = TRUE, label.size = 6) +
  labs(title = "PCA: PC1 vs PC2 - Clusters")

# Visualize clusters on PCA
DimPlot(so_liver_sn, 
        reduction = "pca", 
        dims = c(1, 2), group.by = "celltype",label = TRUE,raster=F)

#       label.size = 6) +
# labs(title = "PCA: PC1 vs PC2 - Cell Types")

```


#6. Proteomics Analysis
## a. TODAY 
```{r}
#Load in AST and ALT in today 
# today <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","CBL.csv"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "CBL.csv", temp_file)
today <- read.csv(temp_file)
gc()
length(unique(today$releaseid)) # 699 ids
today <- today %>%
  filter(mvisit!="R")

#Load in Proteomics in Today
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "today_proteomics_log2.rds", temp_file)
prot <- readRDS(temp_file)
gc()

which(colnames(prot)=="AGEBASE") #7406
which(colnames(prot)=="releaseid") #7326
which(colnames(prot)=="sex") #7399
prot <- prot[c(7326,7406,7399,which(grepl("seq.",colnames(prot))))] #length(unique(prot$releaseid)) - 376 unique ids
proteins <- colnames(prot)[which(grepl("seq.",colnames(prot)))]

#Load gene protein key
# key <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/Data/gene_prot.RDS")
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".RDS") # need to create a temporary file
s3$download_file(bucket, "gene_prot.RDS", temp_file)
key <- readRDS(temp_file)
gc()

genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)]
prot <- prot[c("releaseid","AGEBASE","sex",gene_proteins)]
prot_id <- unique(prot$releaseid)

today_sub <- today %>% 
  filter(releaseid %in% prot_id)

# Basic spaghetti plot
ggplot(today_sub, aes(x = mvisit, y = ALT, group = releaseid)) +
  geom_line(alpha = 0.5, color = "gray40") +
  geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
  labs(title = "ALT Values Over Time by Individual",
       x = "mvisit",
       y = "ALT") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate mean ALT for each mvisit
mean_data <- today_sub %>%
  group_by(mvisit) %>%
  summarise(mean_ALT = mean(ALT, na.rm = TRUE))

# Create plot with individual lines and mean trend
ggplot(today_sub, aes(x = mvisit, y = ALT)) +
  geom_line(aes(group = releaseid), alpha = 0.3, color = "gray60") +
  geom_point(aes(group = releaseid), alpha = 0.3, size = 1, color = "gray60") +
  geom_line(data = mean_data, aes(x = mvisit, y = mean_ALT, group = 1), 
            color = "red", size = 2) +
  geom_point(data = mean_data, aes(x = mvisit, y = mean_ALT), 
             color = "red", size = 3) +
  labs(title = "ALT Values Over Time by Individual",
       subtitle = "Red line shows mean trend",
       x = "mvisit",
       y = "ALT") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(today_sub, aes(x = mvisit, y = ALT, group = releaseid, color = factor(releaseid))) +
  geom_line(alpha = 0.7, size = 1) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "ALT Values Over Time by Individual",
       x = "mvisit",
       y = "ALT",
       color = "Individual ID") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
  theme(legend.position = "none")

# Basic spaghetti plot
ggplot(today_sub, aes(x = mvisit, y = AST, group = releaseid)) +
  geom_line(alpha = 0.5, color = "gray40") +
  geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
  labs(title = "AST Values Over Time by Individual",
       x = "mvisit",
       y = "AST") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate mean AST for each mvisit
mean_data <- today_sub %>%
  group_by(mvisit) %>%
  summarise(mean_AST = mean(AST, na.rm = TRUE))

# Create plot with individual lines and mean trend
ggplot(today_sub, aes(x = mvisit, y = AST)) +
  geom_line(aes(group = releaseid), alpha = 0.3, color = "gray60") +
  geom_point(aes(group = releaseid), alpha = 0.3, size = 1, color = "gray60") +
  geom_line(data = mean_data, aes(x = mvisit, y = mean_AST, group = 1), 
            color = "red", size = 2) +
  geom_point(data = mean_data, aes(x = mvisit, y = mean_AST), 
             color = "red", size = 3) +
  labs(title = "AST Values Over Time by Individual",
       subtitle = "Red line shows mean trend",
       x = "mvisit",
       y = "AST") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(today_sub, aes(x = mvisit, y = AST, group = releaseid, color = factor(releaseid))) +
  geom_line(alpha = 0.7, size = 1) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "AST Values Over Time by Individual",
       x = "mvisit",
       y = "AST",
       color = "Individual ID") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
  theme(legend.position = "none")

missing_counts <- today_sub %>%
  group_by(releaseid) %>%
  summarise(
    total_timepoints = n(),
    missing_ALT = sum(is.na(ALT)),
    missing_AST = sum(is.na(AST)),
    complete_ALT = sum(!is.na(ALT)),
    complete_AST = sum(!is.na(AST))
  )

print(missing_counts)

# Calculate percentages for ALT
ALT_stats <- missing_counts %>%
  summarise(
    total_participants = n(),
    participants_missing_at_least_one_ALT = sum(missing_ALT >= 1),
    participants_missing_more_than_5_ALT = sum(missing_ALT > 5),
    percent_missing_at_least_one_ALT = round(100 * participants_missing_at_least_one_ALT / total_participants, 2),
    percent_missing_more_than_5_ALT = round(100 * participants_missing_more_than_5_ALT / total_participants, 2)
  )

# Calculate percentages for AST
AST_stats <- missing_counts %>%
  summarise(
    total_participants = n(),
    participants_missing_at_least_one_AST = sum(missing_AST >= 1),
    participants_missing_more_than_5_AST = sum(missing_AST > 5),
    percent_missing_at_least_one_AST = round(100 * participants_missing_at_least_one_AST / total_participants, 2),
    percent_missing_more_than_5_AST = round(100 * participants_missing_more_than_5_AST / total_participants, 2)
  )

#Calculate sensoring and time to event
baseline <- today %>% 
  filter(mvisit=="M00") %>% 
  mutate(baseline_alt=ALT,
         baseline_ast=AST) %>% 
  dplyr::select(all_of(c("releaseid","baseline_alt","baseline_ast"))) 
dat <- tidylog::left_join(today,baseline,by="releaseid")
dat <- dat %>% 
  mutate(ratio = AST/ALT) %>% 
  mutate(event_alt=ifelse(ALT>=2*(baseline_alt),1,0)) %>% 
  mutate(event_ast=ifelse(AST>=2*(baseline_ast),1,0)) %>% 
  mutate(event_ratio=ifelse(ratio>=1.5,1,0)) %>% 
  mutate(days=ifelse(mvisit=="M00",0,days))
#Calculate time to event & censoring
dat_alt <- dat %>% 
  group_by(releaseid) %>%
  summarize(
    event_status_alt = ifelse(any(event_alt == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
    time_to_event_alt = ifelse(
      any(event_alt == 1, na.rm = TRUE), 
      min(days[event_alt == 1], na.rm = TRUE), # Time of first event
      max(days, na.rm = TRUE)                 # Time of last observation (censoring)
    )) %>% 
  ungroup()
dat_ast <- dat %>% 
  group_by(releaseid) %>%
  summarize(
    event_status_ast = ifelse(any(event_ast == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
    time_to_event_ast = ifelse(
      any(event_ast == 1, na.rm = TRUE), 
      min(days[event_ast == 1], na.rm = TRUE), # Time of first event
      max(days, na.rm = TRUE)                 # Time of last observation (censoring)
    )) %>% 
  ungroup()

dat_ratio <- dat %>% 
  group_by(releaseid) %>%
  summarize(
    event_status_ratio = ifelse(any(event_ratio == 1, na.rm = TRUE), 1, 0), # 1 if event occurred, 0 if censored
    time_to_event_ratio = ifelse(
      any(event_ratio == 1, na.rm = TRUE), 
      min(days[event_ratio == 1], na.rm = TRUE), # Time of first event
      max(days, na.rm = TRUE)                 # Time of last observation (censoring)
    )) %>% 
  ungroup()

dat_covs <- today %>%
  filter(mvisit=="M00") %>%
  dplyr::select(all_of(c("releaseid","HbA1c")))
#Merge proteins in
dat <- tidylog::right_join(dat_covs,prot,by="releaseid")
dat <- tidylog::right_join(dat_alt,dat,by="releaseid")
dat <- tidylog::right_join(dat_ast,dat,by="releaseid")
dat <- tidylog::right_join(dat_ratio,dat,by="releaseid")
rm(baseline,dat_alt,dat_ast,dat_covs,prot,today)

# length(colnames(dat))
# length(unique(colnames(dat)))
# length(hvg_proteins)
# length(unique(hvg_proteins))
# 
#Examine descrptive statostics
# data_covariates <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","BASELINE.csv"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "BASELINE.csv", temp_file)
data_covariates <- read.csv(temp_file)
gc()

data_covariates <- data_covariates %>%
  filter(days==0) %>%
  filter(releaseid %in% dat$releaseid)
dat <- tidylog::left_join(dat,data_covariates,by="releaseid")
length(unique(dat$releaseid)) #376
# dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
# dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)
#
label(dat$AGEBASE)      <- "Age (y)"
label(dat$sex)      <- "Sex (Male or Female)"
dat$sex <- factor(dat$sex)
# label(dat$sglt2_exclusive) <- "SGLT2 Inhibitors (Yes/No)"
# label(dat$glp1agonist) <- "GLP-1 Receptor Agonists (Yes/No)"
table1(~sex+HbA1c+AGEBASE+bmi,data=dat)
dat$obese <- ifelse(dat$bmi>=30,"Obesity","No Obesity")
label(dat$AGEBASE)      <- "Age (y)"
label(dat$sex)      <- "Sex (Male or Female)"
label(dat$obese)      <- "Obesity (BMI > 30: Yes vs. No)"
dat$obese <- factor(dat$obese)
dat$event_status_alt <- factor(dat$event_status_alt)
dat$event_status_ast <- factor(dat$event_status_ast)
table1(~sex+HbA1c+AGEBASE+obese+time_to_event_alt+event_status_alt+time_to_event_ast+event_status_ast+time_to_event_ratio+event_status_ratio,data=dat)
dat$obese <- factor(dat$obese)
table1(~sex+HbA1c+AGEBASE+obese,data=dat)

```

### Analysis Crude
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE"))
  M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,5]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

results_total <- rbind(results_ast,results_alt)
results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

sig_results <- results_total %>% 
  filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$fdr < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$fdr < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "Log2HR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ratio %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
### Analysis Adjusted
#### FDR < 0.05
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_adj.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_adj.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio_adj.csv"))

# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$fdr < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$fdr < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.05) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_adj.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$fdr < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$fdr < 0.05, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.05) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$fdr < 0.05, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
#### p < 0.05
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  # mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_alt <- results_alt %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  #   mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_ast <- results_ast %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  #   mutate(fdr = p.adjust(Pvalue,method="fdr"))
  # results_ratio <- results_ratio %>%
  mutate(sig=ifelse(Pvalue<0.05,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_adj.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_adj.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio_adj.csv"))

# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

#ALT
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$Pvalue < 0.05 & results_alt$LogHR > 0, "lightcoral",
                            ifelse(results_alt$Pvalue < 0.05 & results_alt$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_alt[results_alt$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_alt %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_alt[results_alt$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("P-value < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$Pvalue < 0.05 & results_ast$LogHR > 0, "lightcoral",
                            ifelse(results_ast$Pvalue < 0.05 & results_ast$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ast[results_ast$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ast %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ast[results_ast$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)


results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$Pvalue < 0.05 & results_ratio$LogHR > 0, "lightcoral",
                              ifelse(results_ratio$Pvalue < 0.05 & results_ratio$LogHR < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- results_ratio[results_ratio$Pvalue < 0.05, ]
# # Select top 10 up and down LogHR genes per Outcome
top_labels <- significant_df%>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  # filter(fdr<0.05) %>%
  slice_head(n = 20) %>%
  bind_rows(
    results_ratio %>%
      group_by(Outcome) %>%
      arrange(LogHR, .by_group = TRUE) %>% 
      slice_head(n = 20)
  ) %>%
  ungroup()
# # Identify significant points (fdr < 0.05)
# significant_df <- results_ratio[results_ratio$Pvalue < 0.05, ]
# 
# # Use significant_df directly for labels
# top_labels <- significant_df %>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("FDR < 0.05, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY_Adjusted_Pvalue.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
#### FDR < 0.1
```{r}
#Create loop for linear regression between proteins & liver enzymes
results_alt <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_alt,event_status_alt) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_alt <- data.frame(Protein=x,Outcome=paste0("Time to doubling of ALT"),LogHR=logHR,Pvalue=pval)
  results_alt <- rbind(results_alt,results_full_alt)
}


results_ast <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x))
  M1 <- coxph(M0,data=dat,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ast <- data.frame(Protein=x,Outcome=paste0("Time to doubling of AST"),LogHR=logHR,Pvalue=pval)
  results_ast <- rbind(results_ast,results_full_ast)
}

#Ratio
dat_ratio <- dat %>% 
  mutate(event_at_baseline=ifelse(event_status_ratio==1 & time_to_event_ratio==0,"Yes","No"))
dat_ratio <- dat_ratio %>% 
  filter(event_at_baseline!="Yes") #Subset of 273 didnt have event at baseline from the 376 with data
results_ratio <- data.frame()
for (x in gene_proteins) {
  M0 <- as.formula(paste0("Surv(time_to_event_ast,event_status_ast) ~ ",x,"+AGEBASE+sex"))
  # M0 <- as.formula(paste0("Surv(time_to_event_ratio,event_status_ratio) ~ ",x))
  M1 <- coxph(M0,data=dat_ratio,id=releaseid)
  logHR <- summary(M1)$coef[1,1]
  pval <- summary(M1)$coef[1,6]
  results_full_ratio <- data.frame(Protein=x,Outcome=paste0("Time to AST/ALT Ratio = 1.5"),LogHR=logHR,Pvalue=pval)
  results_ratio <- rbind(results_ratio,results_full_ratio)
}

#ALT
results_alt <- results_alt %>%
  # filter(Outcome=="Time to doubling of ALT") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_alt <- results_alt %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT_results.csv"))

#AST
results_ast <- results_ast %>%
  # filter(Outcome=="Time to doubling of AST") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ast <- results_ast %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST_results.csv"))

#Ratio
results_ratio <- results_ratio %>%
  # filter(Outcome=="Time to AST/ALT Ratio = 1.5") %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr"))
results_ratio <- results_ratio %>%
  mutate(sig=ifelse(fdr<0.1,"*",""))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

# results_total <- rbind(results_ast,results_alt)
# results_total <- rbind(results_total,results_ratio)


#Match to gene name
key$Protein <- key$AptName
# results_total <- tidylog::left_join(results_total,key,by="Protein")
results_ast <- tidylog::left_join(results_ast,key,by="Protein")
results_alt <- tidylog::left_join(results_alt,key,by="Protein")
results_ratio <- tidylog::left_join(results_ratio,key,by="Protein")


# write.csv(results_ast,"/home/hhampson/Results/today_proteomics_AST_adj_fdr_01.csv")
# write.csv(results_alt,"/home/hhampson/Results/today_proteomics_ALT_adj_fdr_01.csv")
# write.csv(results_ratio,"/home/hhampson/Results/today_proteomics_AST_ALT_ratio_adj_fdr_01.csv")

# # write file
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# write.csv(results_ast, temp_file, row.names = FALSE) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, bucket, 'Log2_today_proteomics_AST_adj_fdr_01.csv')



# sig_results <- results_total %>% 
#   filter(sig=="*")

# write.csv(results_total,fs::path(dir.results,"today_subeomics_alt_ast_hvg_adj_age.csv"))

# mutate(fdr3=p.adjust(PValue3,method="fdr"))
results_alt$PValue10 <- -log10(pmax(results_alt$Pvalue, 1e-10))  # Avoid log(0)


results_alt <- results_alt %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_alt$color <- ifelse(results_alt$fdr<0.1 & results_alt$LogHR > 0, "#990000",
                            ifelse(results_alt$fdr<0.1 & results_alt$LogHR < 0, "#003366", "lightgray"))

# # Identify significant points (fdr<0.1)
# significant_df <- results_alt[results_alt$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.1) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_alt %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_alt[results_alt$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_alt$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_alt$color3 <- ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 > 0, "lightcoral",
#                               ifelse(results_alt$fdr3 < 0.2 & results_alt$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_alt[results_alt$fdr3 < 0.2, ]

max <- max(results_alt$LogHR)
# max <- 3.1
min <- min(results_alt$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_alt, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_ALT_Proteomics_TODAY_Adjusted_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png("/home/hhampson/Results/Plot_ALT_Proteomics_TODAY_Adjusted_fdr_01_log2.png", 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#AST
results_ast$PValue10 <- -log10(pmax(results_ast$Pvalue, 1e-10))  # Avoid log(0)


results_ast <- results_ast %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ast$color <- ifelse(results_ast$fdr<0.1 & results_ast$LogHR > 0, "#990000",
                            ifelse(results_ast$fdr<0.1 & results_ast$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ast[results_ast$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   filter(fdr<0.1) %>% 
#   # slice_head(n = 20) %>%
#   bind_rows(
#     results_ast %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) 
#       # slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ast[results_ast$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ast$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ast$color3 <- ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ast$fdr3 < 0.2 & results_ast$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ast[results_ast$fdr3 < 0.2, ]

max <- max(results_ast$LogHR)
# max <- 3.1
min <- min(results_ast$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ast, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_AST_Proteomics_TODAY_Adjusted_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png("/home/hhampson/Results/Plot_AST_Proteomics_TODAY_Adjusted_fdr_01_log2.png", 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

#Ratio
results_ratio$PValue10 <- -log10(pmax(results_ratio$Pvalue, 1e-10))  # Avoid log(0)
results_ratio <- results_ratio %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

results_ratio$color <- ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR > 0, "#990000",
                              ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ratio[results_ratio$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.1) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ratio[results_ratio$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "log2HR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  # geom_text_repel(data = top_labels, 
  #                 aes(label = Gene),
  #                 size = 3,
  #                 color = "black",
  #                 # Control line segments
  #                 segment.color = "gray50",
  #                 segment.size = 0.5,
  #                 segment.alpha = 0.8,
  #                 # Control label positioning
  #                 box.padding = 0.5,
  #                 point.padding = 0.3,
  #                 force = 1,
  #                 max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
  #                 # Optional: limit computation time
  #                 max.time = 1,
  #                 max.iter = 10000)+
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# png(fs::path(dir.results, "Plot_AST_ALT_Ratio_Proteomics_TODAY_fdr_01.png"), 
#     width = 2200, height = 2000, res = 300)
# print(volcano_plot)
# dev.off()
png(fs::path("/home/hhampson/Results/Plot_AST_ALT_Ratio_Proteomics_TODAY_fdr_01_log2.png"), 
    width = 2200, height = 2000, res = 300)
print(volcano_plot)
dev.off()

```
### GSEA Crude
```{r echo = F}
# write.csv(results_ast,fs::path(dir.results,"today_proteomics_AST.csv"))
# write.csv(results_alt,fs::path(dir.results,"today_proteomics_ALT.csv"))
# write.csv(results_ratio,fs::path(dir.results,"today_proteomics_AST_ALT_ratio.csv"))

full_results <- read.csv(fs::path(dir.results,"today_proteomics_AST.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=entrez_gene_symbol,LogHR=log_hr)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
# gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_dHep <- full_results$LogHR
names(rankings_dHep) <- full_results$Gene
rankings_dHep <- sort(rankings_dHep, decreasing = TRUE)
plot(rankings_dHep)
min(rankings_dHep)
max(rankings_dHep)


set.seed(1234)

kegg_legacy_res_dHep <- fgsea(pathways = kegg_legacy,
                              stats = rankings_dHep,
                              scoreType = 'std', 
                              minSize = 3,
                              maxSize = 500,
                              nproc = 1)

reactome_res_dHep <- fgsea(pathways = reactome,
                           stats = rankings_dHep,
                           scoreType = 'std', 
                           minSize = 3,
                           maxSize = 500,
                           nproc = 1)
go_res_dHep <- fgsea(pathways = go,
                     stats = rankings_dHep,
                     scoreType = 'std', 
                     minSize = 5,
                     maxSize = 500,
                     nproc = 1)

dHep_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_dHep[, padj < 0.05]), sum(kegg_legacy_res_dHep[, pval < 0.05])),
                         "REACTOME"=c(sum(reactome_res_dHep[, padj < 0.05]), sum(reactome_res_dHep[, pval < 0.05])),
                         "GO"=c(sum(go_res_dHep[, padj < 0.05]), sum(go_res_dHep[, pval < 0.05])))
rownames(dHep_fgsea) <- c("adj.pval", "p.val")
dHep_fgsea

##### KEGG Legacy
plot_fgsea_transpose(kegg_legacy_res_dHep, title = "dHep Unadjusted Top 30 KEGG", xnudge = 0.03)

ggsave(fs::path(dir.results,"dHep_top30_kegg_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### REACTOME
plot_fgsea_transpose(reactome_res_dHep, title = "dHep Unadjusted Top 30 REACTOME", xlimit = 5)

ggsave(fs::path(dir.results,"dHep_top30_reactome_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)

##### GO
plot_fgsea_transpose(go_res_dHep, title = "dHep Unadjusted Top 30 GO", xlimit = 8)

ggsave(fs::path(dir.results,"dHep_top30_go_pathways_unadjusted_reml.jpeg"),
       width = 13, height = 10, scale = 1)
```

###ii. Old
```{r}
#Load in AST and ALT in today 
today <- read.csv(fs::path(dir.dat,"TODAY subaward","Clinical data","TODAY","CBL.csv"))
# length(unique(today$releaseid)) - 699 ids
# today_M0 <- today %>%
#   filter(mvisit=="M00")
#dplyr::select(c("releaseid","ALT","AST"))
#Load in Proteomics in Today
prot <- readRDS(fs::path(dir.dat,"Liver project","today_subeomics.rds"))
prot <- prot[c(7326,7404,7397,which(grepl("seq.",colnames(prot))))] #length(unique(prot$releaseid)) - 376 unique ids
proteins <- colnames(prot)[which(grepl("seq.",colnames(prot)))]

#rm(today,today_M0,prot)

# #Determine which proteins correlate with genes associated with alt and ast
# #AST
# ast_genes <- read.xlsx(fs::path(dir.dat,"Liver project","Results","Bulk_Results_for_Ast Di (High vs. Low).xlsx"))
# ast_genes_pos <- ast_genes %>%
#   filter(p_val_adj<0.05) %>%
#   filter(avg_log2FC>0) %>%
#   arrange(desc(avg_log2FC)) %>%
#   dplyr::slice(1:200) 
# ast_genes_pos <- ast_genes_pos$Gene
# ast_genes_neg <- ast_genes %>%
#   filter(p_val_adj<0.05) %>%
#   filter(avg_log2FC<0) %>%
#   arrange(avg_log2FC) %>%
#   dplyr::slice(1:200) 
# ast_genes_neg <- ast_genes_neg$Gene
# ast_genes <- c(ast_genes_pos,ast_genes_neg)

#Key Protein Gene
key <- readRDS(fs::path(dir.dat,"Liver project","gene_prot.RDS"))
sens_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% sens_genes)]
prot_sens <- prot[c("releaseid","AGEBASE","sex",sens_proteins)]
data <- tidylog::right_join(today,prot_sens,by="releaseid")
data <- data %>% #filter out recruitment visits
  filter(mvisit!="R")

# Compute baseline ALT for each participant
data <- data %>%
  group_by(releaseid) %>%
  mutate(baseline_alt = first(ALT)) %>% 
  mutate(baseline_ast = first(AST)) %>% 
  ungroup()

#Check if ALT has doubled at each visit
data <- data %>%
  mutate(event_alt = ifelse(ALT >= 2 * baseline_alt, 1, 0)) %>% 
  mutate(event_ast = ifelse(AST >= 2 * baseline_ast, 1, 0))

# Ensure the event persists after it occurs
data <- data %>%
  group_by(releaseid) %>%
  mutate(event_alt = cummax(event_alt)) %>%  # Marks 1 for all visits after doubling occurs
  mutate(event_ast = cummax(event_ast)) %>% 
  ungroup() %>% 
  mutate(days_to_alt = ifelse(event_alt==1,days,))

#Censor individuals who didnt develop event


#Create loop for cox proportional hazards
#ALT
results_alt <- data.frame()
for (protein in sens_proteins){
  # formula <- as.formula(paste0("Surv(days, event_alt) ~ ", protein))
  formula <- as.formula(paste0("Surv(days, event_alt) ~ ", protein,"+AGEBASE+sex+HbA1c"))
  # Fit the Cox model
  cox_model <- coxph(formula, data = data)
  
  # Store the summary or model output
  LogHR <- summary(cox_model)$coef[1,1]
  Risk <- ifelse(LogHR>0,"Increased",
                 ifelse(LogHR<0,"Decreased","No Effect"))
  Pvalue <- summary(cox_model)$coef[1,5]
  results_data_alt <- data.frame(Protein=protein,Outcome="ALT",LogHazardRatio=LogHR,Risk=Risk,Pvalue=Pvalue)
  results_alt <- rbind(results_alt,results_data_alt)
}
rm(results_data_alt)
results_alt <- results_alt %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr")) %>% 
  mutate(sig=case_when(fdr<0.05 & Risk=="Increased" ~ "Significant Positive",
                       fdr<0.05 & Risk=="Decreased" ~"Significant Negative",
                       fdr>0.05~"Not Significant"))

#AST
results_ast <- data.frame()
for (protein in sens_proteins){
  # formula <- as.formula(paste0("Surv(days, event_ast) ~ ", protein))
  formula <- as.formula(paste0("Surv(days, event_ast) ~ ", protein,"+AGEBASE+sex+HbA1c"))
  # Fit the Cox model
  cox_model <- coxph(formula, data = data)
  
  # Store the summary or model output
  LogHR <- summary(cox_model)$coef[1,1]
  Risk <- ifelse(LogHR>0,"Increased",
                 ifelse(LogHR<0,"Decreased","No Effect"))
  Pvalue <- summary(cox_model)$coef[1,5]
  results_data_ast <- data.frame(Protein=protein,Outcome="AST",LogHazardRatio=LogHR,Risk=Risk,Pvalue=Pvalue)
  results_ast <- rbind(results_ast,results_data_ast)
}
rm(results_data_ast)
results_ast <- results_ast %>% 
  mutate(fdr = p.adjust(Pvalue,method="fdr")) %>% 
  mutate(sig=case_when(fdr<0.05 & Risk=="Increased" ~ "Significant Positive",
                       fdr<0.05 & Risk=="Decreased" ~"Significant Negative",
                       fdr>0.05~"Not Significant"))

#Combine Results
results <- rbind(results_ast,results_alt)
results <- results %>% 
  dplyr::rename(AptName=Protein)
results <- tidylog::left_join(results,key,by="AptName")
results <- results %>% 
  mutate(Gene_Name=paste0(EntrezGeneSymbol,"_",SeqId))
results_alt <- results %>% 
  filter(Outcome=="ALT") 
results_ast <- results %>% 
  filter(Outcome=="AST") 

#Save results
# write.csv(results_alt,fs::path(dir.results,"ALT_cox_results_unadjusted.csv"))
# write.csv(results_ast,fs::path(dir.results,"AST_cox_results_unadjusted.csv"))
write.csv(results_alt,fs::path(dir.results,"ALT_cox_results_adjusted.csv"))
write.csv(results_ast,fs::path(dir.results,"AST_cox_results_adjusted.csv"))

# Create the volcano plot
volcano_plot_alt <- ggplot(results_alt, aes(x = LogHazardRatio, y = -log10(fdr), color = sig)) +
  geom_point(alpha = 0.8, size = 2) +  # Points with transparency
  # scale_color_manual(values = c("grey", "red")) +  # Custom colors for significance
  scale_color_manual(values = c("Not Significant" = "grey", 
                                "Significant Positive" = "red", 
                                "Significant Negative" = "blue")) +
  theme_minimal() +  # Clean theme
  labs(
    title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of ALT (U/L), adjusted for Age, Sex, and HbA1c",
    # title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of ALT (U/L)",
    x = "Log Hazard Ratio",
    y = "-log10(FDR)"
  ) +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Highlight top significant genes (optional)
top_genes_alt <- subset(results_alt, sig== "Significant Positive" | sig=="Significant Negative")
if (nrow(top_genes_alt) > 0) {
  volcano_plot_alt <- volcano_plot_alt +
    # geom_text(data = top_genes_alt, aes(label = EntrezGeneSymbol), 
    #           vjust = 1.5, size = 5, color = "black")
    geom_text_repel(data = top_genes_alt, aes(label = Gene_Name), 
                    box.padding = 0.35, 
                    point.padding = 0.5, 
                    max.overlaps = Inf,  # Prevent overlap
                    size = 3, 
                    color = "black", 
                    segment.size = 0.5)
}
plot(volcano_plot_alt)

# Create the volcano plot
volcano_plot_ast <- ggplot(results_ast, aes(x = LogHazardRatio, y = -log10(fdr), color = sig)) +
  geom_point(alpha = 0.8, size = 2) +  # Points with transparency
  # scale_color_manual(values = c("grey", "red")) +  # Custom colors for significance
  scale_color_manual(values = c("Not Significant" = "grey", 
                                "Significant Positive" = "red", 
                                "Significant Negative" = "blue")) +
  theme_minimal() +  # Clean theme
  labs(
    title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of AST (U/L), adjusted for Age, Sex, and HbA1c",
    # title = "Cox Proportional Hazards Model for Senescence Proteins and Doubling of AST (U/L)",
    x = "Log Hazard Ratio",
    y = "-log10(FDR)"
  ) +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Highlight top significant genes (optional)
top_genes_ast <- subset(results_ast, sig== "Significant Positive" | sig=="Significant Negative")
if (nrow(top_genes_ast) > 0) {
  volcano_plot_ast <- volcano_plot_ast +
    # geom_text(data = top_genes_ast, aes(label = EntrezGeneSymbol), 
    #           vjust = 1.5, size = 5, color = "black")
    geom_text_repel(data = top_genes_ast, aes(label = Gene_Name), 
                    box.padding = 0.35, 
                    point.padding = 0.5, 
                    max.overlaps = Inf,  # Prevent overlap
                    size = 3, 
                    color = "black", 
                    segment.size = 0.5)
}
plot(volcano_plot_ast)

#Make barchart of significant with alt/ast & proteins


#Compare significant results from alt/ast to transcriptomics alt/ast 


```

#b. TEEN-LABs
```{r}
#Proteomics teen labs 
# load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "analyte_info_log2.rds", temp_file)
analyte_info <- readRDS(temp_file)
gc()

gc()
bucket <- "harmonized.dataset" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "df_log2.rds", temp_file)
df <- readRDS(temp_file)
gc()

#Remove na values for visit
df <- df %>% 
  filter(!is.na(visit))
# dat_baseline <- df %>% 
#   filter(visit=="Month 1")
# dat_followup <- df %>% 
#   filter(visit=="Month 6") 
# dat <- df %>% 
#   filter(visit=="Month 1" | visit=="Month 6")

#Protein key
key <- analyte_info %>% 
  dplyr::select(all_of(c("AptName","SeqId","EntrezGeneSymbol")))

#Gene Proteins
genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)] #3770 proteins
length(gene_proteins) #3770
# prot <- df[c("ID","visit",gene_proteins)]
# protein <- colnames(prot)[-c(1,2)] #3770
# prot_baseline <- prot %>% 
#   filter(visit=="Month 1")
# prot_followup <- prot %>% 
#   filter(visit=="Month 6")
# #Name proteins baseline or followup 
# colnames(prot_baseline)[-c(1,2)] <- paste0(colnames(prot_baseline)[-c(1,2)],"_baseline")
# colnames(prot_followup)[-c(1,2)] <- paste0(colnames(prot_followup)[-c(1,2)],"_followup")
# prot_baseline <- prot_baseline %>% 
#   dplyr::select(-visit)
# prot_baseline_dat <- prot_baseline
# prot_followup <- prot_followup %>% 
#   dplyr::select(-visit)

# prot <- tidylog::left_join(prot_baseline,prot_followup,by="ID")
# prot_id <- unique(prot$ID) #64 unique participants with multiple timepoints of data

#Merge alt and protein data togeth
df <- df %>% 
  dplyr::select(c("ID","visit","age","SEX","ETHN","bmi","HBA1C","NAFLD0","NAFLD1",
                  "NAFLD2","NAFLD3","NAFLD4","NAFLD5","NAFLD6","ALT","AST",all_of(gene_proteins)))


# # Scatter plot with individual trajectories
# p3 <- ggplot(df, aes(x = seq.10001.7, y = ALT)) +
#   geom_point(aes(color = factor(visit)), alpha = 0.6) +
#   geom_path(aes(group = ID), alpha = 0.2) +
#   geom_smooth(method = "lm", color = "black", linewidth= 0.5,se=F) +
#   scale_color_viridis_d(name = "Time") +
#   theme_minimal() +
#   labs(title = "ALT vs Protein Levels",
#        subtitle = "Lines connect same subject over time",
#        x = "Protein Level",
#        y = "ALT Level") +
#   theme(plot.title = element_text(face = "bold"))
# 
# print(p3)
# 
# # # Basic spaghetti plot
# ggplot(df, aes(x = visit, y = ALT, group = ID)) +
#   geom_line(alpha = 0.5, aes(color=ID)) +
#   geom_point(alpha = 0.5, size = 1.5,color="gray40") +
#   labs(title = "ALT Values Over Time by Individual",
#        x = "Visit",
#        y = "ALT") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

# library(lme4)
# library(lmerTest)

# First, ensure time is numeric for random slopes
# Convert visit to numeric (assuming ordered visits)
df$time_numeric <- as.numeric(factor(df$visit)) - 1  # Start at 0 for baseline

```
###i. Unadjusted
```{r}
# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
key <- key %>% 
  dplyr::rename(Protein=AptName)
alt_results <- tidylog::left_join(alt_results,key,by="Protein")
alt_results <- alt_results %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Crude_Results_Proteomics.csv"))

alt_results$color <- ifelse(alt_results$fdr < 0.05 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr < 0.05 & alt_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- alt_results[alt_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_alt
png(fs::path(dir.results,"ALT_Proteins_TeenLabs.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))


```
###ii. Adjusted
```{r}
#Proteomics teen labs 
load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
#Remove na values for visit
df <- df %>% 
  filter(!is.na(visit))

#Protein key
key <- analyte_info %>% 
  dplyr::select(all_of(c("AptName","SeqId","EntrezGeneSymbol")))

#Gene Proteins
genes <- rownames(so_liver_sn)
gene_proteins <- key$AptName[which(key$EntrezGeneSymbol %in% genes)] #3770 proteins


#Merge alt and protein data togeth
df <- df %>% 
  dplyr::select(c("ID","visit","age","SEX","ETHN","bmi","HBA1C","NAFLD0","NAFLD1",
                  "NAFLD2","NAFLD3","NAFLD4","NAFLD5","NAFLD6","ALT","AST",all_of(gene_proteins)))

# First, ensure time is numeric for random slopes
# Convert visit to numeric (assuming ordered visits)
df$time_numeric <- as.numeric(factor(df$visit)) - 1  # Start at 0 for baseline

# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
# alt_results <- tidylog::left_join(alt_results,key,by="Protein")
# alt_results <- alt_results %>% 
#   dplyr::rename(Gene=EntrezGeneSymbol)
write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Adj_Results_Proteomics.csv"))

alt_results$color <- ifelse(alt_results$fdr < 0.05 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr < 0.05 & alt_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- alt_results[alt_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_alt
png(fs::path(dir.results,"ALT_Proteins_TeenLabs_Adjusted.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))

# Model with random intercept for time
ast_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ AST + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  ast_results <- rbind(ast_results,results)
}
ast_results <- ast_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.05,"*",""))


ast_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ AST + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    ast_results <<- rbind(ast_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
ast_results <- ast_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
ast_results <- ast_results %>% 
  filter(Singular=="FALSE")

ast_results <- ast_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
ast_results <- tidylog::left_join(ast_results,key,by="Protein")
ast_results <- ast_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
write.csv(alt_results,fs::path(dir.results,"TeenLABS_AST_Adj_Results_Proteomics.csv"))

ast_results$color <- ifelse(ast_results$fdr < 0.05 & ast_results$Beta > 0, "#990000",
                            ifelse(ast_results$fdr < 0.05 & ast_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- ast_results[ast_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(ast_results$Protein))
ast_results$Outcome <- "AST"

volcano_plot <- ggplot(ast_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_bw() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. AST (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
volcano_plot

# volcano_plot_ast
png(fs::path(dir.results,"AST_Proteins_TeenLabs_Adjusted.png"), width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()

results_ratio$color <- ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR > 0, "#990000",
                              ifelse(results_ratio$fdr<0.1 & results_ratio$LogHR < 0, "#003366", "lightgray"))


# # Identify significant points (fdr<0.1)
# significant_df <- results_ratio[results_ratio$fdr<0.1, ]
# # # Select top 10 up and down LogHR genes per Outcome
# top_labels <- significant_df%>%
#   group_by(Outcome) %>%
#   arrange(desc(LogHR), .by_group = TRUE) %>%
#   # filter(fdr<0.1) %>%
#   slice_head(n = 20) %>%
#   bind_rows(
#     results_ratio %>%
#       group_by(Outcome) %>%
#       arrange(LogHR, .by_group = TRUE) %>% 
#       slice_head(n = 20)
#   ) %>%
#   ungroup()
# Identify significant points (fdr<0.1)
significant_df <- results_ratio[results_ratio$fdr<0.1, ]

# Use significant_df directly for labels
top_labels <- significant_df %>%
  group_by(Outcome) %>%
  arrange(desc(LogHR), .by_group = TRUE) %>%
  ungroup()

Genes <- length(unique(results_ratio$Gene))
# Nuclei <- ncol(so_celltype_hvg)
N <- length(unique(dat$releaseid))
# Nonconvergence_Rate <- nebula_nonconverged_percent
# results_ratio$color3 <- ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 > 0, "lightcoral",
#                               ifelse(results_ratio$fdr3 < 0.2 & results_ratio$LogHR3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr<0.1)
# significant_df3 <- results_ratio[results_ratio$fdr3 < 0.2, ]

max <- max(results_ratio$LogHR)
# max <- 3.1
min <- min(results_ratio$LogHR)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(results_ratio, aes(x = LogHR, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  # theme_minimal() +  # Minimal theme
  theme_bw()+
  labs(
    # title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    # subtitle = "Hep-1, Unadjusted (REML)",
    x = "logHR",
    # y = "-log10(P-Value)",
    color = "LogHR Direction Direction",
    caption = paste0("fdr<0.1, Proteins = ",Genes,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black") +
  geom_text_repel(data = top_labels, 
                  aes(label = Gene),
                  size = 3,
                  color = "black",
                  # Control line segments
                  segment.color = "gray50",
                  segment.size = 0.5,
                  segment.alpha = 0.8,
                  # Control label positioning
                  box.padding = 0.5,
                  point.padding = 0.3,
                  force = 1,
                  max.overlaps = Inf,  # Show all labels (unlike check_overlap = TRUE)
                  # Optional: limit computation time
                  max.time = 1,
                  max.iter = 10000)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")+
  facet_wrap(~Outcome)
```
###iii. FDR<0.1
```{r}
# Model with random intercept for time
alt_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ ALT + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  alt_results <- rbind(alt_results,results)
}
alt_results <- alt_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.1,"*",""))


alt_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ ALT + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    alt_results <- rbind(alt_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    alt_results <<- rbind(alt_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
alt_results <- alt_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr<0.1, "*", ""))
alt_results <- alt_results %>% 
  filter(Singular=="FALSE")

alt_results <- alt_results %>% 
  mutate(sig=case_when(fdr<0.1 & Beta>0 ~ "Significant Positive",
                       fdr<0.1 & Beta<0 ~"Significant Negative",
                       fdr>0.1~"Not Significant"))
#Convert protein names to gene names
key <- key %>%
  dplyr::rename(Protein=AptName)
alt_results <- tidylog::left_join(alt_results,key,by="Protein")
alt_results <- alt_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(alt_results,fs::path(dir.results,"TeenLABS_ALT_Adj_Results_Proteomics_FDR_01.csv"))
write.csv(alt_results,"/home/hhampson/Results/TeenLABS_ALT_Adj_Results_Proteomics_FDR_01_Log2.csv")


alt_results$color <- ifelse(alt_results$fdr<0.1 & alt_results$Beta > 0, "#990000",
                            ifelse(alt_results$fdr<0.1 & alt_results$Beta < 0, "#003366", "lightgray"))


# Identify significant points (fdr<0.1)
significant_df <- alt_results[alt_results$fdr<0.1, ]

# Select top 20 positive and top 20 negative Beta genes from significant results
top_labels <- significant_df %>%
  arrange(desc(Beta)) %>%
  slice_head(n = 20) %>%
  bind_rows(
    significant_df %>%
      arrange(Beta) %>%
      slice_head(n = 20)
  )

# Set variables
N <- length(unique(df$ID))
num_proteins <- length(unique(alt_results$Protein))
alt_results$Outcome <- "ALT"

# Create volcano plot
volcano_plot <- ggplot(alt_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  theme_bw() +
  labs(
    title = "Mixed-Effect Model for Proteins vs. ALT (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("fdr<0.1, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # # Add labels for top positive and negative significant points
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = -0.5, hjust = 0.5, size = 3, check_overlap = TRUE, color = "black") +
  # Add labels with lines pointing to points
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  facet_wrap(~Outcome)

volcano_plot

# volcano_plot_alt
png("/home/hhampson/Results/ALT_Proteins_TeenLabs_Adjusted_FDR_01_log2.png", width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(alt_results,fs::path(dir.results,"ALT_Proteins_Teenlabs.csv"))

# Model with random intercept for time
ast_results <- data.frame()
for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein,"~ AST + time_numeric + (1|ID)+age+SEX"))
  model_simple <- lmer(m0, data = df)
  beta <- summary(model_simple)$coef[2,1]
  pval <- summary(model_simple)$coef[2,5]
  results <- data.frame(Protein=protein,Beta=beta,Pval=pval)
  ast_results <- rbind(ast_results,results)
}
ast_results <- ast_results %>% 
  mutate(fdr = p.adjust(Pval,method="fdr")) %>% 
  mutate(sig=ifelse(fdr<0.1,"*",""))


ast_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ AST + time_numeric + (1|ID)+age+SEX"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    ast_results <- rbind(ast_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    ast_results <<- rbind(ast_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
ast_results <- ast_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr<0.1, "*", ""))
ast_results <- ast_results %>% 
  filter(Singular=="FALSE")

ast_results <- ast_results %>% 
  mutate(sig=case_when(fdr<0.1 & Beta>0 ~ "Significant Positive",
                       fdr<0.1 & Beta<0 ~"Significant Negative",
                       fdr>0.1~"Not Significant"))
#Convert protein names to gene names
# key <- key %>% 
#   dplyr::rename(Protein=AptName)
ast_results <- tidylog::left_join(ast_results,key,by="Protein")
ast_results <- ast_results %>%
  dplyr::rename(Gene=EntrezGeneSymbol)
# write.csv(ast_results,"/home/hhampson/Results/TeenLABS_AST_Adj_Results_Proteomics_FDR_01_log2.csv")

# Identify significant points (fdr<0.1)
# significant_df <- ast_results[ast_results$fdr<0.1, ]
ast_results$color <- ifelse(ast_results$fdr<0.1 & ast_results$Beta > 0, "#990000",
                            ifelse(ast_results$fdr<0.1 & ast_results$Beta < 0, "#003366", "lightgray"))


# Identify significant points (fdr<0.1)
significant_df <- ast_results[ast_results$fdr<0.1, ]

# Select top 20 positive and top 20 negative Beta genes from significant results
top_labels <- significant_df %>%
  arrange(desc(Beta)) %>%
  slice_head(n = 20) %>%
  bind_rows(
    significant_df %>%
      arrange(Beta) %>%
      slice_head(n = 20)
  )

# Set variables
N <- length(unique(df$ID))
num_proteins <- length(unique(ast_results$Protein))
ast_results$Outcome <- "AST"

# Create volcano plot
volcano_plot <- ggplot(ast_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +
  scale_color_identity() +
  theme_bw() +
  labs(
    title = "Mixed-Effect Model for Proteins vs. AST (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("fdr<0.1, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # # Add labels for top positive and negative significant points
  # geom_text(data = top_labels, aes(label = Gene),
  #           vjust = -0.5, hjust = 0.5, size = 3, check_overlap = TRUE, color = "black") +
  # Add labels with lines pointing to points
  geom_label_repel(
    data = top_labels, 
    aes(label = Gene),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    segment.color = 'grey50',  # Color of the connecting lines
    segment.size = 0.5,        # Thickness of lines
    force = 2,                 # Increase to spread labels more
    max.overlaps = Inf,        # Show all labels
    min.segment.length = 0,    # Always draw segments
    seed = 42                  # For reproducibility
  ) +
  facet_wrap(~Outcome)

volcano_plot

# volcano_plot_ast
png("/home/hhampson/Results/AST_Proteins_TeenLabs_Adjusted_FDR_01_log2.png", width = 2200, height = 2000,res=300)
print(volcano_plot)
dev.off()
# write.csv(ast_results,fs::path(dir.results,"AST_Proteins_Teenlabs.csv"))
```

### Other outcomes
```{r}
#NAFLD
NAFLD1_results <- data.frame()
problem_proteins <- data.frame()

for (protein in gene_proteins) {
  m0 <- as.formula(paste0(protein, "~ NAFLD1 + time_numeric + (1|ID)"))
  
  # Track convergence and singularity
  converged <- TRUE
  is_singular <- FALSE
  error_msg <- NA
  
  # Try to fit the model
  tryCatch({
    # Suppress warnings during fitting
    model_simple <- suppressWarnings(lmer(m0, data = df))
    
    # Check for singular fit
    if (isSingular(model_simple)) {
      is_singular <- TRUE
    }
    
    # Extract results
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    # Store results
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    NAFLD1_results <- rbind(NAFLD1_results, results)
    
  }, warning = function(w) {
    # Fit model even with warnings
    model_simple <- lmer(m0, data = df)
    
    # Check what type of warning
    if (grepl("singular", w$message, ignore.case = TRUE)) {
      is_singular <- TRUE
    }
    if (grepl("converge", w$message, ignore.case = TRUE)) {
      converged <- FALSE
    }
    
    beta <- summary(model_simple)$coef[2,1]
    pval <- summary(model_simple)$coef[2,5]
    
    results <- data.frame(
      Protein = protein,
      Beta = beta,
      Pval = pval,
      Converged = converged,
      Singular = is_singular
    )
    NAFLD1_results <- rbind(NAFLD1_results, results)
    
    # Track problematic proteins
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = w$message))
    
  }, error = function(e) {
    # Complete failure - store as NA
    results <- data.frame(
      Protein = protein,
      Beta = NA,
      Pval = NA,
      Converged = FALSE,
      Singular = NA
    )
    NAFLD1_results <<- rbind(NAFLD1_results, results)
    
    problem_proteins <<- rbind(problem_proteins, 
                               data.frame(Protein = protein, 
                                          Issue = e$message))
  })
}

# Add FDR correction only for successful models
NAFLD1_results <- NAFLD1_results %>% 
  mutate(fdr = ifelse(!is.na(Pval), p.adjust(Pval, method = "fdr"), NA)) %>% 
  mutate(sig = ifelse(!is.na(fdr) & fdr < 0.05, "*", ""))
NAFLD1_results <- NAFLD1_results %>% 
  filter(Singular=="FALSE")

NAFLD1_results <- NAFLD1_results %>% 
  mutate(sig=case_when(fdr<0.05 & Beta>0 ~ "Significant Positive",
                       fdr<0.05 & Beta<0 ~"Significant Negative",
                       fdr>0.05~"Not Significant"))
#Convert protein names to gene names
key <- key %>% 
  dplyr::rename(Protein=AptName)
NAFLD1_results <- tidylog::left_join(NAFLD1_results,key,by="Protein")
NAFLD1_results <- NAFLD1_results %>% 
  dplyr::rename(Gene=EntrezGeneSymbol)

NAFLD1_results$color <- ifelse(NAFLD1_results$fdr < 0.05 & NAFLD1_results$Beta > 0, "#990000",
                               ifelse(NAFLD1_results$fdr < 0.05 & NAFLD1_results$Beta < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- NAFLD1_results[NAFLD1_results$fdr < 0.05, ]


N <- length(unique(df$ID))
num_proteins <- length(unique(NAFLD1_results$Protein))

volcano_plot <- ggplot(NAFLD1_results, aes(x = Beta, y = -log10(fdr), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Mixed-Effect Model for Proteins vs. NAFLD1 (U/L)",
    x = "Beta",
    y = "-log10(FDR)",
    color = "Beta Direction",
    caption = paste0("FDR < 0.05, Proteins = ",num_proteins,", N = ",N)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")

# volcano_plot_NAFLD1
png(fs::path(dir.results,"NAFLD1_Proteins_TeenLabs.png"),width=4000,height=4000,res=300)
print(volcano_plot)
dev.off()
```

```{r}
# 
# # Calculate mean ALT for each visit
# mean_data <- df_sub %>%
#   group_by(visit) %>%
#   summarise(mean_ALT = mean(ALT, na.rm = TRUE))
# 
# # Create plot with individual lines and mean trend
# ggplot(df_sub, aes(x = visit, y = ALT)) +
#   geom_line(aes(group = ID), alpha = 0.3, color = "gray60") +
#   geom_point(aes(group = ID), alpha = 0.3, size = 1, color = "gray60") +
#   geom_line(data = mean_data, aes(x = visit, y = mean_ALT, group = 1), 
#             color = "red", size = 2) +
#   geom_point(data = mean_data, aes(x = visit, y = mean_ALT), 
#              color = "red", size = 3) +
#   labs(title = "ALT Values Over Time by Individual",
#        subtitle = "Red line shows mean trend",
#        x = "Visit",
#        y = "ALT") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggplot(df_sub, aes(x = visit, y = ALT, group = ID, color = factor(ID))) +
#   geom_line(alpha = 0.7, size = 1) +
#   geom_point(alpha = 0.7, size = 2) +
#   labs(title = "ALT Values Over Time by Individual",
#        x = "Visit",
#        y = "ALT",
#        color = "Individual ID") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
#   theme(legend.position = "none")
# 
# # Basic spaghetti plot
# ggplot(df_sub, aes(x = visit, y = AST, group = ID)) +
#   geom_line(alpha = 0.5, color = "gray40") +
#   geom_point(alpha = 0.5, size = 1.5, color = "gray40") +
#   labs(title = "AST Values Over Time by Individual",
#        x = "Visit",
#        y = "AST") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# # Calculate mean AST for each visit
# mean_data <- df_sub %>%
#   group_by(visit) %>%
#   summarise(mean_AST = mean(AST, na.rm = TRUE))
# 
# # Create plot with individual lines and mean trend
# ggplot(df_sub, aes(x = visit, y = AST)) +
#   geom_line(aes(group = ID), alpha = 0.3, color = "gray60") +
#   geom_point(aes(group = ID), alpha = 0.3, size = 1, color = "gray60") +
#   geom_line(data = mean_data, aes(x = visit, y = mean_AST, group = 1), 
#             color = "red", size = 2) +
#   geom_point(data = mean_data, aes(x = visit, y = mean_AST), 
#              color = "red", size = 3) +
#   labs(title = "AST Values Over Time by Individual",
#        subtitle = "Red line shows mean trend",
#        x = "Visit",
#        y = "AST") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggplot(df_sub, aes(x = visit, y = AST, group = ID, color = factor(ID))) +
#   geom_line(alpha = 0.7, size = 1) +
#   geom_point(alpha = 0.7, size = 2) +
#   labs(title = "AST Values Over Time by Individual",
#        x = "Visit",
#        y = "AST",
#        color = "Individual ID") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   guides(color = guide_legend(ncol = 2))+  # Adjust legend columns
#   theme(legend.position = "none")
# 
# missing_counts <- df_sub %>%
#   group_by(ID) %>%
#   summarise(
#     total_timepoints = n(),
#     missing_ALT = sum(is.na(ALT)),
#     missing_AST = sum(is.na(AST)),
#     complete_ALT = sum(!is.na(ALT)),
#     complete_AST = sum(!is.na(AST))
#   )
# 
# print(missing_counts)
# 
# # Calculate percentages for ALT
# ALT_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_ALT = sum(missing_ALT >= 1),
#     participants_missing_more_than_5_ALT = sum(missing_ALT > 5),
#     percent_missing_at_least_one_ALT = round(100 * participants_missing_at_least_one_ALT / total_participants, 2),
#     percent_missing_more_than_5_ALT = round(100 * participants_missing_more_than_5_ALT / total_participants, 2)
#   )
# 
# # Calculate percentages for AST
# AST_stats <- missing_counts %>%
#   summarise(
#     total_participants = n(),
#     participants_missing_at_least_one_AST = sum(missing_AST >= 1),
#     participants_missing_more_than_5_AST = sum(missing_AST > 5),
#     percent_missing_at_least_one_AST = round(100 * participants_missing_at_least_one_AST / total_participants, 2),
#     percent_missing_more_than_5_AST = round(100 * participants_missing_more_than_5_AST / total_participants, 2)
#   )

# # Find columns with "baseline" and "followup"
# baseline_cols <- grep("_baseline$", colnames(prot), value = TRUE)
# followup_cols <- grep("_followup$", colnames(prot), value = TRUE)
# 
# # Sort to ensure matching order
# baseline_cols <- sort(baseline_cols)
# followup_cols <- sort(followup_cols)
# 
# # Create new columns for differences
# for (i in seq_along(baseline_cols)) {
#   protein_name <- sub("_baseline$", "", baseline_cols[i])  # Get protein name (e.g., "protein1")
#   diff_col <- paste0(protein_name, "_diff")               # Create a difference column name
#   prot[[diff_col]] <- prot[[followup_cols[i]]] - prot[[baseline_cols[i]]]
# }
# 
# #Covariates at baseline
# dat_cov <- dat %>% 
#   filter(visit=="Month 1") %>% 
#   dplyr::select(all_of(c("ID","SEX","HBA1C","age"))) 
# 
# rm(df,analyte_info)
# 
#ALT/AST
# liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
liv <- liv %>%
  dplyr::rename(visit=Visit) %>%
  # filter(visit==1 | visit==6) %>%
  # mutate(visit=case_when(visit==1~"Month 1",
  #                        visit==6~"Month 6")) %>%
  mutate(across(everything(),~ifelse(.==-5,NA,.))) %>%
  mutate(across(everything(),~ifelse(.==-7,1,.))) %>% 
  filter(!is.na(ALT) & !is.na(AST))
#201 have alt and/or ast

# liv_baseline <- liv %>% 
#   filter(visit=="Month 1") %>% 
#   dplyr::select(-visit) %>% 
#   dplyr::rename(ALT_baseline=ALT,
#                 AST_baseline=AST)
# liv_followup <- liv %>% 
#   filter(visit=="Month 6") %>% 
#   dplyr::select(-visit) %>% 
#   dplyr::rename(ALT_followup=ALT,
#                 AST_followup=AST)
# liv <- tidylog::left_join(liv_baseline,liv_followup,by="ID")
# liv <- liv %>% 
#   mutate(ALT_diff = ALT_followup-ALT_baseline,
#          AST_diff = AST_followup-AST_baseline) 
# 
# 
# dat_cov$ID <- as.character(dat_cov$ID)
prot$ID<- as.character(prot$ID)
# 
# #Baseline proteins & baseline covariates and baseline and followup alt/ast
# dat_all <- tidylog::right_join(dat_cov,liv,by=c("ID"))
# dat_all <- tidylog::left_join(dat_all,prot,by=c("ID"))
dat_all <- tidylog::left_join(liv,prot,by=c("ID"))
# 
# #Run linear mixed effect model & difference model 
# protein_diff <- paste0(protein,"_diff")
# results <- data.frame()
# covs <- c("age","SEX","HBA1C")
# for (x in protein_diff) {
#   for (y in c("AST_diff","ALT_diff")) {
#     M0_crude <- as.formula(paste0(y,"~",x))
#     M0_adj <- as.formula(paste0(y,"~",x,"+",paste(covs, collapse = "+")))
#     M1_crude <- lm(M0_crude,data=dat_all)
#     M1_adj <- lm(M0_adj,data=dat_all)
#     coef_crude <- summary(M1_crude)$coef[2,1]
#     coef_adj <- summary(M1_adj)$coef[2,1]
#     p_crude <- summary(M1_crude)$coef[2,4]
#     p_adj <- summary(M1_adj)$coef[2,4]
#     diff_results <- data.frame(Protein=x,Enzyme=y,Coef=coef_adj,PValue=p_adj)
#     results <- rbind(results,diff_results)
#   }
# }
# r_alt <- results %>% 
#   filter(Enzyme=="ALT_diff") %>% 
#   mutate(fdr=p.adjust(PValue,method="fdr"))
# r_ast <- results %>% 
#   filter(Enzyme=="AST_diff") %>% 
#   mutate(fdr=p.adjust(PValue,method="fdr"))
# results <- rbind(r_alt,r_ast)
# results <- results %>% 
#   mutate(sig=ifelse(fdr<0.05,"*",""))
# write.csv(results,fs::path(dir.results,"Diff_Results_Liver_Teenlabs_Imputed.csv"))
# 
# #Baseline protein with change in ALT/AST pre and post surgery
# liv <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Teen Labs/Data_Cleaned/Teen-LABS_AST_ALT.csv")
# liv <- liv %>% 
#   dplyr::rename(visit=Visit) %>% 
#   filter(visit==1 | visit==6) %>% 
#   mutate(visit=case_when(visit==1~"Month 1",
#                          visit==6~"Month 6")) %>% 
#   mutate(across(everything(),~ifelse(.==-5,NA,.))) %>% 
#   mutate(across(everything(),~ifelse(.==-7,NA,.)))
# prot_baseline_dat$ID <- as.character(prot_baseline_dat$ID)
# dat_baseline <- tidylog::left_join(liv,prot_baseline_dat,by=c("ID"))
# dat_baseline <- tidylog::left_join(dat_cov,dat_baseline,by="ID")
# dat_baseline <- dat_baseline %>% 
#   mutate(time=case_when(visit=="Month 1"~1,
#                         visit=="Month 6"~6))
# 
# #Linear Mixed Effects Model
# protein_baseline <- paste0(protein,"_baseline")
# covs <- c("age","SEX","HBA1C")
# 
# results <- data.frame()
# for (x in c("AST","ALT")) {
#   for (y in protein_baseline) {
#     M0_crude <- as.formula(paste0(y,"~",x,"+time+(1|ID)"))
#     M0_adj <- as.formula(paste0(y,"~",x,"*time+",paste(covs, collapse = "+"),"+(1|ID)"))
#     M1_crude <- lmer(M0_crude,data=dat_baseline)
#     M1_adj <- lmer(M0_adj,data=dat_baseline)
#     Main <- summary(M1_adj)$coef[2,1]
#     Main_p <- summary(M1_adj)$coef[2,5]
#     Time <- summary(M1_adj)$coef[3,1]
#     Time_p <- summary(M1_adj)$coef[3,5]
#     Int <- summary(M1_adj)$coef[7,1]
#     Int_p <- summary(M1_adj)$coef[7,5]
#     results_int <- data.frame(Protein=x,Enzyme=y,Main,Main_p,Time,Time_p,Int,Int_p)
#     results <- rbind(results,results_int)
#   }
# }
# r_alt <- results %>% 
#   filter(Enzyme=="ALT") %>% 
#   mutate(Main_fdr=p.adjust(Main_p,method="fdr")) %>% 
#   mutate(Int_fdr=p.adjust(Int_p,method="fdr"))
# r_ast <- results %>% 
#   filter(Enzyme=="AST") %>% 
#   mutate(Main_fdr=p.adjust(Main_p,method="fdr")) %>% 
#   mutate(Int_fdr=p.adjust(Int_p,method="fdr"))
# results <- rbind(r_alt,r_ast)
# results <- results %>% 
#   mutate(Main_sig=ifelse(Main_fdr<0.05,"*","")) %>% 
#   mutate(Int_sig=ifelse(Int_fdr<0.05,"*",""))
# results$AptName <- str_remove(results$Protein,"_baseline")
# results <- tidylog::left_join(results,key,by="AptName")
# write.csv(results,fs::path(dir.results,"LMEM_TeenLabs_Liver_Results_Imputed.csv"))
```
###ii. Old
```{r}
#Proteomics teen labs 
load(fs::path(dir.dat,"Teen Labs","Data_Cleaned","analysis_dataset.RData"))
#Senescence Proteins
sens_proteins <- analyte_info$AptName[which(analyte_info$EntrezGeneSymbol %in% sens_genes)]

alt_ast <- read.csv(fs::path(dir.dat,"Liver Project","Teen-LABS_AST_ALT.csv")) %>% 
  filter(Visit==1|Visit==6) %>% 
  mutate(Visit=ifelse(Visit==1,"PreSurgery","PostSurgery"))
df_baseline <- df %>% 
  filter(visit=="Month 1") %>% 
  dplyr::rename(Visit=visit) %>% 
  mutate(Visit="PreSurgery") %>% 
  mutate(ID=as.character(ID)) %>% 
  dplyr::select(all_of(c("ID",sens_proteins)))
# df_followup <- df %>% 
#   filter(visit=="Month 6") %>% 
#   dplyr::rename(Visit=visit) %>% 
#   mutate(Visit="PostSurgery") %>% 
#   mutate(ID=as.character(ID)) %>% 
#   dplyr::select(all_of(c("ID","Visit",sens_proteins)))

#Prepare data
dat_baseline <- tidylog::left_join(alt_ast,df_baseline,by=c("ID"))
dat <- dat_baseline
rm(dat_baseline)
# dat_followup <- tidylog::left_join(dat,df_followup,by=c("ID"))
# dat_all <- tidylog::left_join(dat,df,by=c("ID","Visit"))

hist(dat$AST)
hist(dat$ALT)
#Log transform alt and ast
dat$ALT_log <- log(dat$ALT)
dat$AST_log <- log(dat$AST)
dat$Visit <- factor(dat$Visit)
dat$Visit <- relevel(dat$Visit, ref = "PreSurgery")

# #Make sure everyone has baseline proteins
# prot <- df %>% 
#   dplyr::select(c("ID","Visit",sens_proteins))

#Linear Mixed Effects Model
#ALT
plot_list <- list()
results <- data.frame()
for (protein in sens_proteins) {
  gene_name <- paste0(analyte_info$EntrezGeneSymbol[which(analyte_info$AptName %in% protein)],"_",analyte_info$SeqId[which(analyte_info$AptName %in% protein)])
  M0 <- as.formula(paste0("ALT_log ~ ",protein,"*Visit + (1 | ID)"))
  M1 <- lmer(M0, data = dat)
  main_effect <- summary(M1)$coef[2,1]
  main_p <- summary(M1)$coef[2,5]
  time_effect <- summary(M1)$coef[3,1]
  time_p <- summary(M1)$coef[3,5]
  int_effect <- summary(M1)$coef[4,1]
  int_p <- summary(M1)$coef[4,5]
  results_dat <- data.frame(Apt=gene_name,Outcome="ALT_log",MainEffect=main_effect,MainPVal=main_p,TimeEffect=time_effect,TimePVal=time_p,Interaction=int_effect,IntPVal=int_p)
  results <- rbind(results,results_dat)
  
  int_plot <- ggplot(dat, aes(x = !!sym(protein), y = ALT_log, color = Visit)) +
    geom_point() +
    geom_smooth(method = "lm", se = TRUE) +
    labs(title = paste0("Interaction between ",gene_name," and Visit on ALT_log"))+
    theme_minimal()
  
  # Create the spaghetti plot
  spaghetti_plot <- ggplot(dat, aes(x = Visit, y = ALT_log, group = ID, color = !!sym(protein))) +
    geom_line() +  # Connect ALT levels for each individual
    geom_point() +  # Add points for ALT levels at each time point
    # scale_color_viridis_d(guide = "none") +  # Optional: Viridis color palette, hide legend
    # scale_color_viridis_c(guide = "colorbar", name = "Protein") +
    scale_color_gradient(low = "blue", high = "red", name = gene_name) +
    # scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(dat[[protein]],na.rm=T), name = "Protein") +
    labs(
      title = paste0("Spaghetti Plot of ALT Levels Pre- and Post-Surgery by ",gene_name),
      x = "Visit",
      y = "ALT Levels"
    ) +
    theme_minimal() +
    theme(panel.grid.major = element_line(color = "gray85")) 
  
  # Combine the two plots
  combined_plot <- plot_grid(int_plot, spaghetti_plot, ncol = 1, labels = c("A", "B"))
  
  # Add to the list
  plot_list[[protein]] <- combined_plot
}

write.csv(results,fs::path(dir.results,paste0("Interaction between ",gene_name," and Visit on ALT_log.csv")))
# # Save all combined plots to a single PDF
# pdf("combined_interaction_and_spaghetti_plots.pdf", width = 10, height = 14)
# for (combined_plot in plot_list) {
#   plot(combined_plot)
# }
# dev.off()

#AST
plot_list <- list()
results <- data.frame()
for (protein in sens_proteins) {
  gene_name <- paste0(analyte_info$EntrezGeneSymbol[which(analyte_info$AptName %in% protein)],"_",analyte_info$SeqId[which(analyte_info$AptName %in% protein)])
  M0 <- as.formula(paste0("AST_log ~ ",protein,"*Visit + (1 | ID)"))
  M1 <- lmer(M0, data = dat)
  main_effect <- summary(M1)$coef[2,1]
  main_p <- summary(M1)$coef[2,5]
  time_effect <- summary(M1)$coef[3,1]
  time_p <- summary(M1)$coef[3,5]
  int_effect <- summary(M1)$coef[4,1]
  int_p <- summary(M1)$coef[4,5]
  results_dat <- data.frame(Apt=gene_name,Outcome="AST_log",MainEffect=main_effect,MainPVal=main_p,TimeEffect=time_effect,TimePVal=time_p,Interaction=int_effect,IntPVal=int_p)
  results <- rbind(results,results_dat)
  
  int_plot <- ggplot(dat, aes(x = !!sym(protein), y = ALT_log, color = Visit)) +
    geom_point() +
    geom_smooth(method = "lm", se = TRUE) +
    labs(title = paste0("Interaction between ",gene_name," and Visit on AST_log"))+
    theme_minimal()
  
  # Create the spaghetti plot
  spaghetti_plot <- ggplot(dat, aes(x = Visit, y = ALT_log, group = ID, color = !!sym(protein))) +
    geom_line() +  # Connect ALT levels for each individual
    geom_point() +  # Add points for ALT levels at each time point
    # scale_color_viridis_d(guide = "none") +  # Optional: Viridis color palette, hide legend
    # scale_color_viridis_c(guide = "colorbar", name = "Protein") +
    scale_color_gradient(low = "blue", high = "red", name = gene_name) +
    # scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = median(dat[[protein]],na.rm=T), name = "Protein") +
    labs(
      title = paste0("Spaghetti Plot of AST Levels Pre- and Post-Surgery by ",gene_name),
      x = "Visit",
      y = "ALT Levels"
    ) +
    theme_minimal() +
    theme(panel.grid.major = element_line(color = "gray85")) 
  
  # Combine the two plots
  combined_plot <- plot_grid(int_plot, spaghetti_plot, ncol = 1, labels = c("A", "B"))
  
  # Add to the list
  plot_list[[protein]] <- combined_plot
}

write.csv(results,fs::path(dir.results,paste0("Interaction between ",gene_name," and Visit on AST_log.csv")))
# # Save all combined plots to a single PDF
# pdf("combined_interaction_and_spaghetti_plots.pdf", width = 10, height = 14)
# for (combined_plot in plot_list) {
#   plot(combined_plot)
# }
# dev.off()
```


#7. Overlap Analysis & Interpretation
##a. DEGs
```{r}
# Gene Expression Pattern Analysis Across Multiple Datasets
# Author: Generated for multi-dataset comparison
# Purpose: Compare gene expression patterns across 6 CSV files

# Load required libraries
library(dplyr)
library(readr)
library(purrr)
library(ggplot2)
library(VennDiagram)
library(pheatmap)

# Function to read and process a single CSV file
process_gene_data <- function(file_path, dataset_name) {
  # Read the CSV file
  data <- read.csv(file_path)
  
  #Format
  data <- data %>% 
    dplyr::rename(LogFC=`logFC_steatosis_catHigh.Steatosis..2.3.`)
  
  # Filter for significant genes (FDR < 0.05)
  sig_data <- data %>%
    filter(fdr < 0.05) %>%
    mutate(
      dataset = dataset_name,
      direction = case_when(
        LogFC > 0 ~ "Up",
        LogFC < 0 ~ "Down",
        TRUE ~ "No_change"
      ),
      abs_logfc = abs(LogFC)
    ) %>%
    dplyr::select(Gene, LogFC, fdr, dataset, direction, abs_logfc)
  
  return(sig_data)
}

# Main analysis function
analyze_gene_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_gene_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_genes = n(),
      upregulated = sum(direction == "Up"),
      downregulated = sum(direction == "Down"),
      mean_abs_logfc = round(mean(abs_logfc), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  # Find genes present in multiple datasets
  gene_counts <- all_data %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Genes in multiple datasets
  multi_dataset_genes <- gene_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== GENES FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total genes appearing in >1 dataset:", nrow(multi_dataset_genes), "\n")
  
  # Detailed comparison for genes in multiple datasets
  detailed_comparison <- all_data %>%
    filter(Gene %in% multi_dataset_genes$Gene) %>%
    dplyr::select(Gene, dataset, LogFC, fdr, direction) %>%
    arrange(Gene, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      logfc_values = paste(round(LogFC, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_logfc = round(mean(abs(LogFC)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_logfc))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP GENES WITH CONSISTENT DIRECTIONS ===\n")
  consistent_genes <- direction_summary %>%
    filter(consistent_direction == TRUE) %>%
    head(20)
  
  print(consistent_genes)
  
  cat("\n=== GENES WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_genes <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_genes) > 0) {
    print(inconsistent_genes)
  } else {
    cat("No genes with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of up/down regulation by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Gene Expression by Dataset and Direction",
         x = "Dataset", y = "Number of Genes", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Up" = "darkred", "Down" = "#264653"))
  
  # Plot 2: Heatmap of gene presence across datasets (for top multi-dataset genes)
  # if(nrow(multi_dataset_genes) > 0) {
  #   top_genes <- head(multi_dataset_genes$Gene, 2000)  # Top 50 genes
  #   
  #   heatmap_data <- all_data %>%
  #     filter(Gene %in% top_genes) %>%
  #     dplyr::select(Gene, dataset, LogFC) %>%
  #     tidyr::pivot_wider(names_from = dataset, values_from = LogFC, values_fill = 0) %>%
  #     column_to_rownames("Gene") %>%
  #     as.matrix()
  #   
  #   # Create heatmap
  #   if(nrow(heatmap_data) > 1) {
  #     p <- pheatmap(heatmap_data, 
  #              main = "LogFC Heatmap for Top Multi-Dataset Genes",
  #              cluster_rows = TRUE,
  #              cluster_cols = TRUE,
  #              scale = "none",
  #              color = colorRampPalette(c("blue", "white", "red"))(100))
  #   }
  # }
  # Plot 2: Heatmap of gene presence across datasets (for top multi-dataset genes)
  if (nrow(multi_dataset_genes) > 0) {
    top_genes <- head(multi_dataset_genes$Gene, 2000)  # Top 50 genes
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      dplyr::select(Gene, dataset, LogFC) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = LogFC, values_fill = 0) %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    # Create star matrix where fdr < 0.05
    star_matrix_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      mutate(star = ifelse(fdr < 0.05, "*", "")) %>%
      dplyr::select(Gene, dataset, star) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = star, values_fill = "") %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    
    # Define your desired column order
    custom_order <- c("Hepatocytes","Hep1","Hep2","Hep3","Hep4","Hep5","dHep")  # Replace with your actual order
    
    # Reorder columns
    # Reorder columns
    heatmap_data <- heatmap_data[, custom_order]
    star_matrix_data <- star_matrix_data[, custom_order]
    
    
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      p <- pheatmap(
        heatmap_data,
        main = "LogFC Heatmap for Top Multi-Dataset Genes\n* = FDR < 0.05",
        cluster_rows = TRUE,
        cluster_cols = FALSE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45 
      )
    }
  }
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_genes = multi_dataset_genes,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = p
  )
  
  return(results)
}

# Example usage:
# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv", 
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_4_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv"
)

dataset_names <- c(
  "Hepatocytes",
  "Hep1",
  "Hep2", 
  "Hep3",
  "Hep4", 
  "Hep5",
  "dHep"
)

# Run the analysis
results <- analyze_gene_patterns(file_paths, dataset_names)
#Save heatmap
png(fs::path(dir.results, "Gene_Overlap_Heatmap_Hepatocytes.png"), 
    width = 3000, height = 2100, res = 300)
print(results$heatmap)
dev.off()


# Additional utility functions

# Function to create Venn diagram for gene overlap (works for 2-5 datasets)
create_venn_diagram <- function(results_data, max_datasets = 5) {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(length(datasets) > max_datasets) {
    datasets <- datasets[1:max_datasets]
    cat("Limiting Venn diagram to first", max_datasets, "datasets\n")
  }
  
  gene_lists <- list()
  
  for(ds in datasets) {
    gene_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(Gene)
  }
  
  # Create Venn diagram
  venn.plot <- venn.diagram(
    x = gene_lists,
    category.names = names(gene_lists),
    filename = NULL,
    output = TRUE,
    fill = rainbow(length(gene_lists)),
    alpha = 0.5
  )
  
  grid::grid.draw(venn.plot)
}
create_venn_diagram(results)
create_venn_diagram(results, selected_datasets = c("Dataset1", "Dataset2", "Dataset3"))
create_venn_diagram(results, selected_datasets = c("Dataset1", "Dataset2", "Dataset3", "Dataset4"))
# Modified function that saves to file
create_venn_diagram_file <- function(results_data, selected_datasets = NULL, filename = "venn_diagram.png") {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  gene_lists <- list()
  
  for(ds in datasets) {
    gene_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(Gene)
  }
  
  # Create and save Venn diagram
  venn.plot <- venn.diagram(
    x = gene_lists,
    category.names = names(gene_lists),
    filename = filename,  # This saves to file
    output = TRUE,
    fill = rainbow(length(gene_lists)),
    alpha = 0.5,
    margin = 0.1,
    resolution = 300,
    compression = "lzw"
  )
  
  cat("Venn diagram saved to:", filename, "\n")
  return(venn.plot)
}

# Use it like this:
create_venn_diagram_file(results, 
                         selected_datasets = c("Hep1","Hep2","Hep3","Hep4","Hep5"),
                         filename = "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/venn_hep1_to_hep5.png")


# Function to export results to files
export_results <- function(results, output_dir = dir.results) {
  
  if(!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Export summary tables
  write_csv(results$summary_stats, 
            file.path(output_dir, "dataset_summary.csv"))
  
  write_csv(results$direction_summary, 
            file.path(output_dir, "direction_consistency_summary.csv"))
  
  write_csv(results$detailed_comparison, 
            file.path(output_dir, "detailed_gene_comparison.csv"))
  
  # Save plot
  ggsave(file.path(output_dir, "expression_direction_plot.png"), 
         results$plot, width = 10, height = 6, dpi = 300)
  
  cat("Results exported to:", output_dir, "\n")
}
export_results(results)

# Instructions:
cat("=== INSTRUCTIONS FOR USE ===\n")
cat("1. Update 'file_paths' with your actual CSV file paths\n")
cat("2. Update 'dataset_names' with descriptive names for your datasets\n")
cat("3. Run: results <- analyze_gene_patterns(file_paths, dataset_names)\n")
cat("4. Optional: create_venn_diagram(results)\n")
cat("5. Optional: export_results(results)\n")
cat("6. View results$direction_summary for main findings\n")
# Run 
results <- analyze_gene_patterns(file_paths, dataset_names)
```

##b. Pathways
###i. Go
```{r}
# Pathway Analysis Across Multiple Datasets
# Author: Generated for multi-dataset pathway comparison
# Purpose: Compare pathway enrichment patterns across multiple CSV files

# Load required libraries
library(dplyr)
library(readr)
library(purrr)
library(ggplot2)
library(VennDiagram)
library(pheatmap)

# Function to read and process a single pathway file
process_pathway_data <- function(file_path, dataset_name) {
  # Read the CSV/RDS file
  if(grepl("\\.rds$", file_path)) {
    data <- readRDS(file_path)
  } else {
    data <- read_csv(file_path)
  }
  
  # Filter for significant pathways (pval < 0.05)
  sig_data <- data %>%
    filter(pval < 0.05) %>%
    mutate(
      dataset = dataset_name,
      direction = case_when(
        NES > 0 ~ "Positive",
        NES < 0 ~ "Negative",
        TRUE ~ "No_change"
      ),
      abs_nes = abs(NES)
    ) %>%
    dplyr::select(pathway, NES, pval, dataset, direction, abs_nes)
  
  return(sig_data)
}

# Main analysis function
analyze_pathway_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_pathway_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_pathways = n(),
      positive_enriched = sum(direction == "Positive"),
      negative_enriched = sum(direction == "Negative"),
      mean_abs_nes = round(mean(abs_nes), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  # Find pathways present in multiple datasets
  pathway_counts <- all_data %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Pathways in multiple datasets
  multi_dataset_pathways <- pathway_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== PATHWAYS FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total pathways appearing in >1 dataset:", nrow(multi_dataset_pathways), "\n")
  
  # Detailed comparison for pathways in multiple datasets
  detailed_comparison <- all_data %>%
    filter(pathway %in% multi_dataset_pathways$pathway) %>%
    dplyr::select(pathway, dataset, NES, pval, direction) %>%
    arrange(pathway, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      nes_values = paste(round(NES, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_nes = round(mean(abs(NES)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_nes))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP PATHWAYS WITH CONSISTENT DIRECTIONS ===\n")
  consistent_pathways <- direction_summary %>%
    filter(consistent_direction == TRUE) %>%
    head(20)
  
  print(consistent_pathways)
  
  cat("\n=== PATHWAYS WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_pathways <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_pathways) > 0) {
    print(inconsistent_pathways)
  } else {
    cat("No pathways with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of positive/negative enrichment by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Pathway Enrichment by Dataset and Direction",
         x = "Dataset", y = "Number of Pathways", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Positive" = "darkred", "Negative" = "darkblue"))
  
  # Plot 2: Heatmap of pathway NES scores across datasets
  if (nrow(multi_dataset_pathways) > 0) {
    
    top_pathways <- head(multi_dataset_pathways$pathway, 100)  # Top 50 pathways
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      dplyr::select(pathway, dataset, NES) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = NES, values_fill = 0) %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Create star matrix where pval < 0.05
    star_matrix_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      mutate(star = ifelse(pval < 0.05, "*", "")) %>%
      dplyr::select(pathway, dataset, star) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = star, values_fill = "") %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Define your desired column order (update with your actual dataset names)
    custom_order <- intersect(dataset_names, colnames(heatmap_data))
    
    # Reorder columns
    heatmap_data <- heatmap_data[, custom_order]
    star_matrix_data <- star_matrix_data[, custom_order]
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      p2 <- pheatmap(
        heatmap_data,
        main = "NES Heatmap for Top Multi-Dataset Pathways\n* = p-value < 0.05",
        cluster_rows = TRUE,
        cluster_cols = FALSE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45,
        fontsize_row = 8,
        number_color = "white"
      )
    }
  }
  
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_pathways = multi_dataset_pathways,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = if(exists("p2")) p2 else NULL
  )
  
  return(results)
}

# Function to create Venn diagram for pathway overlap
create_pathway_venn_diagram <- function(results_data, selected_datasets = NULL, max_datasets = 5) {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) > max_datasets) {
    datasets <- datasets[1:max_datasets]
    cat("Limiting Venn diagram to first", max_datasets, "datasets\n")
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = NULL,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5
  )
  
  grid::grid.draw(venn.plot)
  return(venn.plot)
}

# Function to save Venn diagram to file
create_pathway_venn_diagram_file <- function(results_data, selected_datasets = NULL, filename = "GO_pathway_venn_diagram.png") {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create and save Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = filename,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5,
    margin = 0.1,
    resolution = 300,
    compression = "lzw"
  )
  
  cat("Pathway Venn diagram saved to:", filename, "\n")
  return(venn.plot)
}

# Function to export results to files
export_pathway_results <- function(results, output_dir = dir.results) {
  
  if(!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Export summary tables
  write_csv(results$summary_stats, 
            file.path(output_dir, "GO_pathway_dataset_summary.csv"))
  
  write_csv(results$direction_summary, 
            file.path(output_dir, "GO_pathway_direction_consistency_summary.csv"))
  
  write_csv(results$detailed_comparison, 
            file.path(output_dir, "GO_detailed_pathway_comparison.csv"))
  
  # Save plot
  ggsave(file.path(output_dir, "GO_pathway_enrichment_direction_plot.png"), 
         results$plot, width = 10, height = 6, dpi = 300)
  
  # Save heatmap if it exists
  if(!is.null(results$heatmap)) {
    png(file.path(output_dir, "GO_pathway_overlap_heatmap.png"), 
        width = 3000, height = 2100, res = 300)
    print(results$heatmap)
    dev.off()
  }
  
  cat("Pathway results exported to:", output_dir, "\n")
}

# Example usage:
# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hepatocytes_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_1_Steatosis_GO.rds", 
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_2_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_3_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_4_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_5_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/dHep_Steatosis_GO.rds"
)

dataset_names <- c(
  "Hepatocytes",
  "Hep1",
  "Hep2", 
  "Hep3",
  "Hep4", 
  "Hep5",
  "dHep"
)

# Run the analysis
results <- analyze_pathway_patterns(file_paths, dataset_names)

#Save heatmap
png(fs::path(dir.results, "Pathway_Overlap_Heatmap_Hepatocytes_GO.png"), 
    width = 5000, height = 6000, res = 300)
print(results$heatmap)
dev.off()

# Create visualizations
# create_pathway_venn_diagram(results)
# create_pathway_venn_diagram_file(results, filename = "my_pathway_venn.png")

# Export results
export_pathway_results(results)

# Instructions:
cat("=== INSTRUCTIONS FOR USE ===\n")
cat("1. Update 'file_paths' with your actual pathway file paths\n")
cat("2. Update 'dataset_names' with descriptive names for your datasets\n")
cat("3. Ensure your data files have columns: 'pathway', 'pval', 'NES'\n")
cat("4. Run: results <- analyze_pathway_patterns(file_paths, dataset_names)\n")
cat("5. Optional: create_pathway_venn_diagram(results)\n")
cat("6. Optional: export_pathway_results(results)\n")
cat("7. View results$direction_summary for main findings\n")
cat("8. Look for pathways with consistent vs inconsistent NES directions\n")
```
###ii. Reactome
```{r}
# Pathway Analysis Across Multiple Datasets
# Author: Generated for multi-dataset pathway comparison
# Purpose: Compare pathway enrichment patterns across multiple CSV files

# Load required libraries
library(dplyr)
library(readr)
library(purrr)
library(ggplot2)
library(VennDiagram)
library(pheatmap)

# Function to read and process a single pathway file
process_pathway_data <- function(file_path, dataset_name) {
  # Read the CSV/RDS file
  if(grepl("\\.rds$", file_path)) {
    data <- readRDS(file_path)
  } else {
    data <- read_csv(file_path)
  }
  
  # Filter for significant pathways (pval < 0.05)
  sig_data <- data %>%
    filter(pval < 0.05) %>%
    mutate(
      dataset = dataset_name,
      direction = case_when(
        NES > 0 ~ "Positive",
        NES < 0 ~ "Negative",
        TRUE ~ "No_change"
      ),
      abs_nes = abs(NES)
    ) %>%
    dplyr::select(pathway, NES, pval, dataset, direction, abs_nes)
  
  return(sig_data)
}

# Main analysis function
analyze_pathway_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_pathway_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_pathways = n(),
      positive_enriched = sum(direction == "Positive"),
      negative_enriched = sum(direction == "Negative"),
      mean_abs_nes = round(mean(abs_nes), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  # Find pathways present in multiple datasets
  pathway_counts <- all_data %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Pathways in multiple datasets
  multi_dataset_pathways <- pathway_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== PATHWAYS FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total pathways appearing in >1 dataset:", nrow(multi_dataset_pathways), "\n")
  
  # Detailed comparison for pathways in multiple datasets
  detailed_comparison <- all_data %>%
    filter(pathway %in% multi_dataset_pathways$pathway) %>%
    dplyr::select(pathway, dataset, NES, pval, direction) %>%
    arrange(pathway, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      nes_values = paste(round(NES, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_nes = round(mean(abs(NES)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_nes))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP PATHWAYS WITH CONSISTENT DIRECTIONS ===\n")
  consistent_pathways <- direction_summary %>%
    filter(consistent_direction == TRUE) %>%
    head(20)
  
  print(consistent_pathways)
  
  cat("\n=== PATHWAYS WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_pathways <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_pathways) > 0) {
    print(inconsistent_pathways)
  } else {
    cat("No pathways with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of positive/negative enrichment by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Pathway Enrichment by Dataset and Direction",
         x = "Dataset", y = "Number of Pathways", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Positive" = "darkred", "Negative" = "darkblue"))
  
  # Plot 2: Heatmap of pathway NES scores across datasets
  if (nrow(multi_dataset_pathways) > 0) {
    
    top_pathways <- head(multi_dataset_pathways$pathway, 2000)  # Top 50 pathways
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      dplyr::select(pathway, dataset, NES) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = NES, values_fill = 0) %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Create star matrix where pval < 0.05
    star_matrix_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      mutate(star = ifelse(pval < 0.05, "*", "")) %>%
      dplyr::select(pathway, dataset, star) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = star, values_fill = "") %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Define your desired column order (update with your actual dataset names)
    custom_order <- intersect(dataset_names, colnames(heatmap_data))
    
    # Reorder columns
    heatmap_data <- heatmap_data[, custom_order]
    star_matrix_data <- star_matrix_data[, custom_order]
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      p2 <- pheatmap(
        heatmap_data,
        main = "NES Heatmap for Top Multi-Dataset Pathways\n* = p-value < 0.05",
        cluster_rows = TRUE,
        cluster_cols = FALSE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45,
        fontsize_row = 8,
        number_color = "white"
      )
    }
  }
  
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_pathways = multi_dataset_pathways,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = if(exists("p2")) p2 else NULL
  )
  
  return(results)
}

# Function to create Venn diagram for pathway overlap
create_pathway_venn_diagram <- function(results_data, selected_datasets = NULL, max_datasets = 5) {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) > max_datasets) {
    datasets <- datasets[1:max_datasets]
    cat("Limiting Venn diagram to first", max_datasets, "datasets\n")
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = NULL,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5
  )
  
  grid::grid.draw(venn.plot)
  return(venn.plot)
}

# Function to save Venn diagram to file
create_pathway_venn_diagram_file <- function(results_data, selected_datasets = NULL, filename = "pathway_venn_diagram.png") {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create and save Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = filename,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5,
    margin = 0.1,
    resolution = 300,
    compression = "lzw"
  )
  
  cat("Pathway Venn diagram saved to:", filename, "\n")
  return(venn.plot)
}

# Function to export results to files
export_pathway_results <- function(results, output_dir = dir.results) {
  
  if(!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Export summary tables
  write_csv(results$summary_stats, 
            file.path(output_dir, "pathway_dataset_summary.csv"))
  
  write_csv(results$direction_summary, 
            file.path(output_dir, "pathway_direction_consistency_summary.csv"))
  
  write_csv(results$detailed_comparison, 
            file.path(output_dir, "detailed_pathway_comparison.csv"))
  
  # Save plot
  ggsave(file.path(output_dir, "pathway_enrichment_direction_plot.png"), 
         results$plot, width = 10, height = 6, dpi = 300)
  
  # Save heatmap if it exists
  if(!is.null(results$heatmap)) {
    png(file.path(output_dir, "pathway_overlap_heatmap.png"), 
        width = 3000, height = 2100, res = 300)
    print(results$heatmap)
    dev.off()
  }
  
  cat("Pathway results exported to:", output_dir, "\n")
}

# Example usage:
# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hepatocytes_Steatosis_Reactome.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_1_Steatosis_Reactome.rds", 
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_2_Steatosis_Reactome.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_3_Steatosis_Reactome.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_4_Steatosis_Reactome.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_5_Steatosis_Reactome.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/dHep_Steatosis_Reactome.rds"
)

dataset_names <- c(
  "Hepatocytes",
  "Hep1",
  "Hep2", 
  "Hep3",
  "Hep4", 
  "Hep5",
  "dHep"
)

# Run the analysis
results <- analyze_pathway_patterns(file_paths, dataset_names)

#Save heatmap
png(fs::path(dir.results, "Pathway_Overlap_Heatmap_Hepatocytes.png"), 
    width = 4000, height = 2100, res = 300)
print(results$heatmap)
dev.off()

# Create visualizations
# create_pathway_venn_diagram(results)
# create_pathway_venn_diagram_file(results, filename = "my_pathway_venn.png")

# Export results
export_pathway_results(results)

# Instructions:
cat("=== INSTRUCTIONS FOR USE ===\n")
cat("1. Update 'file_paths' with your actual pathway file paths\n")
cat("2. Update 'dataset_names' with descriptive names for your datasets\n")
cat("3. Ensure your data files have columns: 'pathway', 'pval', 'NES'\n")
cat("4. Run: results <- analyze_pathway_patterns(file_paths, dataset_names)\n")
cat("5. Optional: create_pathway_venn_diagram(results)\n")
cat("6. Optional: export_pathway_results(results)\n")
cat("7. View results$direction_summary for main findings\n")
cat("8. Look for pathways with consistent vs inconsistent NES directions\n")
```

##c. With ALT/AST
###i. DEGs
####I. Format
```{r}
# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hepatocytes_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv", 
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_2_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_4_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_5_Steatosis_unadjusted_2000_pooled_offset.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_dHep_Steatosis_unadjusted_2000_pooled_offset.csv"
)

dataset_names <- c(
  "Hepatocytes",
  "Hep1",
  "Hep2", 
  "Hep3",
  "Hep4", 
  "Hep5",
  "dHep"
)
# all_data <-read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/NEBULA_Hep_3_Steatosis_unadjusted_2000_pooled_offset.csv")
process_gene_data <- function(file_path, dataset_name) {
  # Read the CSV file
  data <- read.csv(file_path)
  
  #Format
  data <- data %>% 
    dplyr::rename(LogFC=`logFC_steatosis_catHigh.Steatosis..2.3.`) %>% 
    dplyr::rename(p_value=`p_steatosis_catHigh.Steatosis..2.3.`)
  
  # Filter for significant genes (FDR < 0.05)
  sig_data <- data %>%
    filter(fdr < 0.05) %>%
    mutate(
      dataset = dataset_name,
      direction = case_when(
        LogFC > 0 ~ "Up",
        LogFC < 0 ~ "Down",
        TRUE ~ "No_change"
      ),
      abs_logfc = abs(LogFC)
    ) %>%
    dplyr::select(Gene, LogFC, p_value,fdr, dataset, direction, abs_logfc)
  
  return(sig_data)
}
analyze_gene_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_gene_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_genes = n(),
      upregulated = sum(direction == "Up"),
      downregulated = sum(direction == "Down"),
      mean_abs_logfc = round(mean(abs_logfc), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  # Find genes present in multiple datasets
  gene_counts <- all_data %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Genes in multiple datasets
  multi_dataset_genes <- gene_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== GENES FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total genes appearing in >1 dataset:", nrow(multi_dataset_genes), "\n")
  
  # Detailed comparison for genes in multiple datasets
  detailed_comparison <- all_data %>%
    filter(Gene %in% multi_dataset_genes$Gene) %>%
    dplyr::select(Gene, dataset, LogFC, fdr, direction) %>%
    arrange(Gene, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      logfc_values = paste(round(LogFC, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_logfc = round(mean(abs(LogFC)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_logfc))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP GENES WITH CONSISTENT DIRECTIONS ===\n")
  consistent_genes <- direction_summary %>%
    filter(consistent_direction == TRUE) %>%
    head(20)
  
  print(consistent_genes)
  
  cat("\n=== GENES WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_genes <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_genes) > 0) {
    print(inconsistent_genes)
  } else {
    cat("No genes with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of up/down regulation by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Gene Expression by Dataset and Direction",
         x = "Dataset", y = "Number of Genes", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Up" = "darkred", "Down" = "#264653"))
  
  # Plot 2: Heatmap of gene presence across datasets (for top multi-dataset genes)
  # if(nrow(multi_dataset_genes) > 0) {
  #   top_genes <- head(multi_dataset_genes$Gene, 2000)  # Top 50 genes
  #   
  #   heatmap_data <- all_data %>%
  #     filter(Gene %in% top_genes) %>%
  #     dplyr::select(Gene, dataset, LogFC) %>%
  #     tidyr::pivot_wider(names_from = dataset, values_from = LogFC, values_fill = 0) %>%
  #     column_to_rownames("Gene") %>%
  #     as.matrix()
  #   
  #   # Create heatmap
  #   if(nrow(heatmap_data) > 1) {
  #     p <- pheatmap(heatmap_data, 
  #              main = "LogFC Heatmap for Top Multi-Dataset Genes",
  #              cluster_rows = TRUE,
  #              cluster_cols = TRUE,
  #              scale = "none",
  #              color = colorRampPalette(c("blue", "white", "red"))(100))
  #   }
  # }
  # Plot 2: Heatmap of gene presence across datasets (for top multi-dataset genes)
  if (nrow(multi_dataset_genes) > 0) {
    top_genes <- head(multi_dataset_genes$Gene, 2000)  # Top 50 genes
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      dplyr::select(Gene, dataset, LogFC) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = LogFC, values_fill = 0) %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    # Create star matrix where fdr < 0.05
    star_matrix_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      mutate(star = ifelse(fdr < 0.05, "*", "")) %>%
      dplyr::select(Gene, dataset, star) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = star, values_fill = "") %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    
    # Define your desired column order
    custom_order <- c("Hepatocytes","Hep1","Hep2","Hep3","Hep4","Hep5","dHep")  # Replace with your actual order
    
    # Reorder columns
    # Reorder columns
    heatmap_data <- heatmap_data[, custom_order]
    star_matrix_data <- star_matrix_data[, custom_order]
    
    
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      p <- pheatmap(
        heatmap_data,
        main = "LogFC Heatmap for Top Multi-Dataset Genes\n* = FDR < 0.05",
        cluster_rows = TRUE,
        cluster_cols = FALSE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45 
      )
    }
  }
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_genes = multi_dataset_genes,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = p
  )
  
  return(results)
}
# Function to create summary dataframe matching original format
create_gene_summary <- function(results) {
  
  # Extract all data from the results object
  all_data <- results$all_data
  # all_data <- all_data %>% 
  #   dplyr::rename(LogFC=`logFC_steatosis_catHigh.Steatosis..2.3.`) %>% 
  # dplyr::rename(p_value=`p_steatosis_catHigh.Steatosis..2.3.`)
  # 
  # Create summary with same column structure as original data
  gene_summary <- all_data %>%
    group_by(Gene) %>%
    summarise(
      LogFC = mean(LogFC),  # Average LogFC across all datasets
      Pvalue = min(p_value), 
      fdr = min(fdr),       # Best (minimum) FDR across all datasets
      .groups = 'drop'
    ) %>%
    mutate(
      dataset = "Summary",
      direction = case_when(
        LogFC > 0 ~ "Up",
        LogFC < 0 ~ "Down",
        TRUE ~ "No_change"
      ),
      abs_logfc = abs(LogFC)
    ) %>%
    dplyr::select(Gene, LogFC, Pvalue, fdr, dataset, direction, abs_logfc)
  
  return(gene_summary)
}

results <- analyze_gene_patterns(file_paths, dataset_names)
summary_data <- create_gene_summary(results)
saveRDS(summary_data,fs::path(dir.results,"Summary_Hepatocytes_Dataframe.rds"))
write.csv(summary_data,fs::path(dir.results,"Summary_Hepatocytes_Dataframe.csv"))

#Alter alt and ast names
data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/today_subeomics_ALT_hvg.csv")
data <- data %>% 
  dplyr::rename(LogFC=LogHR) %>% 
  dplyr::rename(Gene=EntrezGeneSymbol) %>% 
  mutate(dataset="ALT")
write.csv(data,"/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_today_subeomics_ALT_hvg.csv")

data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/today_subeomics_AST_hvg.csv")
data <- data %>% 
  dplyr::rename(LogFC=LogHR) %>% 
  dplyr::rename(Gene=EntrezGeneSymbol) %>% 
  mutate(dataset="AST")
write.csv(data,"/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_today_subeomics_AST_hvg.csv")
```

####II. Analyze
```{r}
# Function to read and process a single CSV file
process_gene_data <- function(file_path, dataset_name) {
  # Read the CSV file
  data <- read.csv(file_path)
  
  #Format
  # data <- data %>% 
  #   dplyr::rename(LogFC=LogHR) %>% 
  #   dplyr::rename(Gene=EntrezGeneSymbol)
  
  # Filter for significant genes (FDR < 0.05)
  sig_data <- data %>%
    filter(Pvalue < 0.1) %>%
    mutate(
      dataset = dataset_name,
      direction = case_when(
        LogFC > 0 ~ "Up",
        LogFC < 0 ~ "Down",
        TRUE ~ "No_change"
      ),
      abs_logfc = abs(LogFC)
    ) %>%
    dplyr::select(Gene, LogFC, Pvalue,fdr, dataset, direction, abs_logfc)
  
  return(sig_data)
}

# Main analysis function
analyze_gene_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_gene_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_genes = n(),
      upregulated = sum(direction == "Up"),
      downregulated = sum(direction == "Down"),
      mean_abs_logfc = round(mean(abs_logfc), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  # Find genes present in multiple datasets
  gene_counts <- all_data %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Genes in multiple datasets
  multi_dataset_genes <- gene_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== GENES FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total genes appearing in >1 dataset:", nrow(multi_dataset_genes), "\n")
  
  # Detailed comparison for genes in multiple datasets
  detailed_comparison <- all_data %>%
    filter(Gene %in% multi_dataset_genes$Gene) %>%
    dplyr::select(Gene, dataset, Pvalue, LogFC, fdr, direction) %>%
    arrange(Gene, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(Gene) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      logfc_values = paste(round(LogFC, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_logfc = round(mean(abs(LogFC)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_logfc))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP GENES WITH CONSISTENT DIRECTIONS ===\n")
  consistent_genes <- direction_summary %>%
    filter(consistent_direction == TRUE) 
  # head(20)
  
  print(consistent_genes)
  
  cat("\n=== GENES WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_genes <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_genes) > 0) {
    print(inconsistent_genes)
  } else {
    cat("No genes with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of up/down regulation by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Gene Expression by Dataset and Direction",
         x = "Dataset", y = "Number of Genes", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Up" = "darkred", "Down" = "darkblue"))
  
  # Plot 2: Heatmap of gene presence across datasets (for top multi-dataset genes)
  if (nrow(multi_dataset_genes) > 0) {
    top_genes <- (multi_dataset_genes$Gene)  # Top 50 genes
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      dplyr::select(Gene, dataset, LogFC) %>%
      complete(Gene, dataset, fill = list(LogFC = 0))  # <-- fills in missing combinations with 0
    
    heatmap_data <- heatmap_data %>% 
      group_by(dataset,Gene) %>% 
      summarise(LogFC = mean(LogFC, na.rm = TRUE), .groups = "drop") %>% 
      ungroup()
    
    heatmap_data <- heatmap_data %>% 
      pivot_wider(names_from = dataset, values_from = LogFC) %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    # Create star matrix where fdr < 0.05
    star_matrix_data <- all_data %>%
      filter(Gene %in% top_genes) %>%
      complete(Gene, dataset, fill = list(Pvalue = 1))   # <-- fills in missing combinations with 0
    
    star_matrix_data <- star_matrix_data %>% 
      group_by(dataset,Gene) %>% 
      summarise(Pvalue = min(Pvalue, na.rm = TRUE), .groups = "drop") %>% 
      ungroup() %>% 
      mutate(star = ifelse(Pvalue < 0.1, "*","")) %>%
      mutate(star = ifelse(Pvalue < 0.05, "**",star)) %>%
      #                      ifelse(Pvalue < 0.2, "*",""))) %>%
      # mutate(star = case_when(Pvalue < 0.2 ~ "*",
      #                         Pvalue < 0.05 ~ "**",
      #                         Pvalue > 0.2 ~ "")) %>% 
      dplyr::select(Gene, dataset, star) 
    
    star_matrix_data <- star_matrix_data %>% 
      pivot_wider(names_from = dataset, values_from = star) %>%
      column_to_rownames("Gene") %>%
      as.matrix()
    
    
    # Define your desired column order
    # custom_order <- c("Hepatocytes","AST","ALT")  # Replace with your actual order
    
    # Reorder columns
    # Reorder columns
    # heatmap_data <- heatmap_data[, custom_order]
    # star_matrix_data <- star_matrix_data[, custom_order]
    
    
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      # Create breaks that center white at 0
      max_val <- max(abs(heatmap_data), na.rm = TRUE)
      breaks <- seq(-max_val, max_val, length.out = 101)
      
      p <- pheatmap(
        heatmap_data,
        main = "LogFC Heatmap for Top Multi-Dataset Genes\n* = Pvalue < 0.1, ** = Pvalue < 0.05",
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        breaks = breaks,
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45,
        number_color = "black"
      )
      # p <- pheatmap(
      #   heatmap_data,
      #   main = "LogFC Heatmap for Top Multi-Dataset Genes\n* = Pvalue < 0.2, ** = Pvalue < 0.05",
      #   cluster_rows = TRUE,
      #   cluster_cols = TRUE,
      #   scale = "none",
      #   # color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
      #   display_numbers = star_matrix_data,
      #   fontsize_number = 14,
      #   angle_col = 45,
      #   number_color = "white"
      # )
    }
  }
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_genes = multi_dataset_genes,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = p
  )
  
  return(results)
}


# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Summary_Hepatocytes_Dataframe.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_today_subeomics_ALT_hvg.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_today_subeomics_AST_hvg.csv"
)

dataset_names <- c(
  "Hepatocytes",
  "ALT",
  "AST"
)

# Run the analysis
results <- analyze_gene_patterns(file_paths, dataset_names)
#Save heatmap
png(fs::path(dir.results, "Gene_Overlap_Heatmap_Transcriptomics_Proteomics_white_stars_01.png"), 
    width = 3000, height = 3000, res = 300)
print(results$heatmap)
dev.off()


# Additional utility functions
# Function to create Venn diagram for gene overlap (works for 2-5 datasets)
create_venn_diagram <- function(results_data, max_datasets = 5) {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(length(datasets) > max_datasets) {
    datasets <- datasets[1:max_datasets]
    cat("Limiting Venn diagram to first", max_datasets, "datasets\n")
  }
  
  gene_lists <- list()
  
  for(ds in datasets) {
    gene_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(Gene)
  }
  
  # Create Venn diagram
  venn.plot <- venn.diagram(
    x = gene_lists,
    category.names = names(gene_lists),
    filename = NULL,
    output = TRUE,
    fill = rainbow(length(gene_lists)),
    alpha = 0.5
  )
  
  grid::grid.draw(venn.plot)
}
create_venn_diagram(results)
# create_venn_diagram(results, selected_datasets = c("Dataset1", "Dataset2", "Dataset3"))
# create_venn_diagram(results, selected_datasets = c("Dataset1", "Dataset2", "Dataset3", "Dataset4"))
# Modified function that saves to file
create_venn_diagram_file <- function(results_data, selected_datasets = NULL, filename = "venn_diagram.png") {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  gene_lists <- list()
  
  for(ds in datasets) {
    gene_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(Gene)
  }
  
  # Create and save Venn diagram
  venn.plot <- venn.diagram(
    x = gene_lists,
    category.names = names(gene_lists),
    filename = filename,  # This saves to file
    output = TRUE,
    fill = rainbow(length(gene_lists)),
    alpha = 0.5,
    margin = 0.1,
    resolution = 300,
    compression = "lzw"
  )
  
  cat("Venn diagram saved to:", filename, "\n")
  return(venn.plot)
}

# Use it like this:
create_venn_diagram_file(results, 
                         selected_datasets = c("Hepatocytes","ALT","AST"),
                         filename = "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/venn_Hep_ALT_AST.png")


# Function to export results to files
export_results <- function(results, output_dir = dir.results) {
  
  if(!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Export summary tables
  write_csv(results$summary_stats, 
            file.path(output_dir, "dataset_summary.csv"))
  
  write_csv(results$direction_summary, 
            file.path(output_dir, "direction_consistency_summary.csv"))
  
  write_csv(results$detailed_comparison, 
            file.path(output_dir, "detailed_gene_comparison.csv"))
  
  # Save plot
  ggsave(file.path(output_dir, "expression_direction_plot.png"), 
         results$plot, width = 6, height = 6, dpi = 300)
  
  cat("Results exported to:", output_dir, "\n")
}
export_results(results)

# Instructions:
cat("=== INSTRUCTIONS FOR USE ===\n")
cat("1. Update 'file_paths' with your actual CSV file paths\n")
cat("2. Update 'dataset_names' with descriptive names for your datasets\n")
cat("3. Run: results <- analyze_gene_patterns(file_paths, dataset_names)\n")
cat("4. Optional: create_venn_diagram(results)\n")
cat("5. Optional: export_results(results)\n")
cat("6. View results$direction_summary for main findings\n")
# Run 

results <- analyze_gene_patterns(file_paths, dataset_names)
```
###i. Pathways
####I. Format
```{r}
# Replace these with your actual file paths and names
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hepatocytes_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_1_Steatosis_GO.rds", 
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_2_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_3_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_4_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Hep_5_Steatosis_GO.rds",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/dHep_Steatosis_GO.rds"
)

dataset_names <- c(
  "Hepatocytes",
  "Hep1",
  "Hep2", 
  "Hep3",
  "Hep4", 
  "Hep5",
  "dHep"
)

# Read in all RDS files and combine
all_data_list <- list()
for(i in 1:length(file_paths)) {
  data <- readRDS(file_paths[i])
  data$dataset <- dataset_names[i]
  all_data_list[[i]] <- data
}
all_data <- bind_rows(all_data_list)

# Filter for significant pathways (adjust threshold as needed)
all_data <- all_data %>%
  filter(pval < 0.05)

# Create summary with pathway, average NES, and best p-value
pathway_summary <- all_data %>%
  group_by(pathway) %>%  # replace 'pathway' with actual pathway column name
  summarise(
    NES = round(mean(NES, na.rm = TRUE), 4),  # replace 'NES' with actual NES column name
    pvalue= min(pval, na.rm = TRUE),            # replace 'pval' with actual p-value column name
    # padj_best = min(padj, na.rm = TRUE),              # replace 'padj' with actual adjusted p-value column name
    n_datasets = n(),                                 # Number of datasets pathway appears in
    .groups = 'drop'
  ) %>%
  arrange(desc(abs(NES))) %>% 
  ungroup() %>% 
  mutate(LogPValue=-log(pvalue)) %>% 
  mutate(dataset="Hepatocytes") %>% 
  filter(LogPValue>-log(0.05))

# Save the results
saveRDS(pathway_summary, fs::path(dir.results, "Summary_Pathways_Dataframe.rds"))
write.csv(pathway_summary, fs::path(dir.results, "Summary_Pathways_Dataframe.csv"), row.names = FALSE)

#Alter alt and ast names
data <- readxl::read_xls("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/IPA Results/AST_pathways.xls",skip=1)
data <- data %>% 
  dplyr::rename(pathway=`Ingenuity Canonical Pathways`) %>% 
  dplyr::rename(LogPValue=`-log(p-value)`)%>%
  # mutate(pvalue = exp(LogPValue)) %>% 
  dplyr::rename(NES=`z-score`) %>% 
  mutate(dataset="AST") %>% 
  filter(LogPValue>-log(0.05))
write.csv(data,"/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_AST_pathways.csv")

data <- readxl::read_xls("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/IPA Results/ALT_pathways.xls",skip=1)
data <- data %>% 
  dplyr::rename(pathway=`Ingenuity Canonical Pathways`) %>% 
  dplyr::rename(LogPValue=`-log(p-value)`) %>% 
  # mutate(pvalue = exp(LogPValue)) %>% 
  dplyr::rename(NES=`z-score`) %>% 
  mutate(dataset="ALT") %>% 
  filter(LogPValue>-log(0.05))
write.csv(data,"/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_ALT_pathways.csv")
```

####II. Analyze
```{r}
file_paths <- c(
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Summary_Pathways_Dataframe.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_ALT_pathways.csv",
  "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_AST_pathways.csv"
)

dataset_names <- c(
  "Hepatocytes",
  "ALT",
  "AST"
)
# file_paths <- c(
#   "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Summary_Pathways_Dataframe.csv")
# 
# dataset_names <- c(
#   "Hepatocytes")
# 
# data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Formatted_ALT_pathways.csv")
# data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Liver project/NEBULA Results/Summary_Pathways_Dataframe.csv")
# Function to read and process a single pathway file


process_pathway_data <- function(file_path, dataset_name) {
  # Read the CSV/RDS file
  if(grepl("\\.rds$", file_path)) {
    data <- readRDS(file_path)
  } else {
    data <- read.csv(file_path)
  }
  
  # Filter for significant pathways (LogPValue < 0.05)
  sig_data <- data %>%
    mutate(NES=ifelse(is.na(NES),0,NES)) %>% 
    # dplyr::rename(LogPValue=LogPValue) %>% 
    filter(LogPValue > -log(0.05)) %>% 
    mutate(direction = case_when(
      NES > 0 ~ "Positive",
      NES < 0 ~ "Negative",
      # is.na(NES) ~ "NA",
      TRUE ~ "No_change"
    ),
    abs_nes = abs(NES)
    ) %>%
    dplyr::select(pathway, NES, LogPValue, dataset, direction, abs_nes)
  
  return(sig_data)
}

# Main analysis function
analyze_pathway_patterns <- function(file_paths, dataset_names) {
  
  # Check if file_paths and dataset_names have same length
  if(length(file_paths) != length(dataset_names)) {
    stop("Number of file paths must match number of dataset names")
  }
  
  # Process all files
  cat("Processing", length(file_paths), "datasets...\n")
  
  all_data <- map2_dfr(file_paths, dataset_names, process_pathway_data)
  
  # Summary statistics
  cat("\n=== DATASET SUMMARY ===\n")
  summary_stats <- all_data %>%
    group_by(dataset) %>%
    summarise(
      total_sig_pathways = n(),
      positive_enriched = sum(direction == "Positive"),
      negative_enriched = sum(direction == "Negative"),
      mean_abs_nes = round(mean(abs_nes), 3),
      .groups = 'drop'
    )
  
  print(summary_stats)
  
  all_data <- all_data %>% 
    mutate(pathway_origional=pathway) %>% 
    mutate(pathway = str_remove(pathway,"^GO")) %>%
    mutate(pathway = str_remove(pathway, "^[A-Z]{2}_")) %>% 
    mutate(pathway=str_replace_all(pathway,"_", " ") )%>%
    mutate(pathway=str_to_title(pathway) ) %>% 
    arrange(pathway)
  
  # all_data1 <- all_data %>%
  #   dplyr::slice(1:200)
  # all_data2 <- all_data %>%
  #   dplyr::slice(200:400)
  # all_data3 <- all_data %>%
  #   dplyr::slice(400:600)
  # all_data4 <- all_data %>%
  #   dplyr::slice(600:767)
  # write.csv(all_data1,fs::path(dir.results,"GO_IPA_Key1.csv"))
  # write.csv(all_data2,fs::path(dir.results,"GO_IPA_Key2.csv"))
  # write.csv(all_data3,fs::path(dir.results,"GO_IPA_Key3.csv"))
  # write.csv(all_data4,fs::path(dir.results,"GO_IPA_Key4.csv"))
  
  # Find pathways present in multiple datasets
  pathway_counts <- all_data %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n_distinct(dataset),
      datasets = paste(unique(dataset), collapse = ", "),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets))
  
  # Pathways in multiple datasets
  multi_dataset_pathways <- pathway_counts %>%
    filter(n_datasets > 1)
  
  cat("\n=== PATHWAYS FOUND IN MULTIPLE DATASETS ===\n")
  cat("Total pathways appearing in >1 dataset:", nrow(multi_dataset_pathways), "\n")
  
  # Detailed comparison for pathways in multiple datasets
  detailed_comparison <- all_data %>%
    filter(pathway %in% multi_dataset_pathways$pathway) %>%
    dplyr::select(pathway, dataset, NES, LogPValue, direction) %>%
    arrange(pathway, dataset)
  
  # Create direction consistency summary
  direction_summary <- detailed_comparison %>%
    group_by(pathway) %>%
    summarise(
      n_datasets = n(),
      datasets = paste(dataset, collapse = ", "),
      directions = paste(direction, collapse = ", "),
      nes_values = paste(round(NES, 3), collapse = ", "),
      consistent_direction = length(unique(direction)) == 1,
      direction_type = ifelse(length(unique(direction)) == 1, 
                              unique(direction), 
                              "Mixed"),
      mean_abs_nes = round(mean(abs(NES)), 3),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_datasets), desc(mean_abs_nes))
  
  cat("\n=== DIRECTION CONSISTENCY ANALYSIS ===\n")
  consistency_stats <- direction_summary %>%
    group_by(consistent_direction) %>%
    summarise(
      count = n(),
      .groups = 'drop'
    )
  
  print(consistency_stats)
  
  cat("\n=== TOP PATHWAYS WITH CONSISTENT DIRECTIONS ===\n")
  consistent_pathways <- direction_summary %>%
    filter(consistent_direction == TRUE) %>%
    head(20)
  
  print(consistent_pathways)
  
  cat("\n=== PATHWAYS WITH INCONSISTENT DIRECTIONS ===\n")
  inconsistent_pathways <- direction_summary %>%
    filter(consistent_direction == FALSE)
  
  if(nrow(inconsistent_pathways) > 0) {
    print(inconsistent_pathways)
  } else {
    cat("No pathways with inconsistent directions found.\n")
  }
  
  # Create visualization data
  viz_data <- all_data %>%
    group_by(dataset, direction) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Plot 1: Bar plot of positive/negative enrichment by dataset
  p1 <- ggplot(viz_data, aes(x = dataset, y = count, fill = direction)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Significant Pathway Enrichment by Dataset and Direction",
         x = "Dataset", y = "Number of Pathways", fill = "Direction") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Positive" = "darkred", "Negative" = "darkblue"))
  
  # Plot 2: Heatmap of pathway NES scores across datasets
  if (nrow(multi_dataset_pathways) > 0) {
    
    top_pathways <- head(multi_dataset_pathways$pathway, 2000)  # Top 50 pathways
    
    # Create the main heatmap matrix
    heatmap_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      dplyr::select(pathway, dataset, NES) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = NES, values_fill = 0) %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Create star matrix where LogPValue < 0.05
    star_matrix_data <- all_data %>%
      filter(pathway %in% top_pathways) %>%
      mutate(star = ifelse(LogPValue > -log(0.05), "*", "")) %>%
      dplyr::select(pathway, dataset, star) %>%
      tidyr::pivot_wider(names_from = dataset, values_from = star, values_fill = "") %>%
      column_to_rownames("pathway") %>%
      as.matrix()
    
    # Define your desired column order (update with your actual dataset names)
    # custom_order <- intersect(dataset_names, colnames(heatmap_data))
    
    # Reorder columns
    # heatmap_data <- heatmap_data[, custom_order]
    # star_matrix_data <- star_matrix_data[, custom_order]
    
    # Plot heatmap with stars
    if (nrow(heatmap_data) > 1) {
      p2 <- pheatmap(
        heatmap_data,
        main = "NES Heatmap for Top Multi-Dataset Pathways\n* = p-value < 0.05",
        cluster_rows = TRUE,
        cluster_cols = FALSE,
        scale = "none",
        color = colorRampPalette(c("darkblue", "white", "darkred"))(100),
        display_numbers = star_matrix_data,
        fontsize_number = 14,
        angle_col = 45,
        fontsize_row = 8,
        number_color = "gray"
      )
    }
  }
  
  # Return results
  results <- list(
    summary_stats = summary_stats,
    multi_dataset_pathways = multi_dataset_pathways,
    direction_summary = direction_summary,
    detailed_comparison = detailed_comparison,
    all_data = all_data,
    plot = p1,
    heatmap = if(exists("p2")) p2 else NULL
  )
  
  return(results)
}

# Function to create Venn diagram for pathway overlap
create_pathway_venn_diagram <- function(results_data, selected_datasets = NULL, max_datasets = 5) {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) > max_datasets) {
    datasets <- datasets[1:max_datasets]
    cat("Limiting Venn diagram to first", max_datasets, "datasets\n")
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = NULL,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5
  )
  
  grid::grid.draw(venn.plot)
  return(venn.plot)
}

# Function to save Venn diagram to file
create_pathway_venn_diagram_file <- function(results_data, selected_datasets = NULL, filename = "GO_pathway_venn_diagram.png") {
  
  datasets <- unique(results_data$all_data$dataset)
  
  if(!is.null(selected_datasets)) {
    datasets <- intersect(datasets, selected_datasets)
  }
  
  if(length(datasets) < 2 || length(datasets) > 5) {
    cat("Need 2-5 datasets for Venn diagram\n")
    return(NULL)
  }
  
  pathway_lists <- list()
  
  for(ds in datasets) {
    pathway_lists[[ds]] <- results_data$all_data %>%
      filter(dataset == ds) %>%
      pull(pathway)
  }
  
  # Create and save Venn diagram
  venn.plot <- venn.diagram(
    x = pathway_lists,
    category.names = names(pathway_lists),
    filename = filename,
    output = TRUE,
    fill = rainbow(length(pathway_lists)),
    alpha = 0.5,
    margin = 0.1,
    resolution = 300,
    compression = "lzw"
  )
  
  cat("Pathway Venn diagram saved to:", filename, "\n")
  return(venn.plot)
}

# Function to export results to files
export_pathway_results <- function(results, output_dir = dir.results) {
  
  if(!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Export summary tables
  write_csv(results$summary_stats, 
            file.path(output_dir, "GO_pathway_dataset_summary.csv"))
  
  write_csv(results$direction_summary, 
            file.path(output_dir, "GO_pathway_direction_consistency_summary.csv"))
  
  write_csv(results$detailed_comparison, 
            file.path(output_dir, "GO_detailed_pathway_comparison.csv"))
  
  # Save plot
  ggsave(file.path(output_dir, "GO_pathway_enrichment_direction_plot.png"), 
         results$plot, width = 10, height = 6, dpi = 300)
  
  # Save heatmap if it exists
  if(!is.null(results$heatmap)) {
    png(file.path(output_dir, "GO_pathway_overlap_heatmap.png"), 
        width = 3000, height = 2100, res = 300)
    print(results$heatmap)
    dev.off()
  }
  
  cat("Pathway results exported to:", output_dir, "\n")
}

# Run the analysis
results <- analyze_pathway_patterns(file_paths, dataset_names)

#Save heatmap
png(fs::path(dir.results, "Pathway_Overlap_Heatmap_Hepatocytes_GO.png"), 
    width = 3000, height = 4000, res = 300)
print(results$heatmap)
dev.off()

# Create visualizations
# create_pathway_venn_diagram(results)
# create_pathway_venn_diagram_file(results, filename = "my_pathway_venn.png")

# Export results
export_pathway_results(results)



```


#8. ALT/AST/GGT with Genes NEBULA in snRNAseq 
## b. Hep-1
```{r}
#Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
# so_celltype$steatosis_cat <- factor(so_celltype$steatosis_cat)
so_celltype$alt 

#Make sure to set reference level
# so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
# so_celltype$steatosis_cat <- relevel(so_celltype$steatosis_cat,ref="Low Steatosis (0+1)")

#Round counts layer for nb
# counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round
counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")[hvgs, ]) # load counts and round

# List of genes
genes_list <- rownames(counts_hvg)

# With parallelization
cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)


# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_alt`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_alt`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv"))

# full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_alt` > 0, "lightcoral",
#                              ifelse(full_results$fdr < 0.05 & full_results$`logFC_alt` < 0, "lightblue", "gray"))
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_alt` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_alt` < 0, "#003366", "lightgray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_alt`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_alt`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_alt`)
# max <- 3.1
min <- min(full_results$`logFC_alt`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_alt`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "Hep-1, Unadjusted (REML,Log Normal,Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_Hep_1_Steatosis_unadjusted_2000_hvg_reml_offset.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.png"),
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
```

### iii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"NEBULA_Hep_1_Steatosis_unadjusted_2000_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_steatosis_cat_high_steatosis_2_3)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_Hepatocytes <- full_results$LogFC
names(rankings_Hepatocytes) <- full_results$Gene
rankings_Hepatocytes <- sort(rankings_Hepatocytes, decreasing = TRUE)
plot(rankings_Hepatocytes)
min(rankings_Hepatocytes)
max(rankings_Hepatocytes)

set.seed(1234)

kegg_legacy_res_Hepatocytes <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_Hepatocytes,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_Hepatocytes <- fgsea(pathways = reactome,
                                  stats = rankings_Hepatocytes,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
reactome_res_Hepatocytes <- data.frame(reactome_res_Hepatocytes)
saveRDS(reactome_res_Hepatocytes,fs::path(dir.results,"Hep_1_Steatosis_Reactome.rds"))
go_res_Hepatocytes <- fgsea(pathways = go,
                            stats = rankings_Hepatocytes,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)
saveRDS(go_res_Hepatocytes,fs::path(dir.results,"Hep_1_Steatosis_GO.rds"))

Hepatocytes_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_Hepatocytes[, padj < 0.05]), sum(kegg_legacy_res_Hepatocytes[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_Hepatocytes[, padj < 0.05]), sum(reactome_res_Hepatocytes[, pval < 0.05])),
                                "GO"=c(sum(go_res_Hepatocytes[, padj < 0.05]), sum(go_res_Hepatocytes[, pval < 0.05])))
rownames(Hepatocytes_fgsea) <- c("adj.pval", "p.val")
Hepatocytes_fgsea

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_Hepatocytes, title = "Hep-1 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"Hepatocytes_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"Hep_1_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Hep_1_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iv. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_liver_sn,celltype=="Hep-1")
DefaultAssay(so_celltype) <- "RNA" 


genes_list <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
so_celltype_hvg <- subset(so_celltype, features =genes_list)
DefaultAssay(so_celltype_hvg) <- "RNA"
so_celltype_hvg$steatosis_cat <- factor(so_celltype_hvg$steatosis_cat)
#Make sure to set reference level
so_celltype_hvg$steatosis_cat <- relevel(so_celltype_hvg$steatosis_cat,ref="Low Steatosis (0+1)")
nrow(so_celltype_hvg) #28964 genes
Nuclei <- ncol(so_celltype_hvg) #130124 nuclei

counts_hvg <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization

cl <- makeCluster(1)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype_hvg,features=g)@meta.data
    pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
    # library <- meta_gene$pooled_offset
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
#   tryCatch({
#     count_gene <- counts_hvg[g, , drop = FALSE]
#     meta_gene <- .subset(so_celltype_hvg,features=g)@meta.data
#     pred_gene <- model.matrix(~steatosis_cat, data = meta_gene)
#     library <- meta_gene$pooled_offset
#     data_g_gene <- group_cell(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene,offset=library)
#     
#     if (is.null(data_g_gene)) {
#       data_g_gene <- list(count = count_gene, id = meta_gene$Kit_Lot, pred = pred_gene, offset = library)
#     }
#     
#     #With offset
#     result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset = data_g_gene$offset)
#     
#     list(gene = g, result = result)  # return both gene name and result
#     
#   }, error = function(e) {
#     NULL
#   })
# }

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

hep_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(hep_nebula_converged$Gene[which(hep_nebula_converged$Convergence_Code==-40)]
) 

full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_alt`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_alt`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Genes_NEBULA_Hep_1_Steatosis_unadjusted.csv"))

# Calculate Confidence Intervals (95% CI)
full_results <- full_results %>%
  mutate(
    CI_Lower = `logFC_alt` - 1.96 * `se_alt`,
    CI_Upper = `logFC_alt` + 1.96 * `se_alt`
  )
full_results <- full_results %>% 
  mutate(sig=ifelse(`p_alt`<0.05,"*",""))

# Create the coefficient plot
dot_plot <- ggplot(full_results, aes(x = `logFC_alt`, y = Gene)) +
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2, color="orange") +  # Add horizontal error bars for CIs
  geom_point(size = 3,color="purple") +  # Add points for the Beta (Log2FC)
  # geom_point(size = 3,aes(color=sig)) +  # Add points for the Beta (Log2FC)
  labs(title = "Steatosis (High vs. Low) in All Cell Types",
       subtitle = "Hep-1, Unadjusted (REML, Log Normal, Offset)",
       x = "LogFC", y = "Gene",
       caption=paste0("Nuclei = ",Nuclei) )+
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        text =element_text(size=10)) 
dot_plot

png(fs::path(dir.results, "Plot_Targeted_Genes_NEBULA_Hep_1_Steatosis_unadjusted.png"),
    width = 2500, height = 2100, res = 300)
print(dot_plot)
dev.off()


#Examine distributions 
target_genes <- c("PNPLA3","GCKR","TM6SF2","APOC3","MTOR")
# Step 1: Pull expression for gene PNPLA3
gene_expr <- FetchData(so_celltype, vars = target_genes)

# Step 2: Pull metadata for steatosis_cat
metadata <- so_celltype@meta.data["steatosis_cat"]

# Step 3: Combine into one dataframe
df <- cbind(gene_expr, metadata)
# colnames(df) <- c("PNPLA3", "steatosis_cat")

# Step 4: Plot using ggplot
ggplot(df, aes(x = PNPLA3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "PNPLA3 Expression by Steatosis Category",
       x = "PNPLA3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = GCKR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "GCKR Expression by Steatosis Category",
       x = "GCKR Expression",
       y = "Cell Count")

ggplot(df, aes(x = TM6SF2, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "TM6SF2 Expression by Steatosis Category",
       x = "TM6SF2 Expression",
       y = "Cell Count")

ggplot(df, aes(x = APOC3, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "APOC3 Expression by Steatosis Category",
       x = "APOC3 Expression",
       y = "Cell Count")

ggplot(df, aes(x = MTOR, fill = steatosis_cat)) + 
  geom_histogram(bins = 30, position = "identity", alpha = 0.6) + 
  theme_minimal() +
  labs(title = "MTOR Expression by Steatosis Category",
       x = "MTOR Expression",
       y = "Cell Count")
```


#9. Cell Chat
```{r}
print("Seurat object overview:")
print(so_Hep)
print("Metadata columns:")
print(colnames(so_Hep@meta.data))

# Check your study design
# print("Visit timepoints:")
# print(table(so_Hep@meta.data$visit))
print("Treatment groups:")
print(table(so_Hep@meta.data$steatosis_cat))
# print("Combined visit x treatment:")
# print(table(so_Hep@meta.data$visit, so_Hep@meta.data$treatment))
print("Number of subjects:")
print(length(unique(so_Hep@meta.data$Kit_Lot)))

# Check cell type annotations
print("Cell types present:")
print(table(so_Hep@meta.data$celltype))

# ============================================================================
# STEP 1: Prepare data for CellChat analysis
# ============================================================================

# Prepare required input data for CellChat analysis
data.input <- so_Hep[["RNA"]]$data
labels <- Idents(so_Hep)
meta <- data.frame(labels = labels, row.names = names(labels))

# Create a CellChat object
cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
cellchat <- setIdent(cellchat, ident.use = "labels")

# Set the ligand-receptor interaction database
CellChatDB <- CellChatDB.human
CellChatDB.use <- CellChatDB
cellchat@DB <- CellChatDB.use

# Use sequential processing instead
future::plan("sequential")
cellchat <- subsetData(cellchat) # This step is necessary even if using the whole database
cellchat <- identifyOverExpressedGenes(cellchat)
cellchat <- identifyOverExpressedInteractions(cellchat)

# Part II: Inference of cell-cell communication network
## Compute the communication probability and infer cellular communication network
ptm = Sys.time()
cellchat <- computeCommunProb(cellchat, type = "triMean")
#> triMean is used for calculating the average gene expression per cell group. 
#> [1] ">>> Run CellChat on sc/snRNA-seq data <<< [2024-02-14 00:32:35.767285]"
#> [1] ">>> CellChat inference is done. Parameter values are stored in `object@options$parameter` <<< [2024-02-14 00:33:13.121225]"


cellchat <- filterCommunication(cellchat, min.cells = 10)

## Infer the cell-cell communication at a signaling pathway level
cellchat <- computeCommunProbPathway(cellchat)
cellchat <- aggregateNet(cellchat)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(cellchat, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "scrna", 'hepatocyte_cellchat.rds')

groupSize <- as.numeric(table(cellchat@idents))
par(mfrow = c(1,2), xpd=TRUE)
netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")
netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")

mat <- cellchat@net$weight
# for (i in 1:nrow(mat)) {
#   mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
#   mat2[i, ] <- mat[i, ]
#   netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])
# }

dir.create("cellchat_circles")  # create output directory

for (i in 1:nrow(mat)) {
  # Define filename
  sender_name <- gsub("[/: ]", "_", rownames(mat)[i])  # sanitize filename
  out_file <- file.path("cellchat_circles", paste0("circle_", sender_name, ".jpeg"))
  
  # Open graphics device
  jpeg(filename = out_file, width = 1600, height = 1600, res = 200)
  
  # Create a matrix with only one sender
  mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
  mat2[i, ] <- mat[i, ]
  
  # Plot
  netVisual_circle(mat2,
                   vertex.weight = groupSize,
                   weight.scale = TRUE,
                   edge.weight.max = max(mat),
                   title.name = rownames(mat)[i])
  
  # Close the graphics device
  dev.off()
}

# List all files
files_to_upload <- list.files("cellchat_circles", full.names = TRUE)

for (f in files_to_upload) {
  key <- paste0("cellchat/circle_plots/", basename(f))
  s3$upload_file(Filename = f, Bucket = "scrna", Key = key)
}

cellchat <- computeCommunProb(cellchat)
# Step 2: Compute communication probabilities at the pathway level
cellchat <- computeCommunProbPathway(cellchat)

# Step 3: Aggregate the network at the signaling pathway level
cellchat <- aggregateNet(cellchat)

# Now you can run:
cellchat@netP$pathways

```

```{r echo = F}
# Chord diagram
# Create an output folder
out_dir <- "cellchat_pathway_plots"
dir.create(out_dir, showWarnings = FALSE)

# Vector of pathway names
pathways <- cellchat@netP$pathways        # already populated

# Loop over pathways and save each plot
for (pw in pathways) {
  
  # Sanitize the pathway name for filenames
  pw_clean  <- gsub("[^A-Za-z0-9_\\-]", "_", pw)
  out_file  <- file.path(out_dir, paste0("aggregate_", pw_clean, ".jpeg"))
  
  # Open graphics device (adjust width/height/res to taste)
  jpeg(filename = out_file, width = 1600, height = 1600, res = 200)
  
  # Draw the plot
  tryCatch(
    {
      netVisual_aggregate(
        object         = cellchat,
        signaling      = pw,
        layout         = "circle",    # or "chord"
        weight.scale   = TRUE,
        edge.weight.max = max(cellchat@net$weight),  # keeps colour scales comparable
        title.name     = pw
      )
    },
    error = function(e) {
      message(sprintf("Skipped %s – %s", pw, e$message))
    }
  )
  
  # Close device so the file is written
  dev.off()
}

message(sprintf("Done! Plots saved to %s/", out_dir))
```

###i. Longs Cell Chat Code
```{r}
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 
# combined$group <- paste(combined$treatment, combined$pre_post, sep = "-") 
# combined <- combined %>% JoinLayers()

filter_by_celltype_size <- function(seurat_obj, celltype_col = "celltype", min_cells = 50) {
  # Get celltype 
  celltypes <- seurat_obj@meta.data[[celltype_col]]
  
  # Count
  cell_counts <- table(celltypes)
  keep_celltypes <- names(cell_counts[cell_counts >= min_cells])
  
  # Subset
  keep_cells <- rownames(seurat_obj@meta.data)[celltypes %in% keep_celltypes]
  seurat_obj_filtered <- subset(seurat_obj, cells = keep_cells)
  
  return(seurat_obj_filtered)
}

# hep  <- subset(hep, subset = group == "VSG-pre") 
# vsg_post <- subset(combined, subset = group == "VSG-post") 
# std_pre  <- subset(combined, subset = group == "Standard-pre") 
# std_post <- subset(combined, subset = group == "Standard-post") 

Hep  <- filter_by_celltype_size(so_Hep)
# vsg_post <- filter_by_celltype_size(vsg_post)
# std_pre  <- filter_by_celltype_size(std_pre)
# std_post <- filter_by_celltype_size(std_post)

library(future)

run_cellchat_pipeline <- function(seurat_obj, group_name, group.by = "celltype", assay = "RNA", min_cells = 10) {
  # future::plan("multisession", workers = n_cores)
  
  cellchat <- createCellChat(object = seurat_obj, group.by = group.by, assay = assay)
  cellchat <- addMeta(cellchat, meta = seurat_obj@meta.data)
  cellchat <- setIdent(cellchat, ident.use = group.by)
  
  CellChatDB <- CellChatDB.human
  cellchat@DB <- CellChatDB
  
  cellchat <- subsetData(cellchat)
  cellchat <- identifyOverExpressedGenes(cellchat)
  cellchat <- identifyOverExpressedInteractions(cellchat)
  cellchat <- computeCommunProb(cellchat, type = "triMean")
  cellchat <- filterCommunication(cellchat, min.cells = min_cells)
  cellchat <- computeCommunProbPathway(cellchat)
  cellchat <- aggregateNet(cellchat)
  
  saveRDS(cellchat, file = paste0("cellchat_", group_name, ".rds"))
  return(cellchat)
}

# Force sequential processing BEFORE running your function
future::plan("sequential")
Hep$celltype <- factor(Hep$celltype)
cellchats <- list(
  Hep  = run_cellchat_pipeline(Hep,  "Hep")
)

get_group_size <- function(cellchat_obj) {
  return(as.numeric(table(cellchat_obj@idents)))
}
cellchat <- cellchats[['Hep']]
groupSize <- get_group_size(cellchat)

#aDTL aIC aPT ATL B C-TAL-1 C-TAL-2 CCD-PC CD4+ T CD8+ T 
#cDC CNT CNT-PC dCCD-PC DCT dDCT dTAL DTL EC-AEA EC-AVR 
#EC-GC EC-LYM EC-PTC EC/VSMC FIB IC-A IC-B M-PC MAC MON 
#NK PEC PT-S1/S2 PT-S3 tPC-IC VSMC/P 
#
# pdf("fig/vsg_pre_immtoepi.pdf", width = 6.5, height = 4)
netVisual_bubble(cellchat, sources.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                 targets.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                 remove.isolate = FALSE)
# title.name = expression(Immune %->% Epithelial/Endothelial))
# dev.off()
#
pdf("fig/vsg_pre_immtoimm.pdf", width = 5, height = 6.5)
netVisual_bubble(cellchat, sources.use = c("MAC", "CD4+ T", "CD8+ T", "B"),
                 targets.use = c("MAC", "CD4+ T", "CD8+ T", "NK", "MON", "B"),
                 remove.isolate = FALSE,
                 title.name = "Immune-Immune Crosstalk")
dev.off()
#
pdf("fig/vsg_pre_fibtoendo.pdf", width = 3.5, height = 13.5)
netVisual_bubble(cellchat, sources.use = c("FIB", "EC/VSMC"),
                 targets.use = c("PT-S3", "PEC", "VSMC/P", "CNT"),
                 remove.isolate = FALSE,
                 title.name = "Fibroblast-Endothelial Signaling")
dev.off()
#
pdf("fig/vsg_pre_tls.pdf", width = 7, height = 2.5)
netVisual_bubble(cellchat, signaling = c("CXCL", "CCL",  "LT", "TNF"), 
                 title.name = "TLS/Inflammation Resolution Signaling")
dev.off()
#
pdf("fig/vsg_pre_fibremod.pdf", width = 4, height = 4)
netVisual_bubble(cellchat, 
                 sources.use = c("FIB", "EC/VSMC"), 
                 signaling = c("TGFb", "PDGF", "VEGF", "BMP", "WNT"),
                 title.name = "Fibroblast/Endothelial Remodeling Signals")
dev.off()

cellchat_pre <- cellchat
cellchat_post <- cellchats[['VSG_post']]
#aDTL aIC aPT ATL C-TAL-1 C-TAL-2 CCD-PC CD4+ T CD8+ T cDC CNT CNT-PC dCCD-PC 
#DCT dDCT dTAL DTL EC-AEA EC-AVR EC-GC EC-PTC EC/VSMC IC-A IC-B MON NK PEC 
#PT-S1/S2 PT-S3 SchwannCells tPC-IC VSMC/P 
#
pdf("fig/vsg_post_immtoepi.pdf", width = 6.5, height = 3)
netVisual_bubble(cellchat_post, sources.use = c("MON", "CD4+ T", "CD8+ T", "NK", "cDC"),
                 targets.use = c("PT-S1/S2", "PT-S3", "aPT", "EC-PTC", "EC-AVR"),
                 remove.isolate = FALSE,
                 title.name = expression(Immune %->% Epithelial/Endothelial))
dev.off()
#
pdf("fig/vsg_post_immtoimm.pdf", width = 3.5, height = 4.5)
netVisual_bubble(cellchat_post, sources.use = c( "CD4+ T", "CD8+ T"),
                 targets.use = c("CD4+ T", "CD8+ T", "NK", "MON"),
                 remove.isolate = FALSE,
                 title.name = "Immune-Immune Crosstalk")
dev.off()
#
pdf("fig/vsg_post_fibtoendo.pdf", width = 3.2, height = 11.5)
netVisual_bubble(cellchat_post, sources.use = c("EC/VSMC"),
                 targets.use = c("PT-S3", "PEC", "VSMC/P", "CNT"),
                 remove.isolate = FALSE,
                 title.name = "Fibroblast-Endothelial Signaling")
dev.off()
#
pdf("fig/vsg_post_tls.pdf", width = 7, height = 2)
netVisual_bubble(cellchat_post, signaling = c("CXCL", "CCL",  "LT", "TNF"), 
                 title.name = "TLS/Inflammation Resolution Signaling")
dev.off()
#
pdf("fig/vsg_post_fibremod.pdf", width = 4, height = 4)
netVisual_bubble(cellchat_post, 
                 sources.use = c("FIB", "EC/VSMC"), 
                 signaling = c("TGFb", "PDGF", "VEGF", "BMP", "WNT"),
                 title.name = "Fibroblast/Endothelial Remodeling Signals")
dev.off()


#CHord diagram
pathways <- cellchat@netP$pathways  
pathways
#"PARs"     "CADM"     "VISFATIN" "CDH"     "PTPRM"
pw <- pathways[5]
netVisual_aggregate(
  object         = cellchat,
  signaling      = pw,
  layout         = "circle",    # or "chord"
  weight.scale   = TRUE,
  edge.weight.max = max(cellchat@net$weight)  # keeps colour scales comparable
  # title.name     = pw
)


```

###ii.Cell Chat by Group
```{r}
# Assuming you have a steatosis grouping variable in your metadata
so_Hep <- subset(so_liver_sn,celltype2=="Hep")
DefaultAssay(so_Hep) <- "RNA" 
colnames(so_Hep@meta.data)

# Split by steatosis level (adjust the column name as needed)
Hep_high <- subset(so_Hep, subset = steatosis_cat == "High Steatosis (2+3)")  # or whatever your high steatosis identifier is
Hep_low  <- subset(so_Hep, subset = steatosis_cat == "Low Steatosis (0+1)")   # or whatever your low steatosis identifier is

# Filter by cell type size for each group
Hep_high <- filter_by_celltype_size(Hep_high, min_cells = 30)  # Lower threshold since you're splitting data
Hep_low  <- filter_by_celltype_size(Hep_low, min_cells = 30)

# Fix factor levels
Hep_high$celltype <- droplevels(factor(Hep_high$celltype))
Hep_low$celltype  <- droplevels(factor(Hep_low$celltype))

# Run CellChat on both groups
cellchats <- list(
  Hep_high = run_cellchat_pipeline(Hep_high, "Hep_high"),
  Hep_low  = run_cellchat_pipeline(Hep_low,  "Hep_low")
)

# Merge CellChat objects for comparison
cellchat_merged <- mergeCellChat(cellchats, add.names = names(cellchats))

# Compare the total number of interactions
compareInteractions(cellchat_merged, show.legend = F, group = c(1,2))

# Compare the total interaction strength
compareInteractions(cellchat_merged, show.legend = F, group = c(1,2), measure = "weight")

# Compare the number of interactions by cell type
netVisual_diffInteraction(cellchat_merged, weight.scale = T)

# Compare the interaction strength by cell type
netVisual_diffInteraction(cellchat_merged, weight.scale = T, measure = "weight")

# Get group sizes for each condition
groupSize_high <- get_group_size(cellchats[['Hep_high']])
groupSize_low  <- get_group_size(cellchats[['Hep_low']])


# Get all pathways from both conditions
pathways_high <- cellchats[['Hep_high']]@netP$pathways
pathways_low  <- cellchats[['Hep_low']]@netP$pathways

# Get union of all pathways and sort them (alphabetical order)
all_pathways <- sort(union(pathways_high, pathways_low))

# Alternative: Order by total strength across both conditions
# pathway_strength <- rankNet(cellchat_merged, mode = "comparison")
# all_pathways <- pathway_strength$pathway[order(pathway_strength$total)]

# High steatosis interactions with ordered pathways
a <- netVisual_bubble(cellchats[['Hep_high']], 
                      sources.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      targets.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      # signaling = all_pathways,  # This orders the pathways
                      remove.isolate = FALSE,
                      title.name = "High Steatosis - Cell Communication")

# Low steatosis interactions with same pathway order
b <- netVisual_bubble(cellchats[['Hep_low']], 
                      sources.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      targets.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      signaling = all_pathways,  # Same order as above
                      remove.isolate = FALSE,
                      title.name = "Low Steatosis - Cell Communication")

# ggarrange(a, b, heights = c(1, 1.5), ncol = 2)
# Use the merged object for direct comparison
cellchat_merged <- mergeCellChat(cellchats, add.names = names(cellchats))

# This will show both conditions with consistent ordering
c <- netVisual_bubble(cellchat_merged, 
                      sources.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      targets.use = c("Hep-1","Hep-2","Hep-3","Hep-4","Hep-5","dHep"),
                      comparison = c(1, 2),  # Compare group 1 vs group 2
                      remove.isolate = FALSE)

# Create comparison plots
pdf(fs::path(dir.results,"steatosis_comparison_bubble.pdf"), width = 8, height = 8)
plot(a)
plot(b)
plot(c)
dev.off()

# Find pathways that differ between conditions
pathways_high <- cellchats[['Hep_high']]@netP$pathways
pathways_low  <- cellchats[['Hep_low']]@netP$pathways

# Pathways specific to high steatosis
high_specific <- setdiff(pathways_high, pathways_low)
print("High steatosis specific pathways:")
print(high_specific)

# Pathways specific to low steatosis
low_specific <- setdiff(pathways_low, pathways_high)
print("Low steatosis specific pathways:")
print(low_specific)

# Common pathways
common_pathways <- intersect(pathways_high, pathways_low)
print("Common pathways:")
print(common_pathways)

# Get pathways from both groups
pathways_high <- cellchats[['Hep_high']]@netP$pathways  
pathways_low <- cellchats[['Hep_low']]@netP$pathways
common_pathways <- intersect(pathways_high, pathways_low)

# Loop through pathways and create comparisons
for(pw in common_pathways) {
  
  # High steatosis
  netVisual_aggregate(
    object = cellchats[['Hep_high']],
    signaling = pw,
    layout = "chord",
    weight.scale = TRUE,
    edge.weight.max = max(cellchats[['Hep_high']]@net$weight),
    title.name = paste(pw, "- High Steatosis")
  )
  
  # Low steatosis  
  netVisual_aggregate(
    object = cellchats[['Hep_low']],
    signaling = pw,
    layout = "chord",
    weight.scale = TRUE,
    edge.weight.max = max(cellchats[['Hep_low']]@net$weight),
    title.name = paste(pw, "- Low Steatosis")
  )
}
```

###iii. Permutation Test for Differences
```{r}
# Permutation Test for CellChat Communication Differences
# Tests differences in pathway communication between high and low steatosis

library(CellChat)
library(dplyr)
library(ggplot2)

# Function to perform permutation test on communication differences
perform_permutation_test <- function(cellchats, n_permutations = 1000, seed = 123) {
  
  set.seed(seed)
  
  # Get common pathways
  pathways_high <- cellchats[['Hep_high']]@netP$pathways
  pathways_low <- cellchats[['Hep_low']]@netP$pathways
  common_pathways <- intersect(pathways_high, pathways_low)
  
  # Initialize results storage
  results <- list()
  
  for(pathway in common_pathways) {
    
    cat(paste("Testing pathway:", pathway, "\n"))
    
    # Get indices for the pathway in each condition
    idx_high <- which(cellchats[['Hep_high']]@netP$pathways == pathway)
    idx_low <- which(cellchats[['Hep_low']]@netP$pathways == pathway)
    
    if(length(idx_high) > 0 && length(idx_low) > 0) {
      
      # Extract communication probability matrices
      prob_high <- cellchats[['Hep_high']]@netP$prob[,,idx_high]
      prob_low <- cellchats[['Hep_low']]@netP$prob[,,idx_low]
      
      # Calculate observed difference in total communication
      obs_diff <- sum(prob_high, na.rm = TRUE) - sum(prob_low, na.rm = TRUE)
      
      # Combine data for permutation
      all_probs <- array(c(prob_high, prob_low), 
                         dim = c(dim(prob_high)[1], dim(prob_high)[2], 2))
      
      # Permutation test
      perm_diffs <- numeric(n_permutations)
      
      for(i in 1:n_permutations) {
        # Randomly assign conditions
        perm_labels <- sample(c(1, 2), 2, replace = FALSE)
        
        perm_high <- all_probs[,,perm_labels[1]]
        perm_low <- all_probs[,,perm_labels[2]]
        
        perm_diffs[i] <- sum(perm_high, na.rm = TRUE) - sum(perm_low, na.rm = TRUE)
      }
      
      # Calculate p-value
      p_value <- mean(abs(perm_diffs) >= abs(obs_diff))
      
      # Calculate effect size (Cohen's d equivalent)
      pooled_sd <- sqrt((var(as.vector(prob_high), na.rm = TRUE) + 
                           var(as.vector(prob_low), na.rm = TRUE)) / 2)
      effect_size <- obs_diff / (pooled_sd * sqrt(length(prob_high)))
      
      # Store results
      results[[pathway]] <- list(
        pathway = pathway,
        observed_diff = obs_diff,
        p_value = p_value,
        effect_size = effect_size,
        perm_diffs = perm_diffs,
        high_total = sum(prob_high, na.rm = TRUE),
        low_total = sum(prob_low, na.rm = TRUE),
        fold_change = sum(prob_high, na.rm = TRUE) / sum(prob_low, na.rm = TRUE)
      )
    }
  }
  
  return(results)
}

# Run the permutation test
perm_results <- perform_permutation_test(cellchats, n_permutations = 1000)

# Convert results to data frame for easy visualization
results_df <- do.call(rbind, lapply(perm_results, function(x) {
  data.frame(
    pathway = x$pathway,
    observed_diff = x$observed_diff,
    p_value = x$p_value,
    effect_size = x$effect_size,
    high_total = x$high_total,
    low_total = x$low_total,
    fold_change = x$fold_change
  )
}))

# Adjust for multiple testing
results_df$p_adj <- p.adjust(results_df$p_value, method = "BH")

# Sort by p-value
results_df <- results_df[order(results_df$p_value),]

print("Permutation test results:")
print(results_df)

# Visualization of results

# 1. Volcano plot
volcano_plot <- ggplot(results_df, aes(x = observed_diff, y = -log10(p_value))) +
  geom_point(aes(size = abs(effect_size), 
                 color = p_value < 0.05),
             alpha = 0.7) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", alpha = 0.5) +
  geom_text_repel(aes(label = pathway), 
                  size = 3,
                  max.overlaps = 15) +
  scale_color_manual(values = c("TRUE" = "red3", "FALSE" = "gray50"),
                     name = "Significant\n(p < 0.05)") +
  scale_size_continuous(name = "Effect Size",
                        range = c(2, 8)) +
  theme_minimal() +
  theme(panel.grid.minor = element_blank(),
        plot.title = element_text(size = 14, face = "bold")) +
  labs(x = "Difference in Total Communication (High - Low)",
       y = expression(-log[10](p-value)),
       title = "Permutation Test Results for Pathway Communication")

print(volcano_plot)

# 2. Bar plot of fold changes with significance
bar_plot <- ggplot(results_df, aes(x = reorder(pathway, fold_change), 
                                   y = log2(fold_change))) +
  geom_bar(stat = "identity", 
           aes(fill = p_value < 0.05)) +
  geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
  scale_fill_manual(values = c("TRUE" = "darkred", "FALSE" = "gray70"),
                    name = "Significant") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Pathway",
       y = "Log2 Fold Change (High/Low)",
       title = "Pathway Communication Changes")

print(bar_plot)

# 3. Individual pathway permutation distribution plots
plot_permutation_distribution <- function(pathway_name, perm_results) {
  
  result <- perm_results[[pathway_name]]
  
  if(!is.null(result)) {
    df <- data.frame(diff = result$perm_diffs)
    
    p <- ggplot(df, aes(x = diff)) +
      geom_histogram(bins = 50, fill = "gray70", color = "black", alpha = 0.7) +
      geom_vline(xintercept = result$observed_diff, 
                 color = "red", size = 1.5, linetype = "solid") +
      geom_vline(xintercept = 0, 
                 color = "black", linetype = "dashed", alpha = 0.5) +
      theme_minimal() +
      labs(x = "Difference in Communication (High - Low)",
           y = "Count",
           title = paste(pathway_name, "Permutation Test"),
           subtitle = paste("p-value:", round(result$p_value, 4),
                            "| Observed difference:", round(result$observed_diff, 3)))
    
    return(p)
  }
}

# Plot for most significant pathways
sig_pathways <- results_df$pathway[results_df$p_value < 0.05]

if(length(sig_pathways) > 0) {
  for(pathway in sig_pathways[1:min(4, length(sig_pathways))]) {
    p <- plot_permutation_distribution(pathway, perm_results)
    print(p)
  }
}

# 4. Summary heatmap of changes
# Create matrix for heatmap
comm_matrix <- matrix(0, nrow = length(common_pathways), ncol = 2)
rownames(comm_matrix) <- common_pathways
colnames(comm_matrix) <- c("Low Steatosis", "High Steatosis")

for(i in 1:length(common_pathways)) {
  pathway <- common_pathways[i]
  if(pathway %in% results_df$pathway) {
    row_data <- results_df[results_df$pathway == pathway,]
    comm_matrix[i, 1] <- row_data$low_total
    comm_matrix[i, 2] <- row_data$high_total
  }
}

# Scale by row to show relative changes
comm_matrix_scaled <- t(scale(t(comm_matrix)))

library(ComplexHeatmap)

ht <- Heatmap(comm_matrix_scaled,
              name = "Scaled\nCommunication",
              column_title = "Communication Strength by Condition",
              row_title = "Signaling Pathway",
              cluster_columns = FALSE,
              col = circlize::colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
              row_names_gp = gpar(fontsize = 10),
              column_names_gp = gpar(fontsize = 12))

draw(ht)

# Export significant results
write.csv(results_df[results_df$p_value < 0.05,], 
          "significant_pathway_changes.csv", 
          row.names = FALSE)

# Function to test cell-type specific changes
test_celltype_specific <- function(cellchats, pathway, n_perm = 1000) {
  
  # Get pathway indices
  idx_high <- which(cellchats[['Hep_high']]@netP$pathways == pathway)
  idx_low <- which(cellchats[['Hep_low']]@netP$pathways == pathway)
  
  if(length(idx_high) == 0 || length(idx_low) == 0) {
    return(NULL)
  }
  
  prob_high <- cellchats[['Hep_high']]@netP$prob[,,idx_high]
  prob_low <- cellchats[['Hep_low']]@netP$prob[,,idx_low]
  
  cell_types <- rownames(prob_high)
  results_ct <- list()
  
  for(i in 1:length(cell_types)) {
    for(j in 1:length(cell_types)) {
      
      # Observed difference
      obs_diff <- prob_high[i,j] - prob_low[i,j]
      
      if(!is.na(obs_diff) && (prob_high[i,j] > 0 || prob_low[i,j] > 0)) {
        
        # Simple permutation for this cell pair
        combined <- c(prob_high[i,j], prob_low[i,j])
        perm_diffs <- numeric(n_perm)
        
        for(k in 1:n_perm) {
          perm <- sample(combined)
          perm_diffs[k] <- perm[1] - perm[2]
        }
        
        p_val <- mean(abs(perm_diffs) >= abs(obs_diff))
        
        results_ct[[paste(cell_types[i], cell_types[j], sep = "_")]] <- list(
          source = cell_types[i],
          target = cell_types[j],
          obs_diff = obs_diff,
          p_value = p_val
        )
      }
    }
  }
  
  return(results_ct)
}

# Example: Test cell-type specific changes for PAR pathway
if("PARs" %in% common_pathways) {
  par_celltype_results <- test_celltype_specific(cellchats, "PARs")
  
  # Convert to data frame
  if(!is.null(par_celltype_results)) {
    par_ct_df <- do.call(rbind, lapply(par_celltype_results, as.data.frame))
    par_ct_df <- par_ct_df[order(par_ct_df$p_value),]
    
    print("\nCell-type specific changes for PAR signaling:")
    print(head(par_ct_df, 10))
  }
}


```

#10. Pet Data with TCA Cycle and Ox Phos Genes
##i. Set Up - RH2 & CRC
```{r}
#Load PET data & alt, ast, ggt and potentially masld 
harm_meta_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean/harmonized_dataset.csv",na=""))

#Number of participants
length(unique(harm_meta_data$record_id)) #651

#Filter to RH2 and CRC 
harm_meta_data <- harm_meta_data %>% 
  filter(grepl("RH2",record_id)|grepl("CRC",record_id))

#Number of participants
length(unique(harm_meta_data$record_id)) #117

#Filter to those with Pet data
pet_dat <- harm_meta_data %>% 
  dplyr::select(c("record_id","kit_id","lc_k2","rc_k2","lm_k2","rm_k2",
                  "lc_f","rc_f","lm_f","rm_f","gptalt_base","gotast_base"))


#Calculate K2 and F variables
so_liver_sn$avg_c_k2 <- (so_liver_sn$lc_k2+so_liver_sn$rc_k2)/2 
so_liver_sn$avg_m_k2 <- (so_liver_sn$lm_k2+so_liver_sn$rm_k2)/2
so_liver_sn$avg_c_f <- (so_liver_sn$lc_f+so_liver_sn$rc_f)/2 
so_liver_sn$avg_m_f <- (so_liver_sn$lm_f+so_liver_sn$rm_f)/2
so_liver_sn$avg_c_k2_f <- so_liver_sn$avg_c_k2/so_liver_sn$avg_c_f
so_liver_sn$avg_m_k2_f <- so_liver_sn$avg_m_k2/so_liver_sn$avg_m_f

#Calculate above and below median values
so_liver_sn$avg_c_k2_med <- ifelse(so_liver_sn$avg_c_k2>median(so_liver_sn$avg_c_k2,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_c_k2_med <- factor(so_liver_sn$avg_c_k2_med)
so_liver_sn$avg_c_k2_med <- relevel(so_liver_sn$avg_c_k2_med,"Below Median")

so_liver_sn$avg_m_k2_med <- ifelse(so_liver_sn$avg_m_k2>median(so_liver_sn$avg_m_k2,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_m_k2_med <- factor(so_liver_sn$avg_m_k2_med)
so_liver_sn$avg_m_k2_med <- relevel(so_liver_sn$avg_m_k2_med,"Below Median")

so_liver_sn$avg_c_f_med <- ifelse(so_liver_sn$avg_c_f>median(so_liver_sn$avg_c_f,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_c_f_med <- factor(so_liver_sn$avg_c_f_med)
so_liver_sn$avg_c_f_med <- relevel(so_liver_sn$avg_c_f_med,"Below Median")

so_liver_sn$avg_m_f_med <- ifelse(so_liver_sn$avg_m_f>median(so_liver_sn$avg_m_f,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_m_f_med <- factor(so_liver_sn$avg_m_f_med)
so_liver_sn$avg_m_f_med <- relevel(so_liver_sn$avg_m_f_med,"Below Median")

so_liver_sn$avg_c_k2_f_med <- ifelse(so_liver_sn$avg_c_k2_f>median(so_liver_sn$avg_c_k2_f,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_c_k2_f_med  <- factor(so_liver_sn$avg_c_k2_f_med )
so_liver_sn$avg_c_k2_f_med  <- relevel(so_liver_sn$avg_c_k2_f_med ,"Below Median")

so_liver_sn$avg_m_k2_f_med <- ifelse(so_liver_sn$avg_m_k2_f>median(so_liver_sn$avg_m_k2_f,na.rm=T),"Above Median","Below Median")
so_liver_sn$avg_m_k2_f_med <- factor(so_liver_sn$avg_m_k2_f_med)
so_liver_sn$avg_m_k2_f_med <- relevel(so_liver_sn$avg_m_k2_f_med,"Below Median")

#Among subset data
#Calculate K2 and F variables
so_subset$avg_c_k2 <- (so_subset$lc_k2+so_subset$rc_k2)/2 
so_subset$avg_m_k2 <- (so_subset$lm_k2+so_subset$rm_k2)/2
so_subset$avg_c_f <- (so_subset$lc_f+so_subset$rc_f)/2 
so_subset$avg_m_f <- (so_subset$lm_f+so_subset$rm_f)/2
so_subset$avg_c_k2_f <- so_subset$avg_c_k2/so_subset$avg_c_f
so_subset$avg_m_k2_f <- so_subset$avg_m_k2/so_subset$avg_m_f

#Calculate above and below median values
so_subset$avg_c_k2_med <- ifelse(so_subset$avg_c_k2>median(so_subset$avg_c_k2,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_k2_med <- factor(so_subset$avg_c_k2_med)
so_subset$avg_c_k2_med <- relevel(so_subset$avg_c_k2_med,"Below Median")

so_subset$avg_m_k2_med <- ifelse(so_subset$avg_m_k2>median(so_subset$avg_m_k2,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_k2_med <- factor(so_subset$avg_m_k2_med)
so_subset$avg_m_k2_med <- relevel(so_subset$avg_m_k2_med,"Below Median")

so_subset$avg_c_f_med <- ifelse(so_subset$avg_c_f>median(so_subset$avg_c_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_f_med <- factor(so_subset$avg_c_f_med)
so_subset$avg_c_f_med <- relevel(so_subset$avg_c_f_med,"Below Median")

so_subset$avg_m_f_med <- ifelse(so_subset$avg_m_f>median(so_subset$avg_m_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_f_med <- factor(so_subset$avg_m_f_med)
so_subset$avg_m_f_med <- relevel(so_subset$avg_m_f_med,"Below Median")

so_subset$avg_c_k2_f_med <- ifelse(so_subset$avg_c_k2_f>median(so_subset$avg_c_k2_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_c_k2_f_med  <- factor(so_subset$avg_c_k2_f_med )
so_subset$avg_c_k2_f_med  <- relevel(so_subset$avg_c_k2_f_med ,"Below Median")

so_subset$avg_m_k2_f_med <- ifelse(so_subset$avg_m_k2_f>median(so_subset$avg_m_k2_f,na.rm=T),"Above Median","Below Median")
so_subset$avg_m_k2_f_med <- factor(so_subset$avg_m_k2_f_med)
so_subset$avg_m_k2_f_med <- relevel(so_subset$avg_m_k2_f_med,"Below Median")


```

#11. Pet Data with IR/IS
##i. Set Up - RH2 & CRC
```{r}
#Load PET data & alt, ast, ggt and potentially masld 
# harm_meta_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean","harmonized_dataset.csv",na=""))
harm_meta_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean","harmonized_dataset.csv"),na.strings = c("", "NA", "N/A", "n/a", " ","na"))

#Number of participants
length(unique(harm_meta_data$record_id)) #651 changed to 656 on 08/25
length(unique(harm_meta_data$mrn)) #480 unique mrns

#Filter to RH2 and CRC 
harm_meta_data <- harm_meta_data %>%
  filter(grepl("RH",record_id)|grepl("RH2",record_id)|grepl("CRC",record_id)|grepl("PEN",record_id))
# harm_meta_data <- harm_meta_data %>% 
#   filter(grepl("CRC",record_id))

#Number of participants
length(unique(harm_meta_data$record_id)) #60 CRC people, 233 including RH and RH2 and PEN

#Number of participants with Pet data
length(which(!is.na(harm_meta_data$liver_k1))) #57 
length(which(!is.na(harm_meta_data$liver_k2))) #57
length(which(!is.na(harm_meta_data$liver_k3))) #57

pet_dat <- harm_meta_data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, last(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, mean(.x, na.rm = TRUE))),
                   .by = c(mrn, visit)) %>%
  arrange(mrn)
length(unique(pet_dat$record_id)) #200
length(unique(pet_dat$mrn)) #200

#select variables of interest
pet_dat2 <- pet_dat %>%
  dplyr::select(c("record_id","mrn","study","visit","screen_date","group","age","sex","bmi","hba1c","liver_k1","liver_k2","liver_k3","gir_190","gir_200","p2_gc_leanm", "p2_gc_m"))
# pet_dat2 <- pet_dat %>%
#   dplyr::select(c("record_id","mrn","study","visit","screen_date","group","liver_k1","liver_k2","liver_k3","search_eis",
#                   "homa_ir","p1_ffa_suppression","gir_190","gir_200","p2_gc_leanm", "p2_gc_m",
#                   "p1_gc_leanm","p1_gc_m","p1_raw_leanm","p1_raw_m","p1_steady_state_ffa",
#                   "p2_ffa_suppression","p2_gc_leanm","p2_gc_m","p2_raw_leanm","p2_raw_m",
#                   "p2_steady_state_ffa"))
#Filter to thoser with pet and insulin data
pet_dat3 <- pet_dat2 %>% filter(study %in% c("CROCODILE", "RENAL-HEIR", "RENAL-HEIRitage")) %>%
  filter(!is.na(liver_k1) & !is.na(gir_190))
#44 have gir_190 and gir_200
#24 have p2_gc_leanm
#26 have p2_gc_m
# > length(which(is.na(pet_dat3$p2_gc_leanm)))
# [1] 20
# > length(which(is.na(pet_dat3$p2_gc_m)))
# [1] 18


# pet_dat2 <- pet_dat %>%
#   arrange(screen_date) %>%
#   # arrange(date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, dplyr::first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, dplyr::first(na.omit(.x)))),
#                    .by = c(record_id, visit))
# pet_dat2 <- pet_dat %>%
#   arrange(screen_date) %>%
#   # arrange(date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, dplyr::first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, dplyr::first(na.omit(.x)))),
#                    .by = c(mrn, screen_date))

# Table 1: Summary Table - Total counts of missing and non-missing data
summary_table <- pet_dat3 %>%
  summarise(across(everything(), 
                   list(n_not_missing = ~sum(!is.na(.)),
                        n_missing = ~sum(is.na(.)),
                        pct_missing = ~round(mean(is.na(.)) * 100, 1)))) %>%
  pivot_longer(everything(), 
               names_to = c("variable", ".value"), 
               names_pattern = "(.*)_(n_not_missing|n_missing|pct_missing)") %>%
  dplyr::select(variable, n_not_missing, n_missing, pct_missing) %>%
  mutate(total = n_not_missing + n_missing) %>%
  arrange(desc(n_not_missing))

# Define a custom rendering function without median
my.render.cont <- function(x) {
  with(stats.apply.rounding(stats.default(x), digits=2), c("",
                                                           "Mean (SD)" = sprintf("%s (%s)", MEAN, SD)))
}
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+gir_190+gir_200+p2_gc_leanm+p2_gc_m| group, data=pet_dat3,
       render.continuous = my.render.cont)
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+gir_190+gir_200+p2_gc_leanm+p2_gc_m| study, data=pet_dat3,
       render.continuous = my.render.cont)
#Filter to those with at least one pet variable
pet_variables <- c("liver_k1","liver_k2","liver_k3")
# pet_dat3 <- pet_dat2 %>%
#   filter(if_any(all_of(pet_variables), ~ !is.na(.)))
# #55 participants have at least 1 pet variable of data 
# #But RH2-25-O has pet data and no insulin variable data, so need to exclude
# insulin_vars <- c("search_eis",
#                   "homa_ir","p1_ffa_suppression","gir_190","gir_200",
#                   "p1_gc_leanm","p1_gc_m","p1_raw_leanm","p1_raw_m","p1_steady_state_ffa",
#                   "p2_ffa_suppression","p2_gc_leanm","p2_gc_m","p2_raw_leanm","p2_raw_m",
#                   "p2_steady_state_ffa")
insulin_vars <- c("gir_190","gir_200","p2_gc_leanm", "p2_gc_m")
# pet_dat4 <- pet_dat3 %>%
#   filter(if_any(all_of(insulin_vars), ~ !is.na(.)))
#28 remain that have at least 1 pet var and at least 1 insulin var

#Correlation/association between each pet var and each insulin var
total_results <- data.frame()
for(pet in pet_variables) {
  for (insulin in insulin_vars){
    # Pearson correlation test
    pearson_test <- cor.test(pet_dat3[[pet]], pet_dat3[[insulin]], 
                             method = "pearson",
                             conf.level = 0.95)
    corr.p <- pearson_test$estimate
    p.p <- pearson_test$p.value
    
    # Spearman correlation test
    spearman_test <- cor.test(pet_dat3[[pet]], pet_dat3[[insulin]], 
                              method = "spearman",
                              conf.level = 0.95)
    corr.s <- spearman_test$estimate
    p.s <- spearman_test$p.value
    
    #Linear regression of x = insulin on y = pet variable
    m0 <- as.formula(paste0(pet,"~",insulin))
    m1 <- lm(m0,data=pet_dat3)
    beta <- summary(m1)$coef[2,1]
    pval <- summary(m1)$coef[2,4] 
    
    results <- data.frame(Pet=pet,IR=insulin,Corr_p=corr.p,Pval_p=p.p,Corr_s=corr.s,Pval_s=p.s,Beta=beta,Pval=pval)
    total_results <- rbind(total_results,results)
  }
}

#Visualize results
get_sig_stars <- function(p) {
  case_when(
    p < 0.001 ~ "***",
    p < 0.01 ~ "**",
    p < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Function to create a heatmap with significance stars
create_heatmap <- function(data, value_col, pval_col, title, 
                           color_low = "blue", color_high = "red", 
                           color_mid = "white", limits = NULL) {
  
  # Reshape data to wide format for values
  values_wide <- data %>%
    dplyr::select(Pet, IR, all_of(value_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(value_col))
  
  # Reshape data to wide format for p-values
  pvals_wide <- data %>%
    dplyr::select(Pet, IR, all_of(pval_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(pval_col))
  
  # Convert to matrix for melting
  values_matrix <- as.matrix(values_wide[,-1])
  rownames(values_matrix) <- values_wide$Pet
  
  pvals_matrix <- as.matrix(pvals_wide[,-1])
  rownames(pvals_matrix) <- pvals_wide$Pet
  
  # Melt for ggplot
  values_melt <- melt(values_matrix, varnames = c("Pet", "IR"), value.name = "value")
  pvals_melt <- melt(pvals_matrix, varnames = c("Pet", "IR"), value.name = "pval")
  
  # Combine and add stars
  plot_data <- values_melt %>%
    left_join(pvals_melt, by = c("Pet", "IR")) %>%
    mutate(stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Set limits if not provided
  if (is.null(limits)) {
    limits <- c(min(plot_data$value, na.rm = TRUE), 
                max(plot_data$value, na.rm = TRUE))
  }
  
  # Create heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3.5) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,face="bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = title)
  
  return(p)
}

library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
library(viridis)
library(gridExtra)

# Create the three heatmaps
# 1. Spearman Correlation Heatmap
heatmap_spearman <- create_heatmap(total_results, 
                                   value_col = "Corr_s", 
                                   pval_col = "Pval_s",
                                   title = "Spearman Correlation Coefficients",
                                   limits = c(-1, 1))

# 2. Pearson Correlation Heatmap
heatmap_pearson <- create_heatmap(total_results, 
                                  value_col = "Corr_p", 
                                  pval_col = "Pval_p",
                                  title = "Pearson Correlation Coefficients",
                                  limits = c(-1, 1))

# 3. Linear Regression Beta Coefficients Heatmap
# For betas, we might want different color scheme and no fixed limits
# heatmap_beta <- create_heatmap(total_results, 
#                               value_col = "Beta", 
#                               pval_col = "Pval",
#                               title = "Linear Regression Beta Coefficients")

# Display individual heatmaps
png(fs::path(dir.results,"Heatmaps_Pearson_Corr_Liver_Pet_IR2.png"),width=3000,height=2000,res=300)
print(heatmap_pearson)
dev.off()
png(fs::path(dir.results,"Heatmaps_Spearman_Corr_Liver_Pet_IR2.png"),width=3000,height=2000,res=300)
print(heatmap_spearman)
dev.off()
# print(heatmap_beta)

# Function to create a single box plot
create_boxplot <- function(data, pet_var, group_var = "group") {
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.5) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         x = "Group",
         y = pet_var) +
    stat_compare_means(method = "t.test", label.y.npc = 0.95) # Add p-value
  return(p)
}

# Create box plots for all PET variables
boxplot_list <- lapply(pet_variables, function(pet) {
  create_boxplot(pet_dat3, pet)
})

# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group.png"), 
    width = 6000, height = 2500, res = 300)
do.call(grid.arrange, c(boxplot_list, ncol = 3))
dev.off()

library(ggplot2)
library(ggpubr)
library(rstatix)
library(gridExtra)
library(dplyr)

# Function to create box plot with ANOVA and Tukey HSD
create_boxplot_with_stats <- function(data, pet_var, group_var = "group") {
  # Perform ANOVA
  anova_formula <- as.formula(paste(pet_var, "~", group_var))
  anova_result <- aov(anova_formula, data = data)
  anova_pval <- summary(anova_result)[[1]][["Pr(>F)"]][1]
  
  # Perform Tukey HSD test
  tukey_result <- TukeyHSD(anova_result)
  tukey_df <- as.data.frame(tukey_result[[group_var]])
  
  # Get unadjusted p-values using pairwise t-tests
  pwc_raw <- data %>%
    rstatix::pairwise_t_test(
      formula = as.formula(paste(pet_var, "~", group_var)),
      p.adjust.method = "none"  # No adjustment for raw p-values
    ) %>%
    add_xy_position(x = group_var)
  
  # Add significance labels for raw p-values
  pwc_raw <- pwc_raw %>%
    mutate(p.signif = case_when(
      p < 0.001 ~ "***",
      p < 0.01 ~ "**",
      p < 0.05 ~ "*",
      p < 0.1 ~ ".",
      TRUE ~ "ns"
    ))
  
  # Create the plot
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7, outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold", size = 12),
          axis.title = element_text(size = 14),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          plot.subtitle = element_text(hjust = 0.5, size = 12)) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         subtitle = paste("ANOVA p =", format(anova_pval, digits = 3), 
                          "| p-values"),
         x = "Group",
         y = pet_var) +
    stat_pvalue_manual(pwc_raw, 
                       label = "p.signif",  # Use raw p-value significance
                       tip.length = 0.01, 
                       bracket.nudge.y = 0.05) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))  # Add space for brackets
  
  # Return all results
  return(list(
    plot = p, 
    anova_pval = anova_pval, 
    tukey_hsd = tukey_df,  # Tukey HSD results for reference
    pairwise_raw = pwc_raw  # Raw p-values that are plotted
  ))
}

# Create box plots and statistical tests for all PET variables
results_list <- list()
plot_list <- list()

for(pet in pet_variables) {
  result <- create_boxplot_with_stats(pet_dat3, pet)
  plot_list[[pet]] <- result$plot
  results_list[[pet]] <- list(
    anova_pval = result$anova_pval,
    tukey_hsd = result$tukey_hsd,
    pairwise_raw = result$pairwise_raw
  )
}

# Optional: Print summary of results
for(pet in names(results_list)) {
  cat("\n", pet, ":\n", sep = "")
  cat("ANOVA p-value:", format(results_list[[pet]]$anova_pval, digits = 4), "\n")
  cat("\nTukey HSD adjusted p-values:\n")
  print(results_list[[pet]]$tukey_hsd[, "p adj", drop = FALSE])
  cat("\nUnadjusted p-values (shown on plot):\n")
  print(results_list[[pet]]$pairwise_raw[, c("group1", "group2", "p", "p.signif")])
  cat("\n", rep("-", 50), "\n", sep = "")
}
# library(ggplot2)
# library(ggpubr)
# library(rstatix)
# library(gridExtra)
# 
# # Function to create box plot with ANOVA and pairwise comparisons
# create_boxplot_with_stats <- function(data, pet_var, group_var = "group") {
#   # Perform ANOVA
#   anova_formula <- as.formula(paste(pet_var, "~", group_var))
#   anova_result <- aov(anova_formula, data = data)
#   anova_pval <- summary(anova_result)[[1]][["Pr(>F)"]][1]
#   
#   # Perform pairwise comparisons
#   pwc <- data %>%
#     rstatix::pairwise_t_test(
#       formula = as.formula(paste(pet_var, "~", group_var)),
#       p.adjust.method = "bonferroni"
#     ) %>%
#     add_xy_position(x = group_var)
#   
#   # Create the plot
#   p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
#     geom_boxplot(alpha = 0.7, outlier.shape = NA) +
#     geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
#     theme_minimal() +
#     theme(legend.position = "none",
#           axis.text.x = element_text(face = "bold", size = 12),
#           axis.title = element_text(size = 14),
#           plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
#           plot.subtitle = element_text(hjust = 0.5, size = 12)) +
#     labs(title = paste("Distribution of", pet_var, "by Group"),
#          subtitle = paste("ANOVA p-value:", format(anova_pval, digits = 3)),
#          x = "Group",
#          y = pet_var) +
#     stat_pvalue_manual(pwc, label = "p.adj.signif", 
#                        tip.length = 0.01, 
#                        bracket.nudge.y = 0.05)
#   
#   return(list(plot = p, anova_pval = anova_pval, pairwise = pwc))
# }
# 
# # Create box plots and statistical tests for all PET variables
# results_list <- list()
# plot_list <- list()
# 
# for(pet in pet_variables) {
#   result <- create_boxplot_with_stats(pet_dat3, pet)
#   plot_list[[pet]] <- result$plot
#   results_list[[pet]] <- list(
#     anova_pval = result$anova_pval,
#     pairwise = result$pairwise
#   )
# }
# 
# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group_with_Stats2.png"),
    width = 7000, height = 3000, res = 300)
do.call(grid.arrange, c(plot_list, ncol = 3))
dev.off()

# Create a summary table of ANOVA results
anova_summary <- data.frame(
  PET_Variable = pet_variables,
  ANOVA_pvalue = sapply(results_list, function(x) x$anova_pval),
  Significant = sapply(results_list, function(x) ifelse(x$anova_pval < 0.05, "Yes", "No"))
)

write.csv(anova_summary, 
          fs::path(dir.results, "ANOVA_Summary_PET_by_Group.csv"), 
          row.names = FALSE)

# Create detailed pairwise comparison table
all_pairwise <- data.frame()
for(pet in names(results_list)) {
  pwc_data <- results_list[[pet]]$pairwise
  pwc_data$PET_Variable <- pet
  all_pairwise <- rbind(all_pairwise, pwc_data)
}

write.csv(all_pairwise, 
          fs::path(dir.results, "Pairwise_Comparisons_PET_by_Group.csv"), 
          row.names = FALSE)

# Correlation analysis stratified by group
total_results_by_group <- data.frame()
for(grp in unique(pet_dat3$group)) {
  # Subset data by group
  group_data <- pet_dat3[pet_dat3$group == grp, ]
  
  for(pet in pet_variables) {
    for(insulin in insulin_vars) {
      # Check if we have enough non-missing values
      complete_cases <- sum(!is.na(group_data[[pet]]) & !is.na(group_data[[insulin]]))
      
      if(complete_cases > 3) {  # Need at least 4 observations for correlation
        # Pearson correlation test
        pearson_test <- cor.test(group_data[[pet]], group_data[[insulin]], 
                                 method = "pearson", conf.level = 0.95)
        corr.p <- pearson_test$estimate
        p.p <- pearson_test$p.value
        
        # Spearman correlation test
        spearman_test <- cor.test(group_data[[pet]], group_data[[insulin]], 
                                  method = "spearman", conf.level = 0.95)
        corr.s <- spearman_test$estimate
        p.s <- spearman_test$p.value
      } else {
        corr.p <- corr.s <- p.p <- p.s <- NA
      }
      
      results <- data.frame(Group = grp, Pet = pet, IR = insulin, 
                            Corr_p = corr.p, Pval_p = p.p, 
                            Corr_s = corr.s, Pval_s = p.s,
                            N = complete_cases)
      total_results_by_group <- rbind(total_results_by_group, results)
    }
  }
}

# Create faceted heatmap function
create_faceted_heatmap <- function(data, value_col, pval_col, title, 
                                   color_low = "blue", color_high = "red", 
                                   color_mid = "white", limits = c(-1, 1)) {
  
  # Prepare data with significance stars
  plot_data <- data %>%
    mutate(value = .data[[value_col]],
           pval = .data[[pval_col]],
           stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Create faceted heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Correlation") +
    facet_wrap(~ Group, ncol = 2) +  # Adjust ncol based on number of groups
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          strip.text = element_text(face = "bold", size = 14),
          strip.background = element_rect(fill = "lightgray", color = "black"),
          panel.spacing = unit(1, "lines")) +
    labs(title = title)
  
  return(p)
}

# Create faceted heatmaps
heatmap_spearman_faceted <- create_faceted_heatmap(total_results_by_group, 
                                                   value_col = "Corr_s", 
                                                   pval_col = "Pval_s",
                                                   title = "Spearman Correlation Coefficients by Group")

heatmap_pearson_faceted <- create_faceted_heatmap(total_results_by_group, 
                                                  value_col = "Corr_p", 
                                                  pval_col = "Pval_p",
                                                  title = "Pearson Correlation Coefficients by Group")

# Save faceted heatmaps
png(fs::path(dir.results, "Heatmap_Pearson_Faceted_by_Group2.png"), 
    width = 4000, height = 3000, res = 300)
print(heatmap_pearson_faceted)
dev.off()

png(fs::path(dir.results, "Heatmap_Spearman_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(heatmap_spearman_faceted)
dev.off()


# Stratified linear regression by group
regression_results_by_group <- data.frame()

for(grp in unique(pet_dat3$group)) {
  # Subset data by group
  group_data <- pet_dat3[pet_dat3$group == grp, ]
  
  for(pet in pet_variables) {
    for(insulin in insulin_vars) {
      # Check if we have enough non-missing values
      complete_cases <- sum(!is.na(group_data[[pet]]) & !is.na(group_data[[insulin]]))
      
      if(complete_cases > 3) {  # Need at least 4 observations for regression
        # Linear regression: pet ~ insulin
        formula <- as.formula(paste0(pet, " ~ ", insulin))
        model <- lm(formula, data = group_data)
        
        # Extract coefficients
        beta <- summary(model)$coef[2, 1]  # Insulin coefficient
        se <- summary(model)$coef[2, 2]    # Standard error
        pval <- summary(model)$coef[2, 4]  # P-value
        
        # Get R-squared
        r_squared <- summary(model)$r.squared
        
        # Get confidence intervals
        ci <- confint(model)[2, ]
        ci_lower <- ci[1]
        ci_upper <- ci[2]
      } else {
        beta <- se <- pval <- r_squared <- ci_lower <- ci_upper <- NA
      }
      
      # Store results
      results <- data.frame(
        Group = grp,
        Pet = pet,
        IR = insulin,
        Beta = beta,
        SE = se,
        Pval = pval,
        CI_lower = ci_lower,
        CI_upper = ci_upper,
        R_squared = r_squared,
        N = complete_cases
      )
      
      regression_results_by_group <- rbind(regression_results_by_group, results)
    }
  }
}

# Create faceted heatmap for regression coefficients
create_faceted_regression_heatmap <- function(data, title, 
                                              color_low = "blue", color_high = "red", 
                                              color_mid = "white") {
  
  # Prepare data with significance stars
  plot_data <- data %>%
    mutate(stars = get_sig_stars(Pval),
           label = paste0(round(Beta, 2), stars),
           # Create a label with CI for tooltip or alternative display
           full_label = paste0("β=", round(Beta, 2), 
                               " [", round(CI_lower, 2), ", ", round(CI_upper, 2), "]",
                               stars))
  
  # Determine color limits based on beta values
  beta_range <- range(plot_data$Beta, na.rm = TRUE)
  max_abs <- max(abs(beta_range))
  limits <- c(-max_abs, max_abs)
  
  # Create faceted heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = Beta)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "β Coefficient") +
    facet_wrap(~ Group, ncol = 2) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          strip.text = element_text(face = "bold", size = 14),
          strip.background = element_rect(fill = "lightgray", color = "black"),
          panel.spacing = unit(1, "lines")) +
    labs(title = title)
  
  return(p)
}

# Create the faceted heatmap
regression_heatmap_faceted <- create_faceted_regression_heatmap(
  regression_results_by_group,
  title = "Linear Regression β Coefficients (PET ~ Insulin) by Group"
)

# Save the heatmap
png(fs::path(dir.results, "Heatmap_Regression_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(regression_heatmap_faceted)
dev.off()

# Create a summary table with comparisons between groups
regression_comparison <- regression_results_by_group %>%
  select(Group, Pet, IR, Beta, Pval, R_squared) %>%
  pivot_wider(names_from = Group, 
              values_from = c(Beta, Pval, R_squared),
              names_sep = "_") %>%
  # Calculate differences if you have exactly 2 groups
  # Adjust group names as needed
  mutate(
    Beta_diff = abs(Beta_Group1 - Beta_Group2),  # Adjust group names
    Both_sig = ifelse(Pval_Group1 < 0.05 & Pval_Group2 < 0.05, "Both", 
                      ifelse(Pval_Group1 < 0.05, "Group1 only",
                             ifelse(Pval_Group2 < 0.05, "Group2 only", "Neither")))
  ) %>%
  arrange(desc(Beta_diff))

write.csv(regression_comparison, 
          fs::path(dir.results, "Regression_Comparison_by_Group.csv"), 
          row.names = FALSE)

# Optional: Create a plot showing R-squared values by group
r_squared_plot <- ggplot(regression_results_by_group, 
                         aes(x = IR, y = Pet, fill = R_squared)) +
  geom_tile(color = "white", size = 0.5) +
  geom_text(aes(label = round(R_squared, 2)), size = 3) +
  scale_fill_gradient(low = "white", high = "darkgreen",
                      name = "R²") +
  facet_wrap(~ Group, ncol = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        strip.text = element_text(face = "bold", size = 14),
        strip.background = element_rect(fill = "lightgray", color = "black")) +
  labs(title = "Model R² Values by Group")

png(fs::path(dir.results, "Heatmap_R_squared_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(r_squared_plot)
dev.off()

# Create a combined visualization showing both beta and significance
# This creates a more detailed view with confidence intervals
create_detailed_regression_plot <- function(data, pet_var) {
  pet_data <- data[data$Pet == pet_var, ]
  
  p <- ggplot(pet_data, aes(x = IR, y = Beta, color = Group)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
    geom_point(position = position_dodge(width = 0.3), size = 3) +
    geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper), 
                  position = position_dodge(width = 0.3), 
                  width = 0.2) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Regression Coefficients for", pet_var),
         x = "Insulin Variable",
         y = "β Coefficient (95% CI)",
         color = "Group")
  
  return(p)
}

# Create individual plots for each PET variable
for(pet in pet_variables) {
  p <- create_detailed_regression_plot(regression_results_by_group, pet)
  
  png(fs::path(dir.results, paste0("Regression_CI_Plot_", pet, ".png")), 
      width = 2500, height = 2000, res = 300)
  print(p)
  dev.off()
}
```



