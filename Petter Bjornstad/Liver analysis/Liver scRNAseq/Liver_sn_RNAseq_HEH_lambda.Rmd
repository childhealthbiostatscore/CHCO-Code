---
title: "Liver scRNA analysis HEH"
author: "Hailey Hampson"
date: "2024-09-24"
output: html_document
--- 

#1. Set up Libraries & Directores
```{r libraries, echo=F, include = F}
library(reprex)
library(tidyverse)
library(BiocManager)        
library(arsenal)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(Seurat)
library(future)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(rstatix)
library(table1)
library(Biobase)
library(ReactomeGSA)
library(GSEABase)
library(msigdbr)
library(kableExtra)
library(knitr)
library(SingleCellExperiment)
library(fgsea)
library(EnhancedVolcano)
library(openxlsx)
library(BiocManager)
library(MAST)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(openxlsx)
library(ggplot2)
library(GGally)
library(GSEABase)
library(limma)
library(reshape2)
library(data.table)
library(knitr)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
library(NMF)
library(rsvd)
library(RColorBrewer)
library(MAST)
library(devtools)
# install_github("Sun-lab/ideas",force=T)
library(ideas)
library(foreach)
library(doRNG)
library(doParallel)
registerDoParallel(cores = 6)


#options(mc.cores = detectCores() - 1) #if you have multiple cores to spin
options(mc.cores = 1)
knitr::opts_chunk$set(message = FALSE,error = FALSE,warning = FALSE,cache = FALSE,fig.width=8,fig.height=6)

#Local file path
# dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
# dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
# dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
# dir.results <- c("/Users/hhampson/Documents/UW/1_Ongoing Projects/Liver scRNAseq/2_Results")

#Lambda file path
dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
dir.results <- c(fs::path(dir.dat,"Liver project/Results"))


plan()
future::plan("sequential")
options(future.globals.maxSize = 3e9)

#Load functions
source("Liver_functions.R")

```

#2a. Load Full Data & Clean: snRNA & MetaData
```{r echo = F}
# Liver snRNA data processing
gc()
#Local
# so_liver_sn <- readRDS(fs::path(dir.dat,"scRNA","data_raw","NoRef_PetterLiver_ClinData_Labels_Char_041924.RDS"))
#Lambda
so_liver_sn <- readRDS(fs::path(dir.dat,"scRNA","data_raw","NoRef_PetterLiver_ClinData_Labels_Char_041924.RDS"))

gc()
#Local
# meta_liver_raw <- read.csv(fs::path(dir.dat,"scRNA","data_clean","liver_biopsy_metadata_PN.csv"))
#Lambda
meta_liver_raw <- read.csv(fs::path(dir.dat,"scRNA","data_clean","liver_biopsy_metadata_PN.csv"))

meta_liver_sn <-  so_liver_sn@meta.data[,1:11] %>%
  dplyr::mutate(RNAlater_ID = SampleID) %>%
  left_join(meta_liver_raw)

rownames(meta_liver_sn) <- rownames(so_liver_sn@meta.data)
so_liver_sn <- AddMetaData(so_liver_sn, meta_liver_sn)
rm(meta_liver_sn,meta_liver_raw)

#Switch default assay in seurat object to RNA
DefaultAssay(so_liver_sn) <- "RNA"
gc()

#Create liver disease and drug groups
so_liver_sn@meta.data <- so_liver_sn@meta.data %>% 
  mutate(both=ifelse(glp1agonist=="Yes" & sglt2=="Yes","Yes","No")) %>% 
  mutate(sglt2_exclusive=ifelse(sglt2=="Yes" & glp1agonist=="No","Yes","No")) %>% 
  mutate(glp1_exclusive=ifelse(sglt2=="No" & glp1agonist=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(sglt2=="No" & glp1agonist=="No","Yes","No"))

# Create a single grouping variable
so_liver_sn@meta.data <- so_liver_sn@meta.data %>% 
  mutate(group2=case_when(both == "Yes" ~ "both",
                         sglt2_exclusive == "Yes" ~ "sglt2_exclusive",
                         glp1_exclusive == "Yes" ~ "glp1_exclusive",
                         neither == "Yes" ~ "neither"))

so_liver_sn@meta.data$group2 <- factor(so_liver_sn@meta.data$group2, levels = c("neither", "sglt2_exclusive", "glp1_exclusive","both"))
```

-OR-
#2b. Load Cleaned & Formatted snRNA Hepatocyte Data
```{r}
# #Create heptatocyte only so
# so_liver_sn@meta.data$hepatocyte <- ifelse(grepl("Hep",so_liver_sn@meta.data$celltype),"Hepatocyte","Non-Hepatocyte")
# Idents(so_liver_sn) <- so_liver_sn$hepatocyte
# # gc()
# so_liver_sn_hep <- subset(so_liver_sn, hepatocyte == "Hepatocyte")
# DefaultAssay(object = so_liver_sn_hep) <- "RNA"
# rm(so_liver_sn)
#saveRDS(so_liver_sn_hep,fs::path(dir.dat2,"so_liver_sn_hepatocytes.RDS"))
gc()
so_liver_sn_hep <- readRDS(fs::path(dir.dat2,"so_liver_sn_hepatocytes.RDS"))
gc()
Idents(so_liver_sn_hep) <- so_liver_sn_hep$hepatocyte
gc()
# 14,15,16,18,19
#Create senesence so
# sens_gene_in_data <- intersect(sens_genes, rownames(so_liver_sn_hep))
# Subset the Seurat object to include only genes in sens_gene_in_data
# so_sens <- subset(so_liver_sn_hep, features = sens_gene_in_data)
# rm(so_liver_sn_hep)
# saveRDS(so_sens,fs::path(dir.dat,"scRNA","data_clean","so_sens_genes.RDS"))
```

#2c. Load Senesence Data 
```{r}
so_sens <- readRDS(fs::path(dir.dat2,"so_sens_genes.RDS"))
so_diab <- subset(so_sens, diagnosis_of_diabetes == "Yes")
DefaultAssay(object = so_diab) <- "RNA"
# so_sens <- readRDS("/Users/hhampson/Desktop/so_sens_genes.RDS")

#Create senesence so in all cell types
sens_gene_in_data <- intersect(sens_genes, rownames(so_liver_sn))
# Subset the Seurat object to include only genes in sens_gene_in_data
so_sens_all <- subset(so_liver_sn, features = sens_gene_in_data)
rm(so_liver_sn)
#saveRDS(so_sens_all,fs::path(dir.dat2,"so_sens_genes_all_cells.RDS"))

#Load sens all cells
so_sens <- readRDS(fs::path(dir.dat2,"so_sens_genes_all_cells.RDS"))
so_diab <- subset(so_sens, diagnosis_of_diabetes == "Yes")
DefaultAssay(object = so_diab) <- "RNA"

```

#2d. Load Kidney ScRNA 
```{r}
#Increase Memory
mem.maxVSize(64000000000)
#Local
# dir.dat <- c("/Users/hhampson/Dropbox/Bjornstad data")
# so_kidney_sc <- readRDS(fs::path(dir.dat,"Kidney scRNA","PB_90samples_Harmony_rpca_Fadhl_PhilApproved_091024.RDS"))
# load("/Volumes/Peds Endo/Petter Bjornstad/Data Harmonization/Data Exports/PB90_clinical_metadata.RData")
# so_kidney_sc <- AddMetaData(so_kidney_sc, so_meta_combined)
# rm(so_meta_combined)
# gc()

#Lambda
so_kidney_sc <- readRDS(fs::path(dir.dat,"scRNA","data_raw","PB_90samples_Harmony_rpca_Fadhl_PhilApproved_091024.RDS"))
load(fs::path(dir.dat,"Data Harmonization","Data Exports","PB90_clinical_metadata_12_10.RData"))
so_kidney_sc <- AddMetaData(so_kidney_sc, so_meta_combined)
rm(so_meta_combined)
gc()

#Define 4 exposure groups: 
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)
so_kidney_sc@meta.data <- so_kidney_sc@meta.data %>% 
  mutate(both=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>% 
  mutate(exclusive_sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>% 
  mutate(exclusive_glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))


so_kidney_sc@meta.data <- so_kidney_sc@meta.data %>% 
  mutate(group2 = case_when(both == "Yes" ~ "both",
                            exclusive_sglt2 == "Yes" ~ "exclusive_sglt2",
                            exclusive_glp1 == "Yes" ~ "exclusive_glp1",
                            neither == "Yes" ~ "neither"))

so_kidney_sc@meta.data$group2 <- factor(so_kidney_sc@meta.data$group2, levels = c("neither", "both", "exclusive_sglt2", "exclusive_glp1"))

so_diab <- subset(so_kidney_sc,group=="Type 2 Diabetes")
rm(so_kidney_sc)
gc()

# #Create senesence so in all cell types
# sens_genes <- c(sens_genes,"CDKN1A")
# sens_gene_in_data <- intersect(sens_genes, rownames(so_kidney_sc))
# # Subset the Seurat object to include only genes in sens_gene_in_data
# so_sens_all <- subset(so_kidney_sc, features = sens_gene_in_data)
# rm(so_kidney_sc)
# # saveRDS(so_sens_all,fs::path(dir.dat,"so_sens_genes_all_cells_KIDNEY.RDS"))
# # rm(so_sens_all)
# # 
# # #Load sens all cells
# # so_sens <- readRDS(fs::path(dir.dat,"so_sens_genes_all_cells_KIDNEY.RDS"))
# # dat <- so_sens@meta.data
# # so_diab <- subset(so_sens, diagnosis_of_diabetes == "Yes")
# # 
# #PT Cells
# so_sens_all@meta.data$PT <- ifelse(grepl("PT-",so_sens_all@meta.data$celltype_rpca),"PT","Non-PT")
# Idents(so_sens_all) <- so_sens_all$PT
# so_sens <- subset(so_sens_all, PT=="PT")
# # saveRDS(so_sens,fs::path(dir.dat,"so_sens_genes_PT_Cells_KIDNEY.RDS"))
# rm(so_sens_all,so_sens)
# so_sens_PT <- readRDS(fs::path(dir.dat,"Liver Project","so_sens_genes_PT_Cells_KIDNEY.RDS"))
# so_sens_PT@meta.data$group1 <- ifelse(so_sens_PT@meta.data$group=="Type 2 Diabetes" | so_sens_PT@meta.data$group=="Lean Control" ,"Yes","No")
# so_sens_PT1 <- subset(so_sens_PT, group1=="Yes")
# so_sens_PT@meta.data$group2 <- ifelse(so_sens_PT@meta.data$group=="Type 2 Diabetes","Yes","No")
# so_sens_PT2 <- subset(so_sens_PT, group2=="Yes")
# so_sens_PT3 <- subset(so_sens_PT, group=="Type 2 Diabetes")
# 
# 
# 
# #TAL Cells
# so_sens_all@meta.data$TAL <- ifelse(grepl("TAL",so_sens_all@meta.data$celltype_rpca),"TAL","Non-TAL")
# Idents(so_sens_all) <- so_sens_all$TAL
# so_sens <- subset(so_sens_all, TAL=="TAL")
# # saveRDS(so_sens,fs::path(dir.dat,"so_sens_genes_TAL_Cells_KIDNEY.RDS"))
# rm(so_sens_all,so_sens,so_sens_TAL,so_sens_TAL1)
# so_sens_TAL <- readRDS(fs::path(dir.dat,"Liver Project","so_sens_genes_TAL_Cells_KIDNEY.RDS"))
# so_sens_TAL@meta.data$group1 <- ifelse(so_sens_TAL@meta.data$group=="Type 2 Diabetes"| so_sens_TAL@meta.data$group=="Lean Control","Yes","No")
# so_sens_TAL1 <- subset(so_sens_TAL, group1=="Yes")
# so_sens_TAL@meta.data$group2 <- ifelse(so_sens_TAL@meta.data$group=="Type 2 Diabetes","Yes","No")
# so_sens_TAL2 <- subset(so_sens_TAL, group2=="Yes")
# so_sens_TAL3 <- subset(so_sens_TAL, group=="Type 2 Diabetes")
```

#3a. Visualize Kidney Data
```{r}
#Visualize the data
so_kidney_sc <- FindVariableFeatures(object = so_kidney_sc)
so_kidney_sc <- RunPCA(so_kidney_sc, features = VariableFeatures(object = so_kidney_sc))
ElbowPlot(so_kidney_sc)
gc()
so_kidney_sc <- FindNeighbors(so_kidney_sc, dims = 1:15)
so_kidney_sc <- FindClusters(so_kidney_sc, resolution = 0.5)
so_kidney_sc <- RunUMAP(so_kidney_sc, dims = 1:15)


DimPlot(so_kidney_sc, reduction = "umap", raster = F)
# so_kidney_sc$celltype_rpca
# DimPlot(so_kidney_sc, reduction = "umap", group.by = "celltype_rpca", raster = FALSE)
DimPlot(so_kidney_sc, reduction = "umap", group.by = "celltype_rpca",raster = FALSE, label = TRUE, label.size = 2)

# Calculate whether each cell expresses any of the sens_genes
sens_genes <- c(sens_genes,"CDKN1A")
# expression_matrix <- FetchData(so_kidney_sc, vars = sens_genes)
expression_matrix <- FetchData(so_kidney_sc, vars = sens_genes, slot="counts")

# Determine if any gene in sens_genes is expressed in each cell
any_sens_expressed <- rowSums(expression_matrix > 0) > 0
# Compute the sum of expression for the 'sens_genes' in each cell
sum_sens_expression <- rowSums(expression_matrix)

# Group by CellType and summarize the count of cells in each type
cell_type_summary <- expression_matrix %>%
  mutate(
    cell_types = so_kidney_sc$celltype_rpca,
    TotalExpression = rowSums(across(where(is.numeric))) # Calculate row sums for numeric columns
  ) %>%
  group_by(cell_types) %>%
  summarize(
    NumberOfCells = n(),
    TotalExpression = sum(TotalExpression) # Sum precomputed row-wise totals
  ) %>%
  ungroup() %>% 
  mutate(AverageExpression=TotalExpression/NumberOfCells)

# expression_matrix <- expression_matrix %>%
#   mutate(exp_total = rowSums(across(everything()))) %>% 
#   mutate(CellID = rownames(expression_matrix))

#Calculate average sensexpression by cell type
expression_matrix$cell_types <- so_kidney_sc$celltype_rpca

expression_matrix <- tidylog::left_join(expression_matrix,cell_type_summary,by="cell_types")


# Add this information as a metadata column in the Seurat object
so_kidney_sc$SensExpressionMagnitude <- sum_sens_expression
so_kidney_sc$SensExpressed <- any_sens_expressed
so_kidney_sc$SensExpressed <- ifelse(so_kidney_sc$SensExpressed==TRUE,"Expressed","Not Expressed")
so_kidney_sc$AverageExpression <- expression_matrix$AverageExpression

#Plot
DimPlot(so_kidney_sc, group.by = "SensExpressed",raster=F) +
  scale_color_manual(values = c("Expressed" = "lightblue", "Not Expressed" = "red"))

# FeaturePlot(so_kidney_sc, features = "SensExpressionMagnitude") +
#   scale_color_gradient(low = "lightblue", high = "darkred") +
#   ggtitle("Magnitude of Sens Genes Expression")


# Assign colors based on Sens_Expression
DimPlot(so_kidney_sc, reduction = "umap", group.by = "SensExpressed", raster=F) 
umap1 <- DimPlot(so_kidney_sc, reduction = "umap", raster=F,group.by = "SensExpressed", 
                 cols = c("Not Expressed" = "red", "Expressed" = "lightblue1"))+
  ggtitle("UMAP Plot with Senescence Expression")+
  theme_void()

# Fetch UMAP coordinates and metadata
# Extract UMAP coordinates for the "umap" reduction
umap_coords <- Embeddings(so_kidney_sc, reduction = "umap")  # Matches DimPlot's reduction
umap_data <- data.frame(
  UMAP_1 = umap_coords[, 1],
  UMAP_2 = umap_coords[, 2],
  SensExpressed = so_kidney_sc$SensExpressed,
  SensMagnitude=so_kidney_sc$SensExpressionMagnitude,# Ensure this column exists in metadata
  celltype = so_kidney_sc$celltype_rpca       # Ensure this column exists in metadata
)

# Calculate the mean expression per cell type
mean_expression_per_celltype <- umap_data %>%
  group_by(celltype) %>%
  summarize(MeanExpression = mean(SensMagnitude, na.rm = TRUE))

# Add the mean expression back to each cell
umap_data <- umap_data %>%
  left_join(mean_expression_per_celltype, by = "celltype")
# # Create UMAP plot colored by mean expression
# ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2, color = MeanExpression)) +
#   geom_point(size = 0.5, alpha = 0.6) +
#   scale_color_gradient(low = "lightblue", high = "darkblue") +
#   ggtitle("Mean Expression Magnitude per Cell Type") +
#   theme_void() +
#   theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))
# Calculate mean expression per cell type
mean_expression <- so_kidney_sc@meta.data %>%
  group_by(celltype_rpca) %>%
  summarize(MeanExpression = mean(SensExpressionMagnitude, na.rm = TRUE))

# Merge back to the Seurat object
so_kidney_sc@meta.data <- left_join(
  so_kidney_sc@meta.data, 
  mean_expression, 
  by = c("celltype_rpca" = "celltype_rpca")
)

# Calculate cluster centers
cluster_centers <- umap_data %>%
  group_by(celltype) %>%
  summarize(
    UMAP_1 = mean(UMAP_1, na.rm = TRUE),
    UMAP_2 = mean(UMAP_2, na.rm = TRUE)
  )
# # Add labels to the plot
# ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2, color = MeanExpression)) +
#   geom_point(size = 0.1, alpha = 0.6) +
#   geom_text(data = cluster_centers, aes(x = UMAP_1, y = UMAP_2, label = celltype), 
#             color = "black", size = 3, fontface = "bold", nudge_y = 0.5) +
#   scale_color_gradient(low = "lightblue", high = "darkblue") +
#   ggtitle("Mean Expression Magnitude per Cell Type") +
#   theme_void() +
#   theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

umap1 +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)

# Plot UMAP with gradient of senescence gene expression
umap_plot <- FeaturePlot(so_kidney_sc, features = "MeanExpression", raster=T,
                         reduction = "umap") 
# min.cutoff = 0, max.cutoff = 1127.136)+
# scale_color_gradientn(
#   colors = c("gray", "lightblue1", "lightblue2","lightblue3","blue", "darkblue"),  # Red for 0, transitioning to dark blue
#   values = scales::rescale(c(0,25,50,75,100,125,150,175,200,1127.136)),           # Control how the colors map to the expression values
#   limits = c(0, 1127.136)                                    # Explicitly set the limits of the color scale
# ) +
labs(color = "Normalized Expression") +
  ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
  theme_void()

# Assign colors based on Sens_Expression
DimPlot(so_kidney_sc, reduction = "umap", group.by = "AverageExpression", raster=F)
umap_plot <- FeaturePlot(so_kidney_sc, features = "AverageExpression", raster = TRUE,
                         reduction = "umap",
                         min.cutoff = 0, max.cutoff = 110) +
  scale_color_gradientn(
    colors = c("gray","lightblue1","blue","darkblue"),  # Red for 0, transitioning to dark blue
    values = scales::rescale(c(0,25,50,75,110)),           # Control how the colors map to the expression values
    limits = c(0, 110)                                    # Explicitly set the limits of the color scale
  ) +
  labs(color = "Average Expression") +
  # ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
  theme_void()
umap_coords <- Embeddings(so_kidney_sc, reduction = "umap")  # Matches DimPlot's reduction
umap_data <- data.frame(
  UMAP_1 = umap_coords[, 1],
  UMAP_2 = umap_coords[, 2],
  SensExpressed = so_kidney_sc$SensExpressed,
  SensMagnitude=so_kidney_sc$SensExpressionMagnitude,# Ensure this column exists in metadata
  celltype_rpca = so_kidney_sc$celltype_rpca,
  AverageExpression=so_kidney_sc$AverageExpression# Ensure this column exists in metadata
)
cluster_centers <- umap_data %>%
  group_by(celltype_rpca) %>%
  summarize(
    UMAP_1 = mean(UMAP_1, na.rm = TRUE),
    UMAP_2 = mean(UMAP_2, na.rm = TRUE)
  )


# Add cell type labels to the plot
umap_plot +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype_rpca), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)  
write.csv(cell_type_summary,fs::path(dir.dat,"Senescence_Signals_Cell_Types.csv"))
```

#3b. Visualize Liver Data with UMAPs
##i. Senescence Genes
```{r echo=F}
# Set a higher memory limit
# mem.maxVSize(64000000000)

# PCA
# so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn),assay="integrated")
# so_liver_sn <- FindVariableFeatures(object = so_liver_sn)
# so_liver_sn <- RunPCA(so_liver_sn, features = VariableFeatures(object = so_liver_sn),assay="RNA")
ElbowPlot(so_liver_sn)
ElbowPlot(so_sens_all)
# Cluster cells
# so_liver_sn_int <- FindNeighbors(so_liver_sn_int)
# so_liver_sn_int <- FindClusters(so_liver_sn_int)

# # Find neighbors and clusters (again using integrated data)
# # so_liver_sn <- FindNeighbors(so_liver_sn, assay = "integrated", dims = 1:15)
# so_liver_sn <- FindNeighbors(so_liver_sn, assay = "RNA", dims = 1:15)
# so_liver_sn <- FindClusters(so_liver_sn, resolution = 0.5)
# 
# # UMAP for visualization
# # so_liver_sn <- RunUMAP(so_liver_sn, assay = "integrated", dims = 1:15)
# so_liver_sn <- RunUMAP(so_liver_sn, assay = "RNA", dims = 1:15)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
DimPlot(so_liver_sn, reduction = "umap", raster = F) 
DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", raster = FALSE)
DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

#Sens
#Categorize senescence genes
# Calculate whether each cell expresses any of the sens_genes
so_liver_sn$Sens_Expression <- colSums(so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE]) > 0
so_liver_sn$Sens_Expression <- ifelse(so_liver_sn$Sens_Expression==TRUE,"Expressing","Not Expressing")
so_liver_sn$Sens_Expression_Level <- colSums(so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE])

#Raw data, not normalized
so_liver_sn$Sens_Expression <- colSums(so_liver_sn@assays$RNA@counts[sens_genes, , drop = FALSE]) > 0
so_liver_sn$Sens_Expression <- ifelse(so_liver_sn$Sens_Expression==TRUE,"Expressing","Not Expressing")
so_liver_sn$Sens_Expression_Level <- colSums(so_liver_sn@assays$RNA@counts[sens_genes, , drop = FALSE])


# Assign colors based on Sens_Expression
DimPlot(so_liver_sn, reduction = "umap", group.by = "Sens_Expression", raster=F) 
umap1 <- DimPlot(so_liver_sn, reduction = "umap", group.by = "Sens_Expression", 
                 cols = c("Not Expressing" = "red", "Expressing" = "lightblue1"))+
  ggtitle("UMAP Plot with Senescence Expression")+
  theme_void()

# Fetch UMAP coordinates and metadata
umap_data <- FetchData(so_liver_sn, vars = c("UMAP_1", "UMAP_2", "Sens_Expression_Level", "celltype"))

# Calculate cluster centers for each cell type
cluster_centers <- umap_data %>%
  group_by(celltype) %>%
  summarize(UMAP_1 = mean(UMAP_1), UMAP_2 = mean(UMAP_2))
umap1 +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)

DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", 
            reduction = "umap", cols = c("lightgrey", "blue", "darkblue")) +
  ggtitle("UMAP with Gradient of Sensitivity Gene Expression") +
  labs(color = "Expression Level") 

max(so_liver_sn$Sens_Expression_Level)
# Fetch UMAP coordinates and metadata
umap_data <- FetchData(so_liver_sn, vars = c("UMAP_1", "UMAP_2", "Sens_Expression_Level", "celltype"))

# Calculate cluster centers for each cell type
cluster_centers <- umap_data %>%
  group_by(celltype) %>%
  summarize(UMAP_1 = mean(UMAP_1), UMAP_2 = mean(UMAP_2))

# Plot UMAP with gradient of senescence gene expression
# umap_plot <- FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", raster=T,
#                          reduction = "umap", cols = c("red","lightblue1", "blue", "darkblue"),
#             min.cutoff = 0, max.cutoff = 37.82061) +
#   labs(color = "Expression Level") +
#   ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
#   theme_void()

umap_plot <- FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", raster = TRUE,
                         reduction = "umap",
                         min.cutoff = 0, max.cutoff = 40.48379) +
  scale_color_gradientn(
    colors = c("gray", "lightblue1", "lightblue2","lightblue3","blue", "darkblue"),  # Red for 0, transitioning to dark blue
    values = scales::rescale(c(0,1,5, 10,15,20,30, 40.48379)),           # Control how the colors map to the expression values
    limits = c(0, 40.48379)                                    # Explicitly set the limits of the color scale
  ) +
  labs(color = "Normalized Expression") +
  ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
  theme_void()

# Add cell type labels to the plot
umap_plot +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)


hist(as.vector(so_liver_sn$Sens_Expression_Level), breaks = 50, main = "Distribution of Raw Expression for Sens Genes", xlab = "Normalized Expression Level")
range(so_liver_sn$Sens_Expression_Level)


# Extract expression data for the senescence genes
expression_data <- so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE]
# Extract cell type information (assuming 'celltype' is a column in metadata)
cell_types <- so_liver_sn$celltype

# Combine the expression data with the cell type information
expression_with_celltype <- data.frame(expression_data)
rm(expression_data)
dim(expression_with_celltype) #124 rows/genes, 130124 columns/cells
expression_with_celltype <- t(expression_with_celltype)
cell <- rownames(expression_with_celltype)
expression_with_celltype <- as.data.frame(expression_with_celltype)
expression_with_celltype$celltype <- cell_types
expression_with_celltype$cell <- cell

#Calculate total sense expression for each cell
expression_with_celltype$total_sens_expression <- rowSums(expression_with_celltype[sens_genes])

# Now, calculate the average expression for each cell type
expression_by_celltype_combined <- expression_with_celltype %>%
  dplyr::group_by(celltype) %>%
  dplyr::summarize(total_expression = sum(total_sens_expression, na.rm = TRUE),
                   total_cells = n())
expression_by_celltype_combined <- expression_by_celltype_combined %>%
  mutate(average_expression = total_expression / total_cells)


ggplot(expression_by_celltype_combined, aes(x = celltype, y = average_expression)) +
  geom_bar(stat = "identity") +
  labs(title = "Average Senescence Gene Expression by Cell Type",
       x = "Cell Type",
       y = "Average Expression") +
  theme_minimal()

expression_with_celltype <- expression_with_celltype %>%
  left_join(expression_by_celltype_combined[, c("celltype", "average_expression")], by = "celltype")

# Add back to Seurat metadata
so_liver_sn@meta.data$average_expression <- expression_with_celltype$average_expression
umap2 <- FeaturePlot(so_liver_sn, features = "average_expression", reduction = "umap")

umap2 +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)+
  labs(color = "Average Expression")+
  theme_void()+
  scale_color_gradientn(
    colors = c("gray", "lightblue1","blue", "darkblue"),  # Red for 0, transitioning to dark blue
    # values = scales::rescale(c(0,9,10,11,12,13,14,15,16)),           # Control how the colors map to the expression values
    limits = c(9, 16)                                    # Explicitly set the limits of the color scale
  ) 


# Extract metadata from Seurat object
metadata <- so_liver_sn@meta.data

# 1. Filter and summarize by diagnosis and cell type
cell_type_counts <- metadata %>%
  group_by(diagnosis_of_diabetes, celltype) %>%
  summarise(cell_count = n(), .groups = "drop")

# 2. Calculate total cells per diagnosis group
total_cells_per_group <- metadata %>%
  group_by(diagnosis_of_diabetes) %>%
  summarise(total_cells = n(), .groups = "drop")

# 3. Merge the counts with the total cell counts to calculate proportions
cell_type_proportions <- cell_type_counts %>%
  left_join(total_cells_per_group, by = "diagnosis_of_diabetes") %>%
  mutate(proportion = cell_count / total_cells)

# Plot the proportions
ggplot(cell_type_proportions, aes(x = celltype, y = proportion, fill = diagnosis_of_diabetes)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Proportion of Each Cell Type in T2D and Healthy Controls",
       x = "Cell Type", y = "Proportion") +
  theme_minimal()

# Extract metadata from Seurat object
metadata <- so_liver_sn@meta.data


```
##ii. P21/CDKN1A
```{r echo=F}
# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
DimPlot(so_liver_sn, reduction = "umap", raster = F) 
DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", raster = FALSE)
DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

#Sens
#Categorize senescence genes
# Calculate whether each cell expresses any of the sens_genes
sens_genes <- c("CDKN1A")
so_liver_sn$Sens_Expression <- colSums(so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE]) > 0
so_liver_sn$Sens_Expression <- ifelse(so_liver_sn$Sens_Expression==TRUE,"Expressing","Not Expressing")
so_liver_sn$Sens_Expression_Level <- colSums(so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE])

# #Raw data, not normalized
# so_liver_sn$Sens_Expression <- colSums(so_liver_sn@assays$RNA@counts[sens_genes, , drop = FALSE]) > 0
# so_liver_sn$Sens_Expression <- ifelse(so_liver_sn$Sens_Expression==TRUE,"Expressing","Not Expressing")
# so_liver_sn$Sens_Expression_Level <- colSums(so_liver_sn@assays$RNA@counts[sens_genes, , drop = FALSE])


# Assign colors based on Sens_Expression
DimPlot(so_liver_sn, reduction = "umap", group.by = "Sens_Expression", raster=F) 
umap1 <- DimPlot(so_liver_sn, reduction = "umap", group.by = "Sens_Expression", 
                 cols = c("Not Expressing" = "lightblue1", "Expressing" = "red"))+
  ggtitle("UMAP Plot with Senescence Expression")+
  theme_void()

# Fetch UMAP coordinates and metadata
umap_data <- FetchData(so_liver_sn, vars = c("UMAP_1", "UMAP_2", "Sens_Expression_Level", "celltype"))

# Calculate cluster centers for each cell type
cluster_centers <- umap_data %>%
  group_by(celltype) %>%
  summarize(UMAP_1 = mean(UMAP_1), UMAP_2 = mean(UMAP_2))
umap1 +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)

DimPlot(so_liver_sn, reduction = "umap", group.by = "celltype", label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", 
            reduction = "umap", cols = c("gray", "lightblue1", "lightblue2","lightblue3","blue", "darkblue")) +
  ggtitle("UMAP with Gradient of Sensitivity Gene Expression") +
  labs(color = "Expression Level") 

max(so_liver_sn$Sens_Expression_Level)
range(so_liver_sn$Sens_Expression_Level)

# Fetch UMAP coordinates and metadata
umap_data <- FetchData(so_liver_sn, vars = c("UMAP_1", "UMAP_2", "Sens_Expression_Level", "celltype"))

# Calculate cluster centers for each cell type
cluster_centers <- umap_data %>%
  group_by(celltype) %>%
  summarize(UMAP_1 = mean(UMAP_1), UMAP_2 = mean(UMAP_2))

# Plot UMAP with gradient of senescence gene expression
# umap_plot <- FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", raster=T,
#                          reduction = "umap", cols = c("red","lightblue1", "blue", "darkblue"),
#             min.cutoff = 0, max.cutoff = 37.82061) +
#   labs(color = "Expression Level") +
#   ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
#   theme_void()

umap_plot <- FeaturePlot(so_liver_sn, features = "Sens_Expression_Level", raster = TRUE,
                         reduction = "umap",
                         min.cutoff = 0, max.cutoff = 3.365003) +
  scale_color_gradientn(
    colors = c("lightgrey","lightblue1","blue", "darkblue"),  # Red for 0, transitioning to dark blue
    values = scales::rescale(c(0,0.1,1,2,3,4)),           # Control how the colors map to the expression values
    limits = c(0, 3.365003)                                    # Explicitly set the limits of the color scale
  ) +
  labs(color = "Normalized Expression") +
  ggtitle("UMAP with Gradient of Senescence Gene Expression by Cell Type") +
  theme_void()

# Add cell type labels to the plot
umap_plot +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)


hist(as.vector(so_liver_sn$Sens_Expression_Level), breaks = 50, main = "Distribution of Raw Expression for Sens Genes", xlab = "Normalized Expression Level")
range(so_liver_sn$Sens_Expression_Level)


# Extract expression data for the senescence genes
expression_data <- so_liver_sn@assays$RNA@data[sens_genes, , drop = FALSE]
# Extract cell type information (assuming 'celltype' is a column in metadata)
cell_types <- so_liver_sn$celltype

# Combine the expression data with the cell type information
expression_with_celltype <- data.frame(expression_data)
rm(expression_data)
dim(expression_with_celltype) #124 rows/genes, 130124 columns/cells
expression_with_celltype <- t(expression_with_celltype)
cell <- rownames(expression_with_celltype)
expression_with_celltype <- as.data.frame(expression_with_celltype)
expression_with_celltype$celltype <- cell_types
expression_with_celltype$cell <- cell

#Calculate total sense expression for each cell
expression_with_celltype$total_sens_expression <- rowSums(expression_with_celltype[sens_genes])

# Now, calculate the average expression for each cell type
expression_by_celltype_combined <- expression_with_celltype %>%
  dplyr::group_by(celltype) %>%
  dplyr::summarize(total_expression = sum(total_sens_expression, na.rm = TRUE),
                   total_cells = n())
expression_by_celltype_combined <- expression_by_celltype_combined %>%
  mutate(average_expression = total_expression / total_cells)


ggplot(expression_by_celltype_combined, aes(x = celltype, y = average_expression)) +
  geom_bar(stat = "identity") +
  labs(title = "Average P21 Gene Expression by Cell Type",
       x = "Cell Type",
       y = "Average Expression") +
  theme_minimal()

expression_with_celltype <- expression_with_celltype %>%
  left_join(expression_by_celltype_combined[, c("celltype", "average_expression")], by = "celltype")

# Add back to Seurat metadata
so_liver_sn@meta.data$average_expression <- expression_with_celltype$average_expression
umap2 <- FeaturePlot(so_liver_sn, features = "average_expression", raster=T,reduction = "umap")

umap2 +
  geom_text(data = cluster_centers, 
            aes(x = UMAP_1, y = UMAP_2, label = celltype), 
            color = "black", size = 2,fontface="bold", nudge_y = 0.5)+
  labs(color = "Average Expression")+
  theme_void()+
  scale_color_gradientn(
    colors = c("lightgray", "lightblue1","blue", "darkblue"),  # Red for 0, transitioning to dark blue
    # values = scales::rescale(c(0,0.1,1,2,3,4)),           # Control how the colors map to the expression values
    limits = c(0, 0.03)                                    # Explicitly set the limits of the color scale
  ) 


# Extract metadata from Seurat object
metadata <- so_liver_sn@meta.data

# 1. Filter and summarize by diagnosis and cell type
cell_type_counts <- metadata %>%
  group_by(diagnosis_of_diabetes, celltype) %>%
  summarise(cell_count = n(), .groups = "drop")

# 2. Calculate total cells per diagnosis group
total_cells_per_group <- metadata %>%
  group_by(diagnosis_of_diabetes) %>%
  summarise(total_cells = n(), .groups = "drop")

# 3. Merge the counts with the total cell counts to calculate proportions
cell_type_proportions <- cell_type_counts %>%
  left_join(total_cells_per_group, by = "diagnosis_of_diabetes") %>%
  mutate(proportion = cell_count / total_cells)

# Plot the proportions
ggplot(cell_type_proportions, aes(x = celltype, y = proportion, fill = diagnosis_of_diabetes)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Proportion of Each Cell Type in T2D and Healthy Controls",
       x = "Cell Type", y = "Proportion") +
  theme_minimal()

# Extract metadata from Seurat object
metadata <- so_liver_sn@meta.data


```

#3c. Cleaning - Check for dublets 
```{r}
# Identify gene markers
# Initialize a list to store markers for each cell type
top_markers <- list()

# Get unique cell types
cell_types <- unique(so_liver_sn$celltype)  # Replace 'celltype' with your grouping metadata column

# Loop through each cell type
for (cell in cell_types) {
  # Find markers for the current cell type vs all others
  markers <- FindMarkers(so_liver_sn, 
                         ident.1 = cell, 
                         group.by = "celltype", 
                         min.pct = 0.25,  # Minimum fraction of cells expressing the gene
                         logfc.threshold = 0.25)  # Minimum log fold change
  
  # Add gene names as a column
  markers <- markers %>%
    rownames_to_column("gene")
  
  # Sort by adjusted p-value (p_val_adj) and log2 fold change
  markers <- markers %>%
    arrange(p_val_adj, desc(avg_log2FC))
  
  # Select the top gene
  if (nrow(markers) > 0) {
    top_markers[[cell]] <- markers$gene[1]
  } else {
    top_markers[[cell]] <- NA  # No markers found for this cell type
  }
}

# Convert the result to a data frame
top_markers_df <- data.frame(celltype = names(top_markers), 
                             top_gene = unlist(top_markers))
print(top_markers_df)


# Define your genes of interest
marker_genes <- top_markers_df$top_gene

# Generate the dot plot grouped by cell type
dot_plot <- DotPlot(so_liver_sn, 
                    features = marker_genes, 
                    group.by = "celltype") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotate x-axis labels for readability

# Display the plot
dot_plot

```

#4. Descriptive Statistics
##a. Liver
```{r echo = F}
#Define disease and drug groups
dat <- meta_liver_raw <- read.csv(fs::path(dir.dat,"scRNA","data_clean","liver_biopsy_metadata_PN.csv"))
dat <- dat %>% 
  # filter(kit_id %in% unique(so_kidney_sc$kit_id)) %>%
  mutate(both=ifelse(glp1agonist=="Yes" & sglt2=="Yes","Yes","No")) %>% 
  mutate(sglt2_exclusive=ifelse(sglt2=="Yes" & glp1agonist=="No","Yes","No")) %>% 
  mutate(glp1_exclusive=ifelse(sglt2=="No" & glp1agonist=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(sglt2=="No" & glp1agonist=="No","Yes","No"))
dat2 <- dat %>% 
  filter(diagnosis_of_diabetes=="Yes")

table(dat2$sglt2_exclusive) #-/+ #5 No
table(dat2$glp1_exclusive) #+/- # 2 Yes, 3 No
table(dat2$both) #+/+ #1 Both, 4 not both
table(dat2$neither) #-/- #3 neither, 2 on someting

#Create table 1
dat <- read.csv(fs::path(dir.dat,"scRNA","data_clean","liver_biopsy_metadata_PN.csv"))
dat <- dat %>% 
  filter(diagnosis_of_diabetes=="Yes")
cor(dat$ast,dat$alt,method="pearson")
cor(dat$ast,dat$alt,method="spearman")
cor(dat$alt,dat$tg,method="spearman")

dat$diagnosis_of_diabetes <- factor(dat$diagnosis_of_diabetes, levels=c("Yes","No"), labels=c("Type 2 Diabetes", "Obese Controls"))
dat$nih_sex     <- factor(dat$nih_sex, levels=c("Male", "Female"), labels=c("Male", "Female"))
dat$nih_ethnicity   <- factor(dat$nih_ethnicity, levels=c("Hispanic_Or_Latino","NonHispanic"), labels=c("Hispanic or Latino","Non-Hispanic/Non-Latino"))
dat$nih_race   <- factor(dat$nih_race, levels=c("White","BlackAfAm","Multiracial","Other"),
                         labels=c("White","Black","Multirace","Other"))
dat$steatosis_grade <- as.factor(dat$steatosis_grade)
dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)

label(dat$age)      <- "Age (y)"
label(dat$nih_sex)      <- "Sex"
label(dat$nih_race)    <- "Race"
label(dat$nih_ethnicity)    <- "Ethnicity"
label(dat$diagnosis_of_diabetes)  <- "Diabetes Status"
label(dat$bmi)   <- "Body Mass Index (kg/m2)"
label(dat$diagnosis_of_MASLD)  <- "MASLD Status"
label(dat$sbp)     <- "Systolic Blood Pressure (mmHg)"
label(dat$dbp) <- "Diastolic Blood Pressure (mmHg)"
label(dat$tg) <-  "Triglycerides (mg/dL)"
label(dat$creatinine) <-  "Creatinine (mg/dL)"
label(dat$steatosis_percent) <- "Steatosis Percent (%)"
label(dat$fibrosis_stage) <- "Fibrosis Stage"
label(dat$lobular_inflammation_percent) <- "Lobular Inflammation Percent (%)"

table1(~ age + nih_sex + nih_race + nih_ethnicity + bmi + diagnosis_of_MASLD + sbp + dbp + tg + creatinine | diagnosis_of_diabetes, data=dat)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, data = dat)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + diagnosis_of_diabetes + a1c  + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | glp1agonist, data = dat)


pvalue <- function(x,...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

mean_sd <- function(x) {
  # Handle missing values explicitly
  s <- stats::sd(x, na.rm=TRUE)
  m <- mean(x, na.rm=TRUE)
  sprintf("%.2f (%.2f)", m, s)
}

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg | diagnosis_of_diabetes, data=dat,overall=F, extra.col=list(`P-value`=pvalue), render.continuous = mean_sd)

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg + diagnosis_of_diabetes | glp1agonist, data=dat,overall=F, extra.col=list(`P-value`=pvalue), render.continuous = mean_sd)

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg | diagnosis_of_diabetes, data=dat,render.continuous = render.continuous.custom)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, data = dat,render.continuous = render.continuous.custom)

# Generate the table
table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, 
       data = dat, 
       overall = , 
       extra.col = list(`P-value` = pvalue), 
       render.continuous = render.continuous.custom)
#bmi,masld,TGs,AST/ALT (Liver enzymes),ggt, steatosis grade and or percentages,lobular inflam grade, fibrosis stage

# Descriptive stats
liver_meta_raw_sc <- meta_liver_raw %>%
  filter(Cryostor_ID!="")
form <- paste("diagnosis_of_diabetes", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

## MASLD Y/N
liver_meta_raw_sc <- meta_liver_raw %>%
  filter(Cryostor_ID!="")
form <- paste("diagnosis_of_MASLD", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

## GLP-1RA Y/N
liver_meta_raw_sc <- liver_meta_raw %>%
  filter(Cryostor_ID!="")
form <- paste("glp1agonist", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

```

##b. Kidney
```{r echo = F}
dat <- readRDS("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Data Harmonization/Data Exports/PB90_clinical_metadata_only_12_10.rds")
unique(so_kidney_sc$kit_id)
dat <- dat %>% 
  filter(kit_id %in% unique(so_kidney_sc$kit_id)) %>%
  mutate(both=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>% 
  mutate(exclusive_sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>% 
  mutate(exclusive_glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>% 
  mutate(neither=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))
dat <- dat %>% 
  filter(group=="Type 2 Diabetes")

dat$record_id %in% unique(so_kidney_sc$record_id)
unique(so_kidney_sc$record_id)
table(dat$exclusive_sglt2) #-/+ #27 no, 10 yes
table(dat$exclusive_glp1) #+/- #29 no, 8 yes
table(dat$both) #+/+ #33 no, 4 yes
table(dat$neither) #-/- #22 no, 15 yes




# dat <- dat %>% 
#   filter(diagnosis_of_diabetes=="Yes")
# cor(dat$ast,dat$alt,method="pearson")
# cor(dat$ast,dat$alt,method="spearman")
# cor(dat$alt,dat$tg,method="spearman")

# dat$diagnosis_of_diabetes <- factor(dat$diagnosis_of_diabetes, levels=c("Yes","No"), labels=c("Type 2 Diabetes", "Obese Controls"))
# dat$nih_sex     <- factor(dat$nih_sex, levels=c("Male", "Female"), labels=c("Male", "Female"))
# dat$nih_ethnicity   <- factor(dat$nih_ethnicity, levels=c("Hispanic_Or_Latino","NonHispanic"), labels=c("Hispanic or Latino","Non-Hispanic/Non-Latino"))
# dat$nih_race   <- factor(dat$nih_race, levels=c("White","BlackAfAm","Multiracial","Other"),
#                          labels=c("White","Black","Multirace","Other"))
# dat$steatosis_grade <- as.factor(dat$steatosis_grade)
# dat$fibrosis_stage <- as.factor(dat$fibrosis_stage)
# dat$lobular_inflammation_percent <- as.factor(dat$lobular_inflammation_percent)
# 
# label(dat$age)      <- "Age (y)"
# label(dat$nih_sex)      <- "Sex"
# label(dat$nih_race)    <- "Race"
# label(dat$nih_ethnicity)    <- "Ethnicity"
# label(dat$diagnosis_of_diabetes)  <- "Diabetes Status"
# label(dat$bmi)   <- "Body Mass Index (kg/m2)"
# label(dat$diagnosis_of_MASLD)  <- "MASLD Status"
# label(dat$sbp)     <- "Systolic Blood Pressure (mmHg)"
# label(dat$dbp) <- "Diastolic Blood Pressure (mmHg)"
# label(dat$tg) <-  "Triglycerides (mg/dL)"
# label(dat$creatinine) <-  "Creatinine (mg/dL)"
# label(dat$steatosis_percent) <- "Steatosis Percent (%)"
# label(dat$fibrosis_stage) <- "Fibrosis Stage"
# label(dat$lobular_inflammation_percent) <- "Lobular Inflammation Percent (%)"
dat2 <- dat %>% 
  filter(group=="Type 2 Diabetes" | group=="Obese Control" | group=="Lean Control")
dat3 <- dat %>% 
  filter(group=="Type 2 Diabetes")
table1(~ age + sex + race + epic_glp1ra_1 + epic_sglti2_1 + acr_u + albuminuria_cat| group, data=dat2)
table1(~ age + sex + race + epic_sglti2_1 + acr_u + albuminuria_cat| epic_glp1ra_1 , data=dat2)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, data = dat)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + diagnosis_of_diabetes + a1c  + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | glp1agonist, data = dat)


pvalue <- function(x,...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

mean_sd <- function(x) {
  # Handle missing values explicitly
  s <- stats::sd(x, na.rm=TRUE)
  m <- mean(x, na.rm=TRUE)
  sprintf("%.2f (%.2f)", m, s)
}

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg | diagnosis_of_diabetes, data=dat,overall=F, extra.col=list(`P-value`=pvalue), render.continuous = mean_sd)

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg + diagnosis_of_diabetes | glp1agonist, data=dat,overall=F, extra.col=list(`P-value`=pvalue), render.continuous = mean_sd)

table1(~ age + nih_sex + nih_race + bmi + diagnosis_of_MASLD + sbp + dbp + tg | diagnosis_of_diabetes, data=dat,render.continuous = render.continuous.custom)

table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, data = dat,render.continuous = render.continuous.custom)

# Generate the table
table1(~ age + nih_sex + nih_race + diagnosis_of_MASLD + bmi+ tg + ast + alt + ggt + steatosis_percent + lobular_inflammation_percent + fibrosis_stage | diagnosis_of_diabetes, 
       data = dat, 
       overall = , 
       extra.col = list(`P-value` = pvalue), 
       render.continuous = render.continuous.custom)
#bmi,masld,TGs,AST/ALT (Liver enzymes),ggt, steatosis grade and or percentages,lobular inflam grade, fibrosis stage

# Descriptive stats
liver_meta_raw_sc <- meta_liver_raw %>%
  filter(Cryostor_ID!="")
form <- paste("diagnosis_of_diabetes", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

## MASLD Y/N
liver_meta_raw_sc <- meta_liver_raw %>%
  filter(Cryostor_ID!="")
form <- paste("diagnosis_of_MASLD", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

## GLP-1RA Y/N
liver_meta_raw_sc <- liver_meta_raw %>%
  filter(Cryostor_ID!="")
form <- paste("glp1agonist", paste(colnames(liver_meta_raw_sc)[6:36], collapse = " + "), sep = " ~ ")

summary(arsenal::tableby(formula = as.formula(form), data = liver_meta_raw_sc, test = F))

```

#5. Differential Expression & GSE Analysis by Groups
##LIVER
##a. Diabetes Status
###i. All cell types 
```{r}
Idents(so_liver_sn) <- so_liver_sn$celltype
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", NULL, "_top")

#Gene set enrichment analysis
sce_sn_hep <- as.SingleCellExperiment(so_liver_sn_hep)
rm(so_liver_sn_hep)
## C2 category is according to canonical pathways: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/pdf/nihms-743907.pdf
geneSets <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
### filter background to only include genes that we assessed
geneSets$gene_symbol <- toupper(geneSets$gene_symbol)
geneSets <- geneSets[geneSets$gene_symbol %in% names(sce_sn_hep),]
m_list <- geneSets %>% split(x = .$gene_symbol, f = .$gs_name)
stats <- m$p_val_adj
names(stats) <- rownames(m)
eaRes <- fgsea(pathways = m_list, stats = na.omit(stats))
#ooEA <- order(eaRes$pval, decreasing = FALSE)
#kable(head(eaRes[ooEA, 1:7], n = 20))
# Convert the leadingEdge column to comma-separated strings
eaRes$leadingEdge <- sapply(eaRes$leadingEdge, function(x) paste(x, collapse = ", "))
gc()
# Save to CSV
write.csv(eaRes, fs::path(dir.results,"GSEA_Diabetes_Hepatocytes.csv"))
gc()

#IPA Pathways 
test_ipa <- readxl::read_xls("/Users/choiyej/Dropbox/PANTHER/IPA results/tanner_stage_12_345_rh_de_table_export.xls", skip = 1)
colnames(test_ipa) <- c("pathway", "neglog_p", "ratio", "zscore", "molecules")

# Volcano plot
sig_cutoff = -log(0.05, base = 10)

test_ipa <- test_ipa %>%
  dplyr::mutate(direction = case_when(zscore < 0 & neglog_p > sig_cutoff ~ "Negative", 
                                      zscore > 0 & neglog_p > sig_cutoff ~ "Positive",
                                      zscore == 0 & neglog_p > sig_cutoff ~ "Unknown",
                                      T ~ "NS")) %>%
  group_by(direction) %>%
  dplyr::mutate(count = row_number(),
                label = case_when(direction != "NS" ~ paste0(str_sub(direction, 1,1), count))) %>%
  ungroup()

test_ipa$direction <- factor(test_ipa$direction, levels = c("Negative", "Positive", "Unknown", "NS"))

ipa.plot <- test_ipa %>% filter(neglog_p > 0) %>%
  ggplot(aes(x = zscore, y = neglog_p)) + 
  geom_point(aes(color = direction), alpha = 0.5, size = 2) +
  geom_hline(aes(yintercept = sig_cutoff), color = "red", linetype = "dashed") +
  labs(x = "Z-Score",
       y = "-log(p-value)",
       color = "Direction") + 
  scale_color_manual(values = c("#bf0603", "#457b9d",
                                "#f6bd60", "#dad7cd")) +
  ggrepel::geom_label_repel(aes(label = label, color = direction),
                            label.size = 0.15,
                            max.overlaps = 100, 
                            min.segment.length = 0.01) +
  theme_bw()

# Table
ipa.table.neg <- test_ipa %>%
  dplyr::filter(direction == "Negative") %>%
  dplyr::select(label, pathway) 
ipa.table.pos <- test_ipa %>%
  dplyr::filter(direction == "Positive") %>%
  dplyr::select(label, pathway) 
ipa.table.unk <- test_ipa %>%
  dplyr::filter(direction == "Unknown") %>%
  dplyr::select(label, pathway) 

cbind.fill <- function(...) {
  nm <- list(...) 
  nm <- lapply(nm, as.matrix)
  n <- max(sapply(nm, nrow)) 
  do.call(cbind, lapply(nm, function(x) {
    filled_matrix <- ifelse(is.na(x), "", x)
    rbind(filled_matrix, matrix("", n - nrow(filled_matrix), ncol(filled_matrix)))
  }))
}

ipa.table.comb <- cbind.fill(ipa.table.neg,ipa.table.pos,ipa.table.unk)
gg.ipa.table <- ggtexttable(ipa.table.comb, rows = NULL,
                            cols = c("Label", "Pathway", "Label", "Pathway","Label", "Pathway"),
                            theme = ttheme("blank",
                                           tbody.style = tbody_style(fill = "white", 
                                                                     size = 8.5, 
                                                                     hjust = 0,
                                                                     x = 0.1))) %>%
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 0.8)



ggarrange(ipa.plot, gg.ipa.table,
          ncol = 2, heights = c(1,1), widths = c(0.5,1),
          legend = "top")


```

###ii. Hepatocytes
```{r}
#Hepatocytes only
# rm(so_liver_sn)
genes <- unique(rownames(so_liver_sn_hep))
de.markers(so_liver_sn_hep, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hepatocyte", "")
# write.csv(m,fs::path(dir.results,"DEG_Diabetes_Hepatocytes.csv"))


#Gene set enrichment analysis
sce_sn_hep <- as.SingleCellExperiment(so_liver_sn_hep)
rm(so_liver_sn_hep)
## C2 category is according to canonical pathways: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/pdf/nihms-743907.pdf
geneSets <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
### filter background to only include genes that we assessed
geneSets$gene_symbol <- toupper(geneSets$gene_symbol)
geneSets <- geneSets[geneSets$gene_symbol %in% names(sce_sn_hep),]
m_list <- geneSets %>% split(x = .$gene_symbol, f = .$gs_name)
stats <- m$p_val_adj
names(stats) <- rownames(m)
eaRes <- fgsea(pathways = m_list, stats = na.omit(stats))
#ooEA <- order(eaRes$pval, decreasing = FALSE)
#kable(head(eaRes[ooEA, 1:7], n = 20))
# Convert the leadingEdge column to comma-separated strings
eaRes$leadingEdge <- sapply(eaRes$leadingEdge, function(x) paste(x, collapse = ", "))
gc()
# Save to CSV
write.csv(eaRes, fs::path(dir.results,"GSEA_Diabetes_Hepatocytes.csv"))
gc()
```
###iii. By Hepatocyte Cell types
```{r}
#By cell
Idents(so_liver_sn) <- so_liver_sn$celltype
de.markers(so_liver_sn, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hep-1", "_top")
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hepa-2", "")
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hep-3", "")
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hep-4", "")
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", "Hep-5", "")

#Determine proportion of each hepatocyte type among Type 2s and Not Type 2s
# Extract metadata
metadata <- so_liver_sn@meta.data

# Ensure the cell type and diabetes diagnosis columns are present
head(metadata[, c("celltype", "diagnosis_of_diabetes")])

# Define relevant cell types
hep_celltypes <- c("Hep-1", "Hep-2", "Hep-3", "Hep-4", "Hep-5")

# Subset metadata for these cell types
metadata_hep <- metadata %>% filter(celltype %in% hep_celltypes)

# Calculate proportions by group and cell type
proportions <- metadata_hep %>%
  group_by(diagnosis_of_diabetes, celltype) %>%
  summarise(count = n()) %>%
  group_by(diagnosis_of_diabetes) %>%
  mutate(proportion = count / sum(count))

ggplot(proportions, aes(x = diagnosis_of_diabetes, y = proportion, fill = celltype)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Proportion of Hep Cell Types by Diabetes Status",
       x = "Diabetes Diagnosis",
       y = "Proportion") +
  theme_minimal()


ggplot(proportions, aes(x = celltype, y = proportion, fill = diagnosis_of_diabetes)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Proportion of Hep Cell Types by Diabetes Status",
       x = "Cell Type",
       y = "Proportion") +
  theme_minimal()

```

##b. MASLD Status
```{r}
Idents(so_liver_sc) <- so_liver_sc$celltype
de.markers(so_liver_sc, genes, "diagnosis_of_MASLD", id2 = "No", id1 = "Yes", "Hepatocyte1", "")
de.markers(so_liver_sc, genes, "diagnosis_of_MASLD", id2 = "No", id1 = "Yes", "Hepatocyte2", "")
de.markers(so_liver_sc, genes, "diagnosis_of_MASLD", id2 = "No", id1 = "Yes", "Hepatocyte3", "")

Idents(so_liver_sc) <- so_liver_sc$hepatocyte
de.markers(so_liver_sc, genes, "diagnosis_of_MASLD", id2 = "No", id1 = "Yes", "Hepatocyte", "")

```

##c. GLP-1RA Status
```{r}
genes <- unique(rownames(so_liver_sn_hep))
Idents(so_liver_sn_hep) <- so_liver_sn_hep$hepatocyte
de.markers(so_liver_sn_hep, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte", "")
de.markers(so_liver_sn_hep, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte", "")

#Idents(so_liver_sc) <- so_liver_sc$celltype
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte1", "")
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte2", "")
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte3", "")

```
##KIDNEY
###i. All cell types 
```{r}
Idents(so_liver_sn) <- so_liver_sn$celltype
de.markers(so_liver_sn, genes, "diagnosis_of_diabetes", id2 = "No", id1 = "Yes", NULL, "_top")

#Gene set enrichment analysis
sce_sn_hep <- as.SingleCellExperiment(so_liver_sn_hep)
rm(so_liver_sn_hep)
## C2 category is according to canonical pathways: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/pdf/nihms-743907.pdf
geneSets <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
### filter background to only include genes that we assessed
geneSets$gene_symbol <- toupper(geneSets$gene_symbol)
geneSets <- geneSets[geneSets$gene_symbol %in% names(sce_sn_hep),]
m_list <- geneSets %>% split(x = .$gene_symbol, f = .$gs_name)
stats <- m$p_val_adj
names(stats) <- rownames(m)
eaRes <- fgsea(pathways = m_list, stats = na.omit(stats))
#ooEA <- order(eaRes$pval, decreasing = FALSE)
#kable(head(eaRes[ooEA, 1:7], n = 20))
# Convert the leadingEdge column to comma-separated strings
eaRes$leadingEdge <- sapply(eaRes$leadingEdge, function(x) paste(x, collapse = ", "))
gc()
# Save to CSV
write.csv(eaRes, fs::path(dir.results,"GSEA_Diabetes_Hepatocytes.csv"))
gc()

#IPA Pathways 
test_ipa <- readxl::read_xls("/Users/choiyej/Dropbox/PANTHER/IPA results/tanner_stage_12_345_rh_de_table_export.xls", skip = 1)
colnames(test_ipa) <- c("pathway", "neglog_p", "ratio", "zscore", "molecules")

# Volcano plot
sig_cutoff = -log(0.05, base = 10)

test_ipa <- test_ipa %>%
  dplyr::mutate(direction = case_when(zscore < 0 & neglog_p > sig_cutoff ~ "Negative", 
                                      zscore > 0 & neglog_p > sig_cutoff ~ "Positive",
                                      zscore == 0 & neglog_p > sig_cutoff ~ "Unknown",
                                      T ~ "NS")) %>%
  group_by(direction) %>%
  dplyr::mutate(count = row_number(),
                label = case_when(direction != "NS" ~ paste0(str_sub(direction, 1,1), count))) %>%
  ungroup()

test_ipa$direction <- factor(test_ipa$direction, levels = c("Negative", "Positive", "Unknown", "NS"))

ipa.plot <- test_ipa %>% filter(neglog_p > 0) %>%
  ggplot(aes(x = zscore, y = neglog_p)) + 
  geom_point(aes(color = direction), alpha = 0.5, size = 2) +
  geom_hline(aes(yintercept = sig_cutoff), color = "red", linetype = "dashed") +
  labs(x = "Z-Score",
       y = "-log(p-value)",
       color = "Direction") + 
  scale_color_manual(values = c("#bf0603", "#457b9d",
                                "#f6bd60", "#dad7cd")) +
  ggrepel::geom_label_repel(aes(label = label, color = direction),
                            label.size = 0.15,
                            max.overlaps = 100, 
                            min.segment.length = 0.01) +
  theme_bw()

# Table
ipa.table.neg <- test_ipa %>%
  dplyr::filter(direction == "Negative") %>%
  dplyr::select(label, pathway) 
ipa.table.pos <- test_ipa %>%
  dplyr::filter(direction == "Positive") %>%
  dplyr::select(label, pathway) 
ipa.table.unk <- test_ipa %>%
  dplyr::filter(direction == "Unknown") %>%
  dplyr::select(label, pathway) 

cbind.fill <- function(...) {
  nm <- list(...) 
  nm <- lapply(nm, as.matrix)
  n <- max(sapply(nm, nrow)) 
  do.call(cbind, lapply(nm, function(x) {
    filled_matrix <- ifelse(is.na(x), "", x)
    rbind(filled_matrix, matrix("", n - nrow(filled_matrix), ncol(filled_matrix)))
  }))
}

ipa.table.comb <- cbind.fill(ipa.table.neg,ipa.table.pos,ipa.table.unk)
gg.ipa.table <- ggtexttable(ipa.table.comb, rows = NULL,
                            cols = c("Label", "Pathway", "Label", "Pathway","Label", "Pathway"),
                            theme = ttheme("blank",
                                           tbody.style = tbody_style(fill = "white", 
                                                                     size = 8.5, 
                                                                     hjust = 0,
                                                                     x = 0.1))) %>%
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 0.8)



ggarrange(ipa.plot, gg.ipa.table,
          ncol = 2, heights = c(1,1), widths = c(0.5,1),
          legend = "top")


```

###ii. PT Cells
```{r}
so_kidney_sc@meta.data$PT <- ifelse(grepl("PT-",so_kidney_sc@meta.data$celltype_rpca),"PT","Non-PT")
Idents(so_kidney_sc) <- so_kidney_sc$PT
sens_genes <- c(sens_genes,"CDKN1A")
de.markers(so_kidney_sc, sens_genes, "epic_glp1ra_1", id2 = "No", id1 = "Yes", "PT", "")
# write.csv(m,fs::path(dir.results,"DEG_Diabetes_Hepatocytes.csv"))

ggmaplot(
  data,
  fdr = 0.05,
  fc = 1.5,
  genenames = NULL,
  detection_call = NULL,
  size = NULL,
  alpha = 1,
  seed = 42,
  font.label = c(12, "plain", "black"),
  label.rectangle = FALSE,
  palette = c("#B31B21", "#1465AC", "darkgray"),
  top = 15,
  select.top.method = c("padj", "fc"),
  label.select = NULL,
  main = NULL,
  xlab = "Log2 mean expression",
  ylab = "Log2 fold change",
  ggtheme = theme_classic(),
  ...
)

#Gene set enrichment analysis
sce_sn_hep <- as.SingleCellExperiment(so_liver_sn_hep)
rm(so_liver_sn_hep)
## C2 category is according to canonical pathways: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/pdf/nihms-743907.pdf
geneSets <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
### filter background to only include genes that we assessed
geneSets$gene_symbol <- toupper(geneSets$gene_symbol)
geneSets <- geneSets[geneSets$gene_symbol %in% names(sce_sn_hep),]
m_list <- geneSets %>% split(x = .$gene_symbol, f = .$gs_name)
stats <- m$p_val_adj
names(stats) <- rownames(m)
eaRes <- fgsea(pathways = m_list, stats = na.omit(stats))
#ooEA <- order(eaRes$pval, decreasing = FALSE)
#kable(head(eaRes[ooEA, 1:7], n = 20))
# Convert the leadingEdge column to comma-separated strings
eaRes$leadingEdge <- sapply(eaRes$leadingEdge, function(x) paste(x, collapse = ", "))
gc()
# Save to CSV
write.csv(eaRes, fs::path(dir.results,"GSEA_Diabetes_Hepatocytes.csv"))
gc()
```


##c. GLP-1RA Status
```{r}
genes <- unique(rownames(so_liver_sn_hep))
Idents(so_liver_sn_hep) <- so_liver_sn_hep$hepatocyte
de.markers(so_liver_sn_hep, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte", "")
de.markers(so_liver_sn_hep, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte", "")

#Idents(so_liver_sc) <- so_liver_sc$celltype
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte1", "")
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte2", "")
#de.markers(so_liver_sc, genes, "glp1agonist", id2 = "No", id1 = "Yes", "Hepatocyte3", "")

```
#6. Senesence Diff Exp 
##a. Diabetes Status 
```{r}
#Diff by Diabetes Status
Idents(so_sens) <- so_sens$hepatocyte
de.markers(so_sens, sens_genes, "diagnosis_of_diabetes", id1 = "Yes", id2 = "No", "Hepatocyte", "",min.pct=0.1)
#write.csv(m,fs::path(dir.results,"DEG_Diabetes_Senesence.csv"))
m_top <- m
significant_genes <- m_top %>% filter(p_val_adj < 0.05)

# Select the top 10 positive and top 10 negative log2FC genes that are significant
top_genes <- rbind(
  significant_genes %>% arrange(desc(avg_log2FC)) %>% head(20),  # Top 10 positive log2FC
  significant_genes %>% arrange(avg_log2FC) %>% head(20)         # Top 10 negative log2FC
)

labels <- ifelse(rownames(m_top) %in% rownames(top_genes), rownames(m_top), NA)
p <- EnhancedVolcano(m_top,
                     lab = labels,
                     x = 'avg_log2FC',
                     y = 'p_val_adj',
                     title = paste0("Differentially Expressed Senesence Genes by Diabetes Status (Pseudobulk Hepatocytes)"),
                     subtitle = paste0("Positive Log2 FC = Greater Expression in Diabetes vs. No Diabetes\n",
                                       "(Significant at FDR-P<0.05, FC Threshold = 0.25)"),
                     pCutoff = 0.05,
                     FCcutoff = 0.25,
                     labFace = 'bold',
                     pointSize = 4,
                     labSize = 5,
                     drawConnectors = TRUE,
                     widthConnectors = 1.0,
                     colConnectors = 'black',
                     legendPosition=NULL,
                     boxedLabels = TRUE,
                     xlim = c(-2,2),
                     max.overlaps=30)
plot(p)

# Filter top 10 positive and negative log2FoldChange
top_pos <- as.data.frame(m) %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(desc(avg_log2FC)) %>% 
  dplyr::slice(1:10) 
top_pos$Gene <- rownames(top_pos)
top_pos <- top_pos[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"

top_neg <- m %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(avg_log2FC) %>% 
  dplyr::slice(1:10) 
top_neg$Gene <- rownames(top_neg)
top_neg <- top_neg[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_neg) <- NULL
top_neg$Direction <- "Negative"

# Combine and prepare for plotting
top_genes <- bind_rows(top_pos, top_neg) 

# Bar chart
ggplot(top_genes, aes(x = Gene, y = avg_log2FC, fill = Direction)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Gene", y = "log2 Fold Change", title = "Top 10 Positive and Negative DEGs") +
  scale_fill_manual(values = c("red", "blue"), labels = c("Negative", "Positive")) +
  theme_minimal()


# Set sorting order: all negative genes first, then all positive genes
top_genes <- top_genes %>%
  mutate(Gene = factor(Gene, levels = Gene[order(Direction, avg_log2FC)]))  # Order by Direction and log2FC

# Bar chart with flipped x and y axes
b <- ggplot(top_genes, aes(x = avg_log2FC, y = Gene, fill = Direction)) +
  geom_bar(stat = "identity") +
  labs(x = "log2 Fold Change", y = "Gene", title = "Top 10 Positive and Negative DEGs in Diabetes vs. No Diabetes") +
  scale_fill_manual(values = c("blue", "red"), labels = c("Downregulated in Diabetes", "Upregulated in Diabetes")) +
  theme_minimal()

```
##b. MASLD Status
```{r}
#MASLD
Idents(so_sens) <- so_sens$hepatocyte
de.markers(so_sens, sens_genes, "diagnosis_of_MASLD", id1 = "Yes", id2 = "No", "Hepatocyte", "",min.pct=0.1)
# write.csv(m,fs::path(dir.results,"Senesence Results","DEG_MASLD_Senesence.csv"))
m_top <- m
significant_genes <- m_top %>% filter(p_val_adj < 0.05)

# Select the top 10 positive and top 10 negative log2FC genes that are significant
top_genes <- rbind(
  significant_genes %>% arrange(desc(avg_log2FC)) %>% head(40),  # Top 10 positive log2FC
  significant_genes %>% arrange(avg_log2FC) %>% head(40)         # Top 10 negative log2FC
)

labels <- ifelse(rownames(m_top) %in% rownames(top_genes), rownames(m_top), NA)
p <- EnhancedVolcano(m_top,
                     lab = labels,
                     x = 'avg_log2FC',
                     y = 'p_val_adj',
                     title = paste0("Differentially Expressed Senesence Genes by MASLD Status (Pseudobulk Hepatocytes)"),
                     subtitle = paste0("Positive Log2 FC = Greater Expression in MASLD vs. No MASLD\n",
                                       "(Significant at FDR-P<0.05, FC Threshold = 0.25)"),
                     pCutoff = 0.05,
                     FCcutoff = 0.25,
                     labFace = 'bold',
                     pointSize = 4,
                     labSize = 5,
                     drawConnectors = TRUE,
                     widthConnectors = 1.0,
                     colConnectors = 'black',
                     legendPosition=NULL,
                     boxedLabels = TRUE,
                     xlim = c(-2,2),
                     max.overlaps=30)
plot(p)

# Filter top 10 positive and negative log2FoldChange
top_pos <- as.data.frame(m) %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(desc(avg_log2FC)) %>% 
  dplyr::slice(1:10) 
top_pos$Gene <- rownames(top_pos)
top_pos <- top_pos[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"

top_neg <- m %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(avg_log2FC) %>% 
  dplyr::slice(1:10) 
top_neg$Gene <- rownames(top_neg)
top_neg <- top_neg[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_neg) <- NULL
top_neg$Direction <- "Negative"

# Combine and prepare for plotting
top_genes <- bind_rows(top_pos, top_neg) 

# Bar chart
ggplot(top_genes, aes(x = Gene, y = avg_log2FC, fill = Direction)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Gene", y = "log2 Fold Change", title = "Top 10 Positive and Negative DEGs") +
  scale_fill_manual(values = c("red", "blue"), labels = c("Negative", "Positive")) +
  theme_minimal()


# Set sorting order: all negative genes first, then all positive genes
top_genes <- top_genes %>%
  mutate(Gene = factor(Gene, levels = Gene[order(Direction, avg_log2FC)]))  # Order by Direction and log2FC

# Bar chart with flipped x and y axes
b <- ggplot(top_genes, aes(x = avg_log2FC, y = Gene, fill = Direction)) +
  geom_bar(stat = "identity") +
  labs(x = "log2 Fold Change", y = "Gene", title = "Top 10 Positive and Negative DEGs in MASLD vs. No MASLD") +
  scale_fill_manual(values = c("blue", "red"), labels = c("Downregulated in MASLD", "Upregulated in MASLD")) +
  theme_minimal()
```
##c. GLP-1 Status
```{r}
#GLP1
#Need to filter to just Type 2
so_diab <- subset(so_sens, diagnosis_of_diabetes == "Yes")
DefaultAssay(object = so_diab) <- "RNA"

#DEG
de.markers(so_diab, sens_genes, "glp1agonist", id1 = "Yes", id2 = "No", "Hepatocyte", "")
write.csv(m,fs::path(dir.results,"Senesence Results","DEG_GLP1_Senesence.csv"))
m_top <- m
significant_genes <- m_top %>% filter(p_val_adj < 0.05)

# Select the top 10 positive and top 10 negative log2FC genes that are significant
top_genes <- rbind(
  significant_genes %>% arrange(desc(avg_log2FC)) %>% head(20),  # Top 10 positive log2FC
  significant_genes %>% arrange(avg_log2FC) %>% head(20)         # Top 10 negative log2FC
)

labels <- ifelse(rownames(m_top) %in% rownames(top_genes), rownames(m_top), NA)
p <- EnhancedVolcano(m_top,
                     lab = labels,
                     x = 'avg_log2FC',
                     y = 'p_val_adj',
                     title = paste0("Differentially Expressed Senesence Genes by GLP-1 Status (Among T2D, Pseudobulk Hepatocytes)"),
                     subtitle = paste0("Positive Log2 FC = Greater Expression in GLP-1 vs. No GLP-1\n",
                                       "(Significant at FDR-P<0.05, FC Threshold = 0.25)"),
                     pCutoff = 0.05,
                     FCcutoff = 0.25,
                     labFace = 'bold',
                     pointSize = 4,
                     labSize = 5,
                     drawConnectors = TRUE,
                     widthConnectors = 1.0,
                     colConnectors = 'black',
                     legendPosition=NULL,
                     boxedLabels = TRUE,
                     xlim = c(-2,2),
                     max.overlaps=30)
plot(p)

# Filter top 10 positive and negative log2FoldChange
top_pos <- as.data.frame(m) %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(desc(avg_log2FC)) %>% 
  dplyr::slice(1:10) 
top_pos$Gene <- rownames(top_pos)
top_pos <- top_pos[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"

top_neg <- m %>% 
  filter(p_val_adj<0.05) %>% 
  arrange(avg_log2FC) %>% 
  dplyr::slice(1:10) 
top_neg$Gene <- rownames(top_neg)
top_neg <- top_neg[c("Gene","avg_log2FC","p_val_adj")]
rownames(top_neg) <- NULL
top_neg$Direction <- "Negative"

# Combine and prepare for plotting
top_genes <- bind_rows(top_pos, top_neg) 

# Bar chart
ggplot(top_genes, aes(x = Gene, y = avg_log2FC, fill = Direction)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Gene", y = "log2 Fold Change", title = "Top 10 Positive and Negative DEGs") +
  scale_fill_manual(values = c("red", "blue"), labels = c("Negative", "Positive")) +
  theme_minimal()


# Set sorting order: all negative genes first, then all positive genes
top_genes <- top_genes %>%
  mutate(Gene = factor(Gene, levels = Gene[order(Direction, avg_log2FC)]))  # Order by Direction and log2FC

# Bar chart with flipped x and y axes
b <- ggplot(top_genes, aes(x = avg_log2FC, y = Gene, fill = Direction)) +
  geom_bar(stat = "identity") +
  labs(x = "log2 Fold Change", y = "Gene", title = "Top 10 Positive and Negative DEGs in T2D") +
  scale_fill_manual(values = c("blue", "red"), labels = c("Downregulated in GLP-1", "Upregulated in GLP-1")) +
  theme_minimal()
```

#7. GSEA: Gene Set enrichment analysis
```{r echo = F}
#sce_sn_hep <- as.SingleCellExperiment(so_liver_sn_hep)
## C2 category is according to canonical pathways: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/pdf/nihms-743907.pdf
geneSets <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
### filter background to only include genes that we assessed
geneSets$gene_symbol <- toupper(geneSets$gene_symbol)
geneSets <- geneSets[geneSets$gene_symbol %in% names(sce_sn_hep),]
m_list <- geneSets %>% split(x = .$gene_symbol, f = .$gs_name)
stats <- m$p_val_adj
names(stats) <- rownames(m)
eaRes <- fgsea(pathways = m_list, stats = na.omit(stats))
#ooEA <- order(eaRes$pval, decreasing = FALSE)
#kable(head(eaRes[ooEA, 1:7], n = 20))
# Convert the leadingEdge column to comma-separated strings
eaRes$leadingEdge <- sapply(eaRes$leadingEdge, function(x) paste(x, collapse = ", "))

# Save to CSV
write.csv(eaRes, "GSEA_Diabetes.csv", row.names = FALSE)
```

#8. Association between Groups & Genes
##a. Full Gene Set
###i. Kidney
```{r}
so_diab$celltype2 <- ifelse(grepl("TAL-",so_diab$celltype_rpca),"TAL",
                            ifelse(grepl("PT-",so_diab$celltype_rpca),"PT",
                                   ifelse(grepl("PC-",so_diab$celltype_rpca),"PC",
                                          ifelse(grepl("DTL-",so_diab$celltype_rpca),"DTL",
                                                 ifelse(grepl("IC-",so_diab$celltype_rpca),"IC",so_diab$celltype_rpca)))))

# unique(so_diab$celltype_rpca)
# unique(so_diab$celltype2)

# genes <- rownames(so_diab)

# Create a single grouping variable
so_diab@meta.data$group <- with(so_diab@meta.data, case_when(
  both == "Yes" ~ "both",
  exclusive_sglt2 == "Yes" ~ "exclusive_sglt2",
  exclusive_glp1 == "Yes" ~ "exclusive_glp1",
  neither == "Yes" ~ "neither"
))

so_diab@meta.data$group <- factor(so_diab@meta.data$group, levels = c("neither", "both", "exclusive_sglt2", "exclusive_glp1"))

#Test 
# so=so_diab
# cell="PT"
# exposure="group"
# covariate=NULL
# gene_set=rownames(so_diab)
# batch_size=2000
# exp_group="both"
# ref_group="neither"
# so <- subset(so_diab,group=="neither" | group == "both")
# enrichment="Yes"
# top_gsea_pathways <- 40

#Run function
# (+/+) : "both"
# (-/+): "exclusive_sglt2"
# (+/-): "exclusive_glp1"
# (-/-): "neither"

#Set full gene set
genes <- rownames(so_diab)
# genes <- genes[1:2000]

#(-/-) vs. (+/+)
all_results <- mast_fxn(so=so_diab,cell="PT",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="both",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(-/-) vs. (-/+)
all_results <- mast_fxn(so=so_diab,cell="PT",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_sglt2",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(-/-) vs. (+/-)
all_results <- mast_fxn(so=so_diab,cell="PT",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_glp1",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(+/+) vs. (-/+)
all_results <- mast_fxn(so=so_diab,cell="PT",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_sglt2",ref_group="both",enrichment="Yes",top_gsea_pathways=40)
#(+/+) vs. (+/-)
all_results <- mast_fxn(so=so_diab,cell="PT",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_glp1",ref_group="both",enrichment="Yes",top_gsea_pathways=40)


```

###ii. Liver
```{r}

# unique(so_liver_sn$celltype)
so_liver_sn$celltype2 <- ifelse(grepl("Hep-",so_liver_sn$celltype),"Hepatocyte",
                                ifelse(grepl("Stellate-",so_liver_sn$celltype),"Stellate",
                                       ifelse(grepl("EC-",so_liver_sn$celltype),"EC",so_liver_sn$celltype)))

#Set Groups
# (+/+) : "both"
# (-/+): "exclusive_sglt2"
# (+/-): "exclusive_glp1"
# (-/-): "neither"
#dat <- read.csv(fs::path(dir.dat,"scRNA","data_clean","liver_biopsy_metadata_PN.csv"))


#Set full gene set
genes <- rownames(so_liver_sn)

#Diabetes (Yes/No)

#ALT

#AST

#Filter to diabetes only
so_diab <- subset(so_liver_sn,group2)

#(-/-) vs. (+/+)
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="both",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(-/-) vs. (-/+)
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_sglt2",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(-/-) vs. (+/-)
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_glp1",ref_group="neither",enrichment="Yes",top_gsea_pathways=40)
#(+/+) vs. (-/+)
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_sglt2",ref_group="both",enrichment="Yes",top_gsea_pathways=40)
#(+/+) vs. (+/-)
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="group",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="exclusive_glp1",ref_group="both",enrichment="Yes",top_gsea_pathways=40)


# # Parameters
# total_genes <- nrow(so_liver_sn)  # Total number of genes
# batch_size <- 2000                  # Batch size
# all_genes <- rownames(so_liver_sn) # All gene names
# cell_type <- "your_cell_type"        # Specify your cell type
# exposure <- "your_exposure"          # Specify your exposure variable
# covariate <- "your_covariate"        # Specify your covariate variable

# # Placeholder to store batch results
# all_results <- list()
# 
# # Loop through genes in batches
# for (start_index in seq(1, total_genes, by = batch_size)) {
#   # Define the end of the current batch
#   end_index <- min(start_index + batch_size - 1, total_genes)
#   
#   # Subset the current batch of genes
#   gene_batch <- all_genes[start_index:end_index]
#   
#   # Call the function with the current batch
#   batch_result <- mast_fxn(
#     so = seurat_object, 
#     cell = cell_type, 
#     exposure = exposure, 
#     covariate = covariate, 
#     gene_set = gene_batch
#   )
#   
#   # Store results in the list
#   all_results[[paste0("batch_", start_index, "_to_", end_index)]] <- batch_result
# }
# 
# # Combine all results into a single data frame, if needed
# combined_results <- do.call(rbind, all_results)


# cell <- "Hepatocyte"
# so <- so_liver_sn
# exposure <- "diagnosis_of_diabetes"
# # length(rownames(so_liver_sn))
# #36601 - batches
# gene_set <- rownames(so_liver_sn)
# total_genes <- nrow(so_liver_sn) # Number of genes in the Seurat object
# batch_size <- 2000
# exp_group <- "Yes"

mast_fxn <- function(so,cell,exposure,covariate,gene_set,batch_size,exp_group) {
  DefaultAssay(so) <- "RNA"
  combined_results <- data.frame()
  num_genes <- length(gene_set)
  for (start_batch in seq(1,num_genes,by=batch_size)) {
    
    end_batch <- min(start_batch + batch_size - 1, num_genes)
    batch <- gene_set[start_batch:end_batch]
    #Filter so to specified cell type
    so_filt <- subset(so,celltype2==cell)
    DefaultAssay(so_filt) <- "RNA"
    rm(so)
    subset <- intersect(batch, rownames(so_filt))
    # Subset the Seurat object to include only genes in sens_gene_in_data
    so_subset <- subset(so_filt, features = subset)
    rm(so_filt)
    # Extract the expression data matrix from so (e.g., normalized counts)
    expression_matrix <- as.matrix(GetAssayData(so_subset, layer = "data"))
    
    # Extract metadata
    cell_metadata <- so_subset@meta.data
    cell_metadata[[exposure]] <- factor(cell_metadata[[exposure]])
    
    # Create SingleCellAssay object
    sca <- FromMatrix(exprsArray = expression_matrix, cData = cell_metadata)
    
    # Assuming gene_set is a vector of gene names
    sca_gene_set <- sca[rownames(sca) %in% gene_set, ]
    
    #Define the formula
    model_formula <- as.formula(paste0("~", exposure))
    exp <- paste0(exposure,exp_group)
    
    # Run the linear model with zlm
    zlm_results <- zlm(formula = model_formula, sca = sca_gene_set)
    
    # Summarize results and perform likelihood ratio test (LRT) for outcome
    summary_zlm <- summary(zlm_results, doLRT = exp)
    
    # Convert the summary to a data table for easy manipulation
    summary_dt <- summary_zlm$datatable
    
    batch_results <- summary_dt
    
    combined_results <- rbind(combined_results, batch_results)
  }
}

# so <- so_liver_sn
# exposure <- "diagnosis_of_diabetes"
# # length(rownames(so_liver_sn))
# #36601 - batches
genes <- rownames(so_liver_sn)
# total_genes <- nrow(so_liver_sn) # Number of genes in the Seurat object
# batch_size <- 2000
# exp_group <- "Yes"
all_results <- mast_fxn(so=so_liver_sn,cell="Hepatocyte",exposure="diagnosis_of_diabetes",covariate=NULL,gene_set=genes,batch_size=2000,exp_group="Yes")

all_genes <- rownames(so_liver_sn)

# Process genes in batches
for (start_index in seq(1, total_genes, by = batch_size)) {
  # Get the indices for the current batch
  end_index <- min(start_index + batch_size - 1, total_genes)
  
  # Subset the current batch of genes
  batch_genes <- all_genes[start_index:end_index]
  
  # Run your function on the current batch
  mast_fxn(batch_genes)
}



# Extract the expression data matrix (e.g., normalized counts)
expression_matrix <- as.matrix(GetAssayData(so_liver_sn_hep, layer = "data"))

# Extract metadata
cell_metadata <- so_liver_sn_hep@meta.data

# Create SingleCellAssay object
sca <- FromMatrix(exprsArray = expression_matrix, cData = cell_metadata)

# Assuming gene_set is a vector of gene names
sca_gene_set <- sca[rownames(sca) %in% gene_set, ]

# Define the model with the outcome variable
outcomes <- c("AST","ALT","fibrosis","steatosis","lobular_inflammation")
model_formula <- ~ outcome + covariate

# Run the linear model with zlm
zlm_results <- zlm(formula = model_formula, sca = sca_gene_set)

# Summarize results and perform likelihood ratio test (LRT) for outcome
summary_zlm <- summary(zlm_results, doLRT = 'outcome')

# Convert the summary to a data table for easy manipulation
summary_dt <- summary_zlm$datatable

# Extract results for the outcome variable
result <- summary_dt[contrast == 'outcome' & component == 'H', c("primerid", "Pr(>Chisq)")]

# Adjust p-values for multiple testing (False Discovery Rate)
result$p_adj <- p.adjust(result$`Pr(>Chisq)`, method = "fdr")

# Filter significant results (e.g., adjusted p-value < 0.05)
significant_results <- result[result$p_adj < 0.05, ]
print(significant_results)

```

##b. Senesence Gene Set
###LIVER
###i. Quality Control & Visualizations
```{r}
# Step 1: Extract the expression data matrix (e.g., normalized counts)
expression_matrix <- as.matrix(GetAssayData(so_sens[["RNA"]], layer = "data"))

# Step 2: Filter out genes with zero variance
gene_variance <- apply(expression_matrix, 1, var)
expression_matrix_filtered <- expression_matrix[gene_variance > 0, ]

# Step 3: Extract metadata and add 'wellKey' column
cell_metadata <- so_sens@meta.data
cell_metadata$wellKey <- rownames(cell_metadata)

# Step 7: Create a SingleCellAssay object with the filtered and subsetted expression matrix
sca <- FromMatrix(exprsArray = expression_matrix_filtered, cData = cell_metadata)

# 
#GLP1 diabetes only
so_diab@meta.data$alt_scaled <- scale(so_diab@meta.data$alt) %>% 
  as.numeric()
# Step 1: Extract the expression data matrix (e.g., normalized counts)
expression_matrix <- as.matrix(GetAssayData(so_diab[["RNA"]], layer = "data"))

# Step 2: Filter out genes with zero variance
gene_variance <- apply(expression_matrix, 1, var)
expression_matrix_filtered <- expression_matrix[gene_variance > 0, ]

# Step 3: Extract metadata and add 'wellKey' column
cell_metadata <- so_diab@meta.data
cell_metadata$wellKey <- rownames(cell_metadata)

# Step 7: Create a SingleCellAssay object with the filtered and subsetted expression matrix
sca <- FromMatrix(exprsArray = expression_matrix_filtered, cData = cell_metadata)

```

###ii. Differential Expression Analyses
```{r}
# Assuming gene_set is a vector of gene names
sca_gene_set <- sca[rownames(sca) %in% sens_genes, ]

# Define the model with the exposure variable
#"ast","alt","fibrosis_stage","steatosis_grade")

# Convert count variables to factors
so_sens@meta.data$steatosis_grade <- factor(so_sens@meta.data$steatosis_grade)
so_sens@meta.data$fibrosis_stage <- factor(so_sens@meta.data$fibrosis_stage)
so_sens@meta.data$diagnosis_of_diabetes <- factor(so_sens@meta.data$diagnosis_of_diabetes,levels = c("No", "Yes"), labels = c(0, 1))
so_sens@meta.data$diagnosis_of_MASLD <- factor(so_sens@meta.data$diagnosis_of_MASLD,levels = c("No", "Yes"), labels = c(0, 1))
so_sens@meta.data$glp1agonist <- factor(so_sens@meta.data$glp1agonist, levels = c("No", "Yes"), labels = c(0, 1))
so_sens@meta.data$nih_sex <- factor(so_sens@meta.data$nih_sex)

so_diab@meta.data$steatosis_grade <- factor(so_diab@meta.data$steatosis_grade)
so_diab@meta.data$fibrosis_stage <- factor(so_diab@meta.data$fibrosis_stage)
so_diab@meta.data$diagnosis_of_diabetes <- factor(so_diab@meta.data$diagnosis_of_diabetes)
so_diab@meta.data$diagnosis_of_MASLD <- factor(so_diab@meta.data$diagnosis_of_MASLD)
so_diab@meta.data$glp1agonist <- factor(so_diab@meta.data$glp1agonist, levels = c("No", "Yes"), labels = c(0, 1))
so_diab@meta.data$nih_sex <- factor(so_diab@meta.data$nih_sex)
# so_diab@meta.data$tg <- factor(so_diab@meta.data$tg)
so_diab@meta.data$alt_scaled <- (so_diab@meta.data$alt-mean(so_diab@meta.data$alt,na.rm=T))/sd(so_diab@meta.data$alt,na.rm=T)
so_diab@meta.data$alt_scaled <- scale(so_diab@meta.data$alt) %>% 
  as.numeric()

#Filter to diabetes only
model_formula <- ~ glp1agonist + alt_scaled
#Diabetes status, GLP1 status, age, sex, sbp, HbA1c
# Run the linear model with zlm
zlm_results <- zlm(formula = model_formula, sca = sca_gene_set)
# summary_zlm <- summary(zlm_results)
# Summarize results and perform likelihood ratio test (LRT) for outcome
summary_zlm <- summary(zlm_results, doLRT = "glp1agonist1")
# summary_zlm <- summary(zlm_results)
# Convert the summary to a data table for easy manipulation
summary_dt2 <- summary_zlm$datatable

```

###KIDNEY
###i. Quality Control & Visualizations
```{r}
so_sens <- so_sens_PT2
# Check the metadata for NA values
table(is.na(so_sens$acr_u))
so_sens$missing <- ifelse(is.na(so_sens$acr_u),"Yes","No")
so_sens <- subset(so_sens, missing != "Yes")
# Subset the Seurat object to remove cells with NA in "celltype_rpca"
# so_sens_TAL3 <- subset(so_sens_TAL3, subset = !is.na(acr_u))

# Step 1: Extract the expression data matrix (e.g., normalized counts)
expression_matrix <- as.matrix(GetAssayData(so_sens[["RNA"]], layer = "data"))

# Step 2: Filter out genes with zero variance
gene_variance <- apply(expression_matrix, 1, var)
expression_matrix_filtered <- expression_matrix[gene_variance > 0, ]

# Step 3: Extract metadata and add 'wellKey' column
cell_metadata <- so_sens@meta.data
cell_metadata$wellKey <- rownames(cell_metadata)

# Step 7: Create a SingleCellAssay object with the filtered and subsetted expression matrix
sca <- FromMatrix(exprsArray = expression_matrix_filtered, cData = cell_metadata)


# #GLP1 diabetes only
# so_diab@meta.data$alt_scaled <- scale(so_diab@meta.data$alt) %>% 
#   as.numeric()
# # Step 1: Extract the expression data matrix (e.g., normalized counts)
# expression_matrix <- as.matrix(GetAssayData(so_diab[["RNA"]], layer = "data"))
# 
# # Step 2: Filter out genes with zero variance
# gene_variance <- apply(expression_matrix, 1, var)
# expression_matrix_filtered <- expression_matrix[gene_variance > 0, ]
# 
# # Step 3: Extract metadata and add 'wellKey' column
# cell_metadata <- so_diab@meta.data
# cell_metadata$wellKey <- rownames(cell_metadata)
# 
# # Step 7: Create a SingleCellAssay object with the filtered and subsetted expression matrix
# sca <- FromMatrix(exprsArray = expression_matrix_filtered, cData = cell_metadata)

```

###ii. Differential Expression Analyses
```{r}
# Assuming gene_set is a vector of gene names
sca_gene_set <- sca[rownames(sca) %in% sens_genes, ]

# Define the model with the exposure variable
#"ast","alt","fibrosis_stage","steatosis_grade")

# # Convert count variables to factors
# so_sens@meta.data$steatosis_grade <- factor(so_sens@meta.data$steatosis_grade)
# so_sens@meta.data$fibrosis_stage <- factor(so_sens@meta.data$fibrosis_stage)
# so_sens@meta.data$diagnosis_of_diabetes <- factor(so_sens@meta.data$diagnosis_of_diabetes,levels = c("No", "Yes"), labels = c(0, 1))
# so_sens@meta.data$diagnosis_of_MASLD <- factor(so_sens@meta.data$diagnosis_of_MASLD,levels = c("No", "Yes"), labels = c(0, 1))
# so_sens@meta.data$glp1agonist <- factor(so_sens@meta.data$glp1agonist, levels = c("No", "Yes"), labels = c(0, 1))
so_sens@meta.data$acr_u <- factor(so_sens@meta.data$acr_u)
so_sens@meta.data$group <- factor(so_sens@meta.data$group)
so_sens@meta.data$group <- relevel(so_sens@meta.data$group, ref = "Lean Control")
so_sens@meta.data$epic_sglti2_1 <- factor(so_sens@meta.data$epic_sglti2_1)
so_sens@meta.data$epic_sglti2_1 <- relevel(so_sens@meta.data$epic_sglti2_1, ref = "No")
so_sens@meta.data$epic_glp1ra_1 <- factor(so_sens@meta.data$epic_glp1ra_1)
so_sens@meta.data$epic_glp1ra_1 <- relevel(so_sens@meta.data$epic_glp1ra_1, ref = "No")
# so_sens@meta.data$group2 <- ifelse(so_sens@meta.data$group=="Type 2 Diabetes","T2","LC")

# so_diab@meta.data$steatosis_grade <- factor(so_diab@meta.data$steatosis_grade)
# so_diab@meta.data$fibrosis_stage <- factor(so_diab@meta.data$fibrosis_stage)
# so_diab@meta.data$diagnosis_of_diabetes <- factor(so_diab@meta.data$diagnosis_of_diabetes)
# so_diab@meta.data$diagnosis_of_MASLD <- factor(so_diab@meta.data$diagnosis_of_MASLD)
# so_diab@meta.data$glp1agonist <- factor(so_diab@meta.data$glp1agonist, levels = c("No", "Yes"), labels = c(0, 1))
# so_diab@meta.data$nih_sex <- factor(so_diab@meta.data$nih_sex)
# # so_diab@meta.data$tg <- factor(so_diab@meta.data$tg)
# so_diab@meta.data$alt_scaled <- (so_diab@meta.data$alt-mean(so_diab@meta.data$alt,na.rm=T))/sd(so_diab@meta.data$alt,na.rm=T)
# so_diab@meta.data$alt_scaled <- scale(so_diab@meta.data$alt) %>% 
#   as.numeric()

#Filter to diabetes only
model_formula <- ~ epic_sglti2_1
#Diabetes status, GLP1 status, age, sex, sbp, HbA1c
# Run the linear model with zlm
zlm_results <- zlm(formula = model_formula, sca = sca_gene_set)
# summary_zlm <- summary(zlm_results)
# Summarize results and perform likelihood ratio test (LRT) for outcome
summary_zlm <- summary(zlm_results, doLRT = "epic_sglti2_1Yes")
# summary_zlm <- summary(zlm_results)
# Convert the summary to a data table for easy manipulation
summary_dt <- summary_zlm$datatable

```

#All Cells, by cell type
```{r}

cell_types <- as.vector(unique(so_sens@meta.data$celltype))

for (cell in cell_types) {
  cell="Hep-2"
  #Create subset so
  Idents(so_sens) <- so_sens$celltype
  # gc()
  so_subset <- subset(so_sens, diagnosis_of_diabetes=="Yes")
  so_sens$celltype==cell
  DefaultAssay(object = so_liver_sn_hep) <- "RNA"
  
  
  #Filter to diabetes only
  model_formula <- ~ diagnosis_of_diabetes + alt
  #Diabetes status, GLP1 status, age, sex, sbp, HbA1c
  # Run the linear model with zlm
  zlm_results <- zlm(formula = model_formula, sca = sca_gene_set)
  # summary_zlm <- summary(zlm_results)
  # Summarize results and perform likelihood ratio test (LRT) for outcome
  summary_zlm <- summary(zlm_results, doLRT = "diagnosis_of_diabetesYes")
  # summary_zlm <- summary(zlm_results)
  # Convert the summary to a data table for easy manipulation
  summary_dt <- summary_zlm$datatable
  
  #Overall with Hurdle and logFC
  fcHurdle <- merge(summary_dt[contrast=='diagnosis_of_diabetesYes' & component=='H',.(primerid, `Pr(>Chisq)`)], #hurdle P values
                    summary_dt[contrast=='diagnosis_of_diabetesYes' & component=='logFC', .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients
  fcHurdle[,fdr:=p.adjust(`Pr(>Chisq)`, 'fdr')]
  # write.csv(fcHurdle,fs::path(dir.results,"Senesence Results","ALT_Senescence_OverallResults.csv"))
  m <- fcHurdle[,c("primerid","coef","fdr")]
  
}
# # m$Condition <- "A1c"
# m$Condition <- "GLP-1 Adj. ALT"
# # results <- m
# # results_full <- rbind(results,m)
# results_full <- rbind(results_full,m)
# results <- m
# 
# #Continous 
# fcHurdle <- merge(summary_dt[contrast=='glp1agonistYes' & component=='C',.(primerid, `Pr(>Chisq)`)], #hurdle P values
#                   summary_dt[contrast=='glp1agonistYes' & component=='C', .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients
# fcHurdle[,fdr:=p.adjust(`Pr(>Chisq)`, 'fdr')]
# # fcHurdle <- fcHurdle %>%
# #   mutate(coef=10*coef)
# # write.csv(fcHurdle,fs::path(dir.results,"Senesence Results","GLP1_Senescence.csv"))
# m <- fcHurdle[,c("primerid","coef","fdr")]

# Filter top 10 positive and negative log2FoldChange
top_pos <- as.data.frame(m) %>%
  filter(fdr<0.05) %>%
  # arrange(desc(coef)) %>%
  filter(coef>0) %>% 
  # dplyr::slice(1:20) %>%
  dplyr::rename(Gene=primerid)
# top_pos$Gene <- rownames(top_pos)
top_pos <- top_pos[c("Gene","coef","fdr")]
rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"
# top_pos <- as.data.frame(m) %>%
#   filter(fdr<0.05) %>%
#   filter(coef>0) %>% 
#   dplyr::rename(Gene=primerid)
# top_pos$Gene <- rownames(top_pos)
# top_pos <- top_pos[c("Gene","coef","fdr")]
# rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"

# top_neg <- m %>% 
#   filter(fdr<0.05) %>%
#   arrange(coef) %>% 
#   # dplyr::slice(1:20) %>% 
#   dplyr::rename(Gene=primerid)
# # top_neg$Gene <- rownames(top_neg)
# # top_neg <- top_neg[c("Gene","coef","fdr")]
# # rownames(top_neg) <- NULL
# top_neg$Direction <- "Negative"
top_neg <- as.data.frame(m) %>%
  filter(fdr<0.05) %>%
  filter(coef<0) %>% 
  dplyr::rename(Gene=primerid)
# top_pos$Gene <- rownames(top_pos)
# top_pos <- top_pos[c("Gene","coef","fdr")]
# rownames(top_pos) <- NULL
top_neg$Direction <- "Negative"

# Combine and prepare for plotting
top_genes <- bind_rows(top_pos, top_neg) 

# Set sorting order: all negative genes first, then all positive genes
top_genes <- top_genes %>%
  mutate(Gene = factor(Gene, levels = Gene[order(Direction, coef)]))  # Order by Direction and log2FC
# 
# # Bar chart with flipped x and y axes
# b <- ggplot(top_genes, aes(x = coef, y = Gene, fill = Direction)) +
#   geom_bar(stat = "identity") +
#   labs(x = "Coefficient", y = "Gene", title = "Association of AST and Gene Expression Among youth with T2D, assuming genes are expressed") +
#   scale_fill_manual(values = c("blue", "red"), labels = c("Lower Expression", "Higher Expression")) +
#   theme_minimal()
# 
# # Bar chart with flipped x and y axes
b <- ggplot(top_genes, aes(x = coef, y = Gene, fill = Direction)) +
  geom_bar(stat = "identity") +
  labs(x = "logFC", y = "Gene", title = "Overall Association of A1c and Gene Expression, Among youth with T2D") +
  scale_fill_manual(values = c("blue", "red"), labels = c("Lower Expression", "Higher Expression")) +
  theme_minimal()+
  theme(element_text(family="Times"))+
  theme(legend.position="none")


# results <- top_genes %>%
#   dplyr::select(c(Gene,Direction)) %>%
#   dplyr::rename(Direction_GLP1_Unadjusted=Direction)
#   
results2 <- top_genes %>%
  dplyr::select(c(Gene,Direction)) %>%
  dplyr::rename(Direction_GLP1_A1c=Direction)

# results3 <- top_genes %>%
#   dplyr::select(c(Gene,Direction)) %>%
#   dplyr::rename(Direction_A1c=Direction)
# results4 <- top_genes %>%
#   dplyr::select(c(Gene,Direction)) %>%
#   dplyr::rename(Direction_GLP1_A1c=Direction)

results_full <- tidylog::full_join(results2,results3,by="Gene")
# results_full <- tidylog::full_join(results_full,results3,by="Gene")
# results_full <- tidylog::full_join(results_full,results4,by="Gene")
results_full <-results_full %>% 
  # mutate(adjustment_change=case_when(Direction_GLP1_Unadjusted=="Positive" & Direction_GLP1=="Negative" ~ "Change",
  #                                    Direction_GLP1_Unadjusted=="Negative" & Direction_GLP1=="Positive" ~ "Change",
  #                                    Direction_GLP1_Unadjusted=="Positive" & Direction_GLP1=="Positive" ~ "Same",
  #                                    Direction_GLP1_Unadjusted=="Negative" & Direction_GLP1=="Negative" ~ "Same")) %>% 
  mutate(reverse=case_when(Direction_GLP1_A1c=="Positive" & Direction_A1c=="Negative" ~ "Reversed_Down",
                           Direction_GLP1_A1c=="Negative" & Direction_A1c=="Positive" ~ "Reversed_Up",
                           Direction_GLP1_A1c=="Positive" & Direction_A1c=="Positive" ~ "Maintained",
                           Direction_GLP1_A1c=="Negative" & Direction_A1c=="Negative" ~ "Maintained"))

results_full$Gene[which(results_full$reverse=="Reversed_Down")]
results_full$Gene[which(results_full$reverse=="Reversed_Up")]

data_long <- results_full %>%
  pivot_longer(
    cols = c(Direction_ALT, Direction_GLP1),
    names_to = "Condition",
    values_to = "Direction"
  )


```

#Heptatocytes
```{r}
#Overall with Hurdle and logFC
fcHurdle <- merge(summary_dt[contrast=='epic_sglti2_1Yes' & component=='H',.(primerid, `Pr(>Chisq)`)], #hurdle P values
                  summary_dt[contrast=='epic_sglti2_1Yes' & component=='logFC', .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients
fcHurdle[,fdr:=p.adjust(`Pr(>Chisq)`, 'fdr')]
# write.csv(fcHurdle,fs::path(dir.results,"Senesence Results","ALT_Senescence_OverallResults.csv"))
m <- fcHurdle[,c("primerid","coef","fdr")]

# Filter top 10 positive and negative log2FoldChange
top_pos <- as.data.frame(m) %>%
  filter(fdr<0.05) %>%
  # arrange(desc(coef)) %>%
  filter(coef>0) %>%
  # dplyr::slice(1:10) %>%
  dplyr::rename(Gene=primerid,
                LogFC=coef)
# top_pos$Gene <- rownames(top_pos)
# top_pos <- top_pos[c("Gene","coef","fdr")]
# rownames(top_pos) <- NULL
top_pos$Direction <- "Positive"

top_neg <- as.data.frame(m) %>%
  filter(fdr<0.05) %>%
  filter(coef<0) %>% 
  # arrange(coef) %>%
  # dplyr::slice(1:10)%>%
  dplyr::rename(Gene=primerid,
                LogFC=coef)
top_neg$Direction <- "Negative"

# Combine and prepare for plotting
top_genes <- bind_rows(top_pos, top_neg)
# write.csv(top_genes,fs::path(dir.dat,"Liver Project","Top_Senescence_Genes_ACR_u_TALcells.csv"))

# Set sorting order: all negative genes first, then all positive genes
top_genes <- top_genes %>%
  mutate(Gene = factor(Gene, levels = Gene[order(Direction, LogFC)]))  # Order by Direction and log2FC

# # Bar chart with flipped x and y axes
ggplot(top_genes, aes(x = LogFC, y = Gene, fill = Direction)) +
  geom_bar(stat = "identity") +
  # geom_bar(stat = "identity",color = "black", size = 1)+
  labs(x = "logFC", y = "Gene") +
  # scale_fill_manual(values = c("orange", "#E65164FF"), labels = c("Lower Expression", "Higher Expression")) +
  scale_fill_manual(values = c("blue", "red"), labels = c("Lower Expression", "Higher Expression")) +
  theme_minimal()+
  theme(element_text(family="Times"))+
  theme(legend.position="none")

top_genes_alb <- top_genes
top_genes_diab <- top_genes 
top_genes_sglt2 <- top_genes
top_genes_glp1 <- top_genes
top_genes <- tidylog::left_join(top_genes_alb,top_genes_sglt2,by="Gene")
# write.csv(top_genes_glp_1,fs::path(dir.dat,"Liver Project","Kidney_GLP_1s_Genes_T2D_only.csv"))
top_genes <- top_genes %>% 
  mutate(Change=ifelse(Direction.x=="Negative" & Direction.y=="Positive","Upregulated",
                       ifelse(Direction.x=="Positive" & Direction.y=="Negative","Downregulated",
                              "Unchanged")))
up <- top_genes %>% 
  filter(Change=="Upregulated") %>% 
  dplyr::select(Gene)

down <- top_genes %>% 
  filter(Change=="Downregulated") %>% 
  dplyr::select(Gene)

library(VennDiagram)
library(tidyverse)

# Read the CSV files
acr_data <- read.csv(fs::path(dir.dat,"Liver Project","Top_Senescence_Genes_ACR_u_TALcells.csv"))
glp1_data <- read.csv(fs::path(dir.dat,"Liver Project","Top_Senescence_Genes_GLP1_TALcells.csv"))
sglt2_data <- read.csv(fs::path(dir.dat,"Liver Project","Top_Senescence_Genes_SGLT2_TALcells.csv"))
type2_data <- read.csv(fs::path(dir.dat,"Liver Project","Top_Senescence_Genes_Type2_TALcells.csv"))

# Function to extract genes by direction
extract_genes <- function(data, direction) {
  data %>%
    filter(Direction == direction) %>%
    pull(Gene)
}

# Extract positive and negative genes for each dataset
acr_pos <- extract_genes(acr_data, "Positive")
acr_neg <- extract_genes(acr_data, "Negative")

glp1_pos <- extract_genes(glp1_data, "Positive")
glp1_neg <- extract_genes(glp1_data, "Negative")

sglt2_pos <- extract_genes(sglt2_data, "Positive")
sglt2_neg <- extract_genes(sglt2_data, "Negative")

type2_pos <- extract_genes(type2_data, "Positive")
type2_neg <- extract_genes(type2_data, "Negative")

# Venn diagram for positive genes
pdf(fs::path(dir.dat,"Liver Project","positive_genes_venn.pdf"), width=10, height=10)
venn.diagram(
  x = list(
    "ACR" = acr_pos,
    "GLP1" = glp1_pos,
    "SGLT2" = sglt2_pos,
    "Type2" = type2_pos
  ),
  category.names = c("ACR", "GLP1", "SGLT2", "Type2"),
  filename = NULL,
  output = TRUE,
  
  # Circles
  lwd = 2,
  lty = 'blank',
  fill = c("#440154", "#21908C", "#FDE725", "#F0F921"),
  
  # Numbers
  cex = .6,
  fontface = "bold",
  fontfamily = "sans",
  
  # Titles
  main = "Overlap of Positive Genes Across Datasets",
  main.cex = 1.5,
  main.fontfamily = "sans"
)
dev.off()

# Venn diagram for negative genes
pdf(fs::path(dir.dat,"Liver Project","negative_genes_venn.pdf"), width=10, height=10)
venn.diagram(
  x = list(
    "ACR" = acr_neg,
    "GLP1" = glp1_neg,
    "SGLT2" = sglt2_neg,
    "Type2" = type2_neg
  ),
  category.names = c("ACR", "GLP1", "SGLT2", "Type2"),
  filename = NULL,
  output = TRUE,
  
  # Circles
  lwd = 2,
  lty = 'blank',
  fill = c("#440154", "#21908C", "#FDE725", "#F0F921"),
  
  # Numbers
  cex = .6,
  fontface = "bold",
  fontfamily = "sans",
  
  # Titles
  main = "Overlap of Negative Genes Across Datasets",
  main.cex = 1.5,
  main.fontfamily = "sans"
)
dev.off()


# Detailed overlap analysis
print_overlap <- function(gene_lists, type) {
  cat(paste("Overlap Analysis for", type, "Genes:\n"))
  
  # Find intersections
  all_intersections <- Reduce(intersect, gene_lists)
  cat("Genes present in ALL datasets:", all_intersections, "\n\n")
  
  # Pairwise intersections
  dataset_names <- c("ACR", "GLP1", "SGLT2", "Type2")
  for (i in 1:(length(gene_lists)-1)) {
    for (j in (i+1):length(gene_lists)) {
      intersect_genes <- intersect(gene_lists[[i]], gene_lists[[j]])
      cat(paste(dataset_names[i], "and", dataset_names[j], "overlap:"), 
          intersect_genes, "\n")
    }
  }
  cat("\n")
}

# Print overlaps for positive and negative genes
print_overlap(list(acr_pos, glp1_pos, sglt2_pos, type2_pos), "Positive")
print_overlap(list(acr_neg, glp1_neg, sglt2_neg, type2_neg), "Negative")
```

##c. Tutorial 
```{r}
data(maits, package='MAST')
dim(maits$expressionmat)
head(maits$cdat)
head(maits$fdat)

scaRaw <- FromMatrix(t(maits$expressionmat), maits$cdat, maits$fdat)
aheatmap(assay(scaRaw[1:1000,]), labRow='', annCol=as.data.frame(colData(scaRaw)[,c('condition', 'ourfilter')]), distfun='spearman')

set.seed(123)
plotPCA <- function(sca_obj){
  projection <- rpca(t(assay(sca_obj)), retx=TRUE, k=4)$x
  colnames(projection)=c("PC1","PC2","PC3","PC4")
  pca <- data.table(projection,  as.data.frame(colData(sca_obj)))
  print(ggpairs(pca, columns=c('PC1', 'PC2', 'PC3', 'libSize', 'PercentToHuman', 'nGeneOn', 'exonRate'),
                mapping=aes(color=condition), upper=list(continuous='blank')))
  invisible(pca)
}

plotPCA(scaRaw)
```

#9. Visualize Results of MAST
##a. Full Gene Set
##b. Senesence Gene Set
```{r}
# Filter data for component C and D separately
summary_dt_H <- summary_dt %>%
  filter(component == "H") %>%
  mutate(log_pvalue = -log10(`Pr(>Chisq)`))  # Add -log10(p-value)

# Filter data for component C and D separately
summary_dt_C <- summary_dt %>%
  filter(component == "C") %>%
  mutate(log_pvalue = -log10(`Pr(>Chisq)`))  # Add -log10(p-value)

summary_dt_D <- summary_dt %>%
  filter(component == "D") %>%
  mutate(log_pvalue = -log10(`Pr(>Chisq)`))  # Add -log10(p-value)

# For component C: Top 10 significant and largest coefficient genes
# Filter for p-value < 0.05
summary_dt_C_significant <- summary_dt_C %>%
  filter(`Pr(>Chisq)` < 0.05)

# Top 10 significant positive and negative coefficients for component C
top_significant_positive_C <- summary_dt_C_significant %>%
  arrange(desc(coef)) %>%  # Largest positive coefficients
  slice_head(n = 10)

top_significant_negative_C <- summary_dt_C_significant %>%
  arrange(coef) %>%  # Largest negative coefficients
  slice_head(n = 10)

# Combine the top 10 significant positive and negative coefficients for component C
top_genes_C <- bind_rows(top_significant_positive_C, top_significant_negative_C)

# Create the volcano plot for component C with adjusted colors
bubble_plot_C <- ggplot(summary_dt_C, aes(x = coef, y = log_pvalue)) +
  geom_point(aes(color = `Pr(>Chisq)`), alpha = 0.6) +  # Bubbles colored by p-value
  geom_text(data = top_genes_C, aes(label = primerid), size = 3, vjust = 1, hjust = 1) +  # Label top genes
  scale_color_gradient(low = "blue", high = "red") +  # Color scale for p-value
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +  # Vertical line at coefficient = 0
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +  # Horizontal line at p-value = 0.05
  theme_minimal() +  # Clean theme
  labs(
    title = "Adjusted AST Volcano Plot for Component C: Coefficients vs -log10(P-value)",
    x = "Coefficient (Coef)",
    y = "-log10(P-value)",
    color = "P-value"
  ) +
  theme(
    legend.position = "right",  # Position the legend on the right
    strip.text = element_text(size = 12),  # Adjust facet label size
    axis.text = element_text(size = 10),  # Adjust axis label size
    axis.title = element_text(size = 12)  # Adjust axis title size
  )



# Repeat the same for component D

# For component D: Top 10 significant and largest coefficient genes
# Filter for p-value < 0.05
summary_dt_D_significant <- summary_dt_D %>%
  filter(`Pr(>Chisq)` < 0.05)

# Top 10 significant positive and negative coefficients for component D
top_significant_positive_D <- summary_dt_D_significant %>%
  arrange(desc(coef)) %>%  # Largest positive coefficients
  slice_head(n = 10)

top_significant_negative_D <- summary_dt_D_significant %>%
  arrange(coef) %>%  # Largest negative coefficients
  slice_head(n = 10)

# Combine the top 10 significant positive and negative coefficients for component D
top_genes_D <- bind_rows(top_significant_positive_D, top_significant_negative_D)

# Create the volcano plot for component D with adjusted colors
bubble_plot_D <- ggplot(summary_dt_D, aes(x = coef, y = log_pvalue)) +
  geom_point(aes(color = `Pr(>Chisq)`), alpha = 0.6) +  # Bubbles colored by p-value
  geom_text(data = top_genes_D, aes(label = primerid), size = 3, vjust = 1, hjust = 1) +  # Label top genes
  scale_color_gradient(low = "blue", high = "red") +  # Color scale for p-value
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +  # Vertical line at coefficient = 0
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +  # Horizontal line at p-value = 0.05
  theme_minimal() +  # Clean theme
  labs(
    title = "Adjusted AST Volcano Plot for Component D: Coefficients vs -log10(P-value)",
    x = "Coefficient (Coef)",
    y = "-log10(P-value)",
    color = "P-value"
  ) +
  theme(
    legend.position = "right",  # Position the legend on the right
    strip.text = element_text(size = 12),  # Adjust facet label size
    axis.text = element_text(size = 10),  # Adjust axis label size
    axis.title = element_text(size = 12)  # Adjust axis title size
  )



```

#10. IDEAS DEGs 
##a. Liver 
###i. Full Gene Set
```{r, Full Gene Set}

#Remove bottom 10% genes (lowly expresed)
exposure <- "diagnosis_of_diabetes"
var_type <- "binary"
# so <- so_liver_sn
rm(so_liver_sn)
id <- "Kit_Lot"
method <- "zinb"

ideas_fxn <- function(so, exposure, covariates, var_type, id, method) {
  
  # Create individual variable dynamically based on the input 'id'
  so$individual <- so[[id]]  # Assign the column specified by 'id' as the individual variable
  
  # Split genes into batches
  batch_size <- 1000  # Number of genes per batch
  count_matrix <- GetAssayData(so, assay = "RNA", slot = "counts")
  gene_batches <- split(rownames(count_matrix), ceiling(seq_along(rownames(count_matrix)) / batch_size))
  
  # Loop through each gene batch
  all_results <- list()  # To store results from all batches
  
  for (i in seq_along(gene_batches)) {
    cat("Processing batch", i, "of", length(gene_batches), "\n")
    
    # Get the list of genes for the current batch
    batch_genes <- gene_batches[[i]]
    
    # Extract the count matrix for this batch of genes
    batch_matrix <- count_matrix[batch_genes, , drop = FALSE]  # Drop = FALSE ensures it stays a matrix
    batch_matrix <- as.matrix(batch_matrix)
    # Round the count matrix to ensure integer values
    batch_matrix <- round(batch_matrix)  # Round values to ensure integer counts
    
    # Check if the matrix contains non-integer values
    if (any(batch_matrix != floor(batch_matrix))) {
      stop("Batch matrix contains non-integer values!")
    }
    
    # Extract the metadata for the cells corresponding to the batch
    meta_cell <- so@meta.data
    meta_cell$cell_id <- rownames(meta_cell)  # Add cell IDs if not already present
    
    # Ensure the metadata includes the required column (e.g., 'Kit_Lot' for individuals)
    meta_cell$cell_rd <- colSums(batch_matrix)  # Total counts per cell (read depth)
    
    # Add a small constant to ensure no zero or negative values
    meta_cell$cell_rd <- meta_cell$cell_rd + 1  # Adding 1 to avoid log(0) errors
    
    #    # Ensure the metadata includes the required column (e.g., 'Kit_Lot' for individuals)
    # meta_cell$cell_rd[meta_cell$cell_rd == 0] <- 1  # Ensure no zero read depth
    
    # Create individual-level metadata (e.g., group information, exposure)
    meta_ind <- unique(meta_cell[, c("individual", exposure)])  # Use dynamic 'id' for individual variable
    
    # Set variables for differential expression analysis
    var2test <- exposure  # Group variable to test
    var2adjust <- NULL     # Adjusting variable (e.g., RIN, if applicable)
    var2test_type <- var_type  # "binary" or "continuous"
    var_per_cell <- "cell_rd"  # Cell-level adjustment variable (read depth)
    test_method <- paste0(method)
    
    # Perform IDEAS distance calculation for this batch
    dist_batch <- ideas_dist(
      count_input = batch_matrix,
      meta_cell = meta_cell,
      meta_ind = meta_ind,
      var_per_cell = var_per_cell,
      var2test = var2test,
      var2test_type = var2test_type,
      d_metric = "Was",  # Wasserstein distance
      fit_method = test_method  # Negative binomial fit
    )
    
    # Perform PERMANOVA for this batch
    pval_batch <- permanova(
      dist_array = dist_batch,
      meta_ind = meta_ind,
      var2test = var2test,
      var2adjust = NULL,
      var2test_type = var2test_type,
      n_perm = 999,
      r.seed = 903
    )
    
    # Combine results for this batch
    batch_results <- data.frame(
      gene = batch_genes,
      pvalue = pval_batch
    )
    
    # Store results
    all_results[[i]] <- batch_results
  }
  
  # Combine all batches into one final result
  final_results <- do.call(rbind, all_results)
  
  # Save or further analyze the results
  write.csv(final_results, "DEA_results_ideas.csv", row.names = FALSE)
}



```
##b. Kidney
```{r}
exposure="group3"
exp_group <- "exclusive_glp1"
ref_group <- "neither"
var_type <- "binary"
so <- so_diab
# rm(so_kidney_sc)
id <- "kit_id"
method <- "zinb"
# unique(so$kit_id[which(is.na(so$group))])
# so_diab <- subset(so,group=="Type 2 Diabetes")
# so <- so_diab
# rm(so_diab)

ideas_fxn <- function(so, exp_group, ref_group, covariates, var_type, id, method, exposure) {
  
  #Filter so to groups of interest
  so$filt_condition <- ifelse(so$group2==paste0(exp_group) | so$group2==paste0(ref_group),"Yes","No")
  so <- subset(so,filt_condition=="Yes")
  so$group3 <- ifelse(so$group2==paste0(exp_group),paste0(exp_group),paste0(ref_group))
  so$group3 <- factor(so$group3)
  
  # Create individual variable dynamically based on the input 'id'
  so$individual <- so[[id]]  # Assign the column specified by 'id' as the individual variable
  
  # Split genes into batches
  batch_size <- 100  # Number of genes per batch
  count_matrix <- GetAssayData(so, assay = "RNA", layer = "counts")
  gene_batches <- split(rownames(count_matrix), ceiling(seq_along(rownames(count_matrix)) / batch_size))
  
  # Loop through each gene batch
  all_results <- list()  # To store results from all batches
  
  for (i in seq_along(gene_batches)) 
    {
    cat("Processing batch", i, "of", length(gene_batches), "\n")
    
    # Get the list of genes for the current batch
    batch_genes <- gene_batches[[i]]
    
    # Extract the count matrix for this batch of genes
    batch_matrix <- count_matrix[batch_genes,]  # Drop = FALSE ensures it stays a matrix
    batch_matrix <- as.matrix(batch_matrix)
    # Round the count matrix to ensure integer values
    batch_matrix <- round(batch_matrix)  # Round values to ensure integer counts
    
    # Check if the matrix contains non-integer values
    if (any(batch_matrix != floor(batch_matrix))) {
      stop("Batch matrix contains non-integer values!")
    }
    
    # Extract the metadata for the cells corresponding to the batch
    # Subset meta_cell based on the cells in batch_matrix
    cell_ids <- colnames(batch_matrix)  # Extract cell IDs from the batch matrix
    meta_cell <- so@meta.data[cell_ids, ]  # Subset metadata to match the batch cells
    meta_cell$cell_id <- rownames(meta_cell)  # Add cell IDs if not already present
    
    # Ensure the metadata includes the required column (e.g., 'Kit_Lot' for individuals)
    meta_cell$cell_rd <- colSums(batch_matrix)  # Total counts per cell (read depth)
    
    # Add a small constant to ensure no zero or negative values
    meta_cell$cell_rd <- meta_cell$cell_rd + 1  # Adding 1 to avoid log(0) errors
    
    # Create individual-level metadata (e.g., group information, exposure)
    meta_ind <- unique(meta_cell[, c("individual", "group3")]) 
    
    # Set variables for differential expression analysis
    var2test <- "group3"  # Group variable to test
    var2adjust <- NULL     # Adjusting variable (e.g., RIN, if applicable)
    var2test_type <- var_type  # "binary" or "continuous"
    var_per_cell <- "cell_rd"  # Cell-level adjustment variable (read depth)
    test_method <- paste0(method)
    
    # Perform IDEAS distance calculation for this batch
    dist_batch <- ideas_dist(
      count_input = batch_matrix,
      meta_cell = meta_cell,
      meta_ind = meta_ind,
      var_per_cell = var_per_cell,
      var2test = var2test,
      var2test_type = var2test_type,
      d_metric = "Was",  # Wasserstein distance
      fit_method = test_method  # Negative binomial fit
    )
    
    # Perform PERMANOVA for this batch
    pval_batch <- permanova(
      dist_array = dist_batch,
      meta_ind = meta_ind,
      var2test = var2test,
      var2adjust = NULL,
      var2test_type = var2test_type,
      n_perm = 999,
      r.seed = 903
    )
    
    # Combine results for this batch
    batch_results <- data.frame(
      gene = batch_genes,
      pvalue = pval_batch
    )
    
    # Store results
    all_results[[i]] <- batch_results
  }
  
  # Combine all batches into one final result
  final_results <- do.call(rbind, all_results)
  
  # Save or further analyze the results
  write.csv(final_results, "DEA_results_ideas.csv", row.names = FALSE)
}

```



