---
title: "DECODE_Kidney_NEBULA"
author: "Hailey Hampson"
date: "2025-05-12"
output: html_document
---

# 1. Analysis Plan
```{r}

#1. Comparative Analysis: Determine differential gene expression between Type 2 Diabetes (No Med) vs. Healthy Controls (No Med)

#2. Comparative Analysis: Determine differential gene expression in T2D only, between:
#a. SGLT2i Yes vs. No
#b. GLP-1 Yes vs. No
#c. SGLT2 + GLP-1 vs. GLP-1
#d. SGLT2 + GLP-1 vs. SGLT2
#e. SGLT2 + GLP-1 vs. No Med
#f. Any Med vs. No Med

```

# 2. Set Up
## a. Libraries & Directores
```{r, include=F}
library(reprex)
# library(tidyverse)
library(purrr)
library(BiocManager)        
library(arsenal)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(Seurat)
library(future)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(venn)
library(rstatix)
library(table1)
# BiocManager::install("Biobase")
library(Biobase)
# BiocManager::install("ReactomeGSA")
library(ReactomeGSA)
# BiocManager::install("GSEABase")
library(GSEABase)
# install.packages('msigdbdf', repos = 'https://igordot.r-universe.dev')
library(msigdbr)
# library(kableExtra)
library(knitr)
# BiocManager::install("SingleCellExperiment")
library(SingleCellExperiment)
# BiocManager::install("fgsea")
library(fgsea)
# BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)
library(openxlsx)
library(BiocManager)
# library(MAST)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(openxlsx)
library(ggplot2)
library(GGally)
# library(limma)
library(reshape2)
library(data.table)
library(janitor)
# BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
# library(NMF)
library(rsvd)
library(RColorBrewer)
# BiocManager::install("devtools")
# library(devtools)
# install_github("Sun-lab/ideas",force=T)
# library(ideas)
library(foreach)
library(doRNG)
library(doParallel)
library(fs)
library(future)
# registerDoParallel(cores = 6)
# library(VennDiagram)
#install.packages("survival")
library(survival)
#install.packages("lme4")  # If not already installed
library(lme4)
#install.packages("lmerTest")
library(lmerTest)
# install.packages("emmeans")
library(emmeans)
# install.packages("glmmTMB")
library(glmmTMB)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(purrr)
#install.packages("glmmTMB")
# Reinstall glmmTMB from source
#install.packages("glmmTMB", type = "source")
# library(glmmTMB)
# Install DoubletFinder (if not already installed)
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# Load the package
# Install DoubletFinder from GitHub (use devtools to install)
# if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# library(DoubletFinder)
# install.packages("emmeans")
library(emmeans)
library(ggrepel)
# library(qpcR)
# BiocManager::install("enrichplot")
# library(enrichplot)
library(enrichR)
dbs <- c("GO_Biological_Process_2023",
         "KEGG_2021_Human",
         "Reactome_2022",
         "Reactome_Pathways_2024")
# BiocManager::install("scran")a
library(scran)

##c. Load functions ----
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Kidney scRNA/Kidney scRNA/Kidney_functions_sc.R")
#Set number of cores for parallellization
#maxCores <- detectCores()
#numCores <- maxCores-1
#cl <- makeCluster(numCores)  # Create a cluster with the desired number of cores
#registerDoParallel(cl) 

#Local file path
#dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
#dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
#dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
#dir.results <- c("/Volumes/Peds Endo/Petter Bjornstad/Kidney Project/Results")

# #Lambda file path
# dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
# dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Kidney scRNA/Kidney scRNA")
# dir.results <- c(fs::path(dir.dat,"Kidney Project/Results"))

#Lambda work station file path
# dir.results <- "/home/hailey/Documents/ROCKIES Results"

# # #Mac Studio File Path
# dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
# dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/DECODE/DECODE Analysis/Results")
# # dir.ipa <- c("/Users/hhampson/Documents/IPA/Results")

#Mac laptop file path
dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive")
dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/DECODE/DECODE Analysis/Results")

#Load functions
# source("Kidney_functions_sc.R")
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")
# dir.results <- c("/home/hailey/Documents/Results")

# # write file
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# write.csv(df, temp_file, row.names = FALSE) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, bucket, 'Kidney transcriptomics/ROCKIES Results/filename.csv')

```

## b. Cyberduck 
### i. Lambda
```{r, Cyberduck setup}
# knitr::opts_knit$set(root.dir = dir.results)
# install.packages("reticulate")
# Sys.setenv(RETICULATE_PYTHON = "/home/hailey/miniconda3/envs/py310_env/bin/python")
library(reticulate)
reticulate::py_config()
# library(reticulate)
# reticulate::use_condaenv("py310_env", required = TRUE)
# reticulate::py_config()
# Sys.setenv(LD_LIBRARY_PATH = "/usr/lib/x86_64-linux-gnu")
# reticulate::use_python("/home/hailey/miniconda3/bin/python")
# reticulate::use_condaenv("base", required = TRUE)

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/home/hailey/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```
### ii. Hyak
```{r, Cyberduck setup}
# knitr::opts_knit$set(root.dir = dir.results)
# install.packages("reticulate")
# Sys.setenv(RETICULATE_PYTHON = "/home/hailey/miniconda3/envs/py310_env/bin/python")
library(reticulate)
reticulate::py_config()
# library(reticulate)
# reticulate::use_condaenv("py310_env", required = TRUE)
# reticulate::py_config()
# Sys.setenv(LD_LIBRARY_PATH = "/usr/lib/x86_64-linux-gnu")
# reticulate::use_python("/home/hailey/miniconda3/bin/python")
# reticulate::use_condaenv("base", required = TRUE)

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/mmfs1/home/hhampson/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```
## c. Load Kidney scRNA seq Data
### i. Lambda load
```{r, include=F}
#Load PB90 with new KPMP Cell Types
gc()
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "Kidney transcriptomics/Single cell RNA seq/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds", temp_file)
so_kpmp_sc <- readRDS(temp_file)

# #Load Formatted PB90 dataset
# gc()
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
# s3$download_file(bucket, "Kidney transcriptomics/Single cell RNA seq/Formatted_KPMP_Decode.rds", temp_file)
# so_kpmp_sc <- readRDS(temp_file)
```

### ii. Local Load 
```{r}
# #Mac Studio pathway
# so_kpmp_sc <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/scRNA/data_raw/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds")

#Mac Laptop 
ids <- c("KL-0029521","KL-0014632","KL-0014625","KL-0014642","KL-0014634","KL-0014643","KL-0014639","KL-0014630","KL-0014628","KL-0014629","KL-0014624","KL-0014636","KL-0024002","KL-0014637", "KL-0019098","KL-0014631","KL-0019097","KL-0014638","KL-0019099","KL-0019100","KL-0019062","KL-0019103","KL-0019102","KL-0022163","KL-0022172","KL-0019095","KL-0022157","KL-0022158","KL-0022162","KL-0022167","KL-0022168","KL-0024007","KL-0024010","KL-0024000","KL-0023998","KL-0027475","KL-0030622","KL-0029525","KL-0029524","KL-0030619","KL-0030597","KL-0030606","KL-0031458","KL-0030607","KL-0031465","KL-0030913","KL-0031453","KL-0029407","KL-0030908","KL-0031460","KL-0029408","KL-0032459")

so_kpmp_sc <- readRDS(fs::path(dir.dat,"scRNA/data_raw/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds"))
# so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)

# id2 <- unique(so_kpmp_sc$record_id[which(so_kpmp_sc$kit_id %in% ids)])
so_kpmp_sc1 <- subset(so_kpmp_sc,kit_id %in% ids[1:20])
so_kpmp_sc2 <-  subset(so_kpmp_sc,kit_id %in% ids[21:40])
so_kpmp_sc3 <-  subset(so_kpmp_sc,kit_id %in% ids[41:52])

so_kpmp_sc_combined <- merge(so_kpmp_sc1, y = so_kpmp_sc2)

```

## d. Load Gene Sets
```{r}
tca1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/tca_cycle_genes.csv")$genesymbol
tca2 <- c(
  "ACO1", "ACO2", "IDH1", "IDH2", "IDH3A", "IDH3B", "IDH3G", "OGDH", "OGDHL",
  "SUCLA2", "SUCLG1", "SUCLG2", "SDHA", "SDHB", "SDHC", "SDHD", "FH", "MDH1",
  "MDH2", "FAS", "CS"
) #21 genes

tca <- unique(c(tca1,tca2))

ox_phos1 <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/RH_ROCKIES/Gene Sets/ox_phos_genes.csv")$genesymbol
ox_phos2 <- c(
  "NDUFS6",  "SDHB", "SDHC", "SDHD",
  "UQCRC1", "UQCRC2", "COX4I1", "COX4I2", "ATP5PF") #47 genes
ox_phos <- unique(c(ox_phos1,ox_phos2))

# #Check gene names
# genes <- unique(c(tca,ox_phos)) #82 genes
# 
# rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% genes)] #37 genes in data

# #Check if other genes are named differentily 
# missing <- genes[!genes %in% rownames(so_kpmp_sc)] #45 missing genes
# rownames(so_kpmp_sc)[which(grepl("ATP5PF",rownames(so_kpmp_sc)))]
```

## e. Data Cleaning, QC & Preprocessing
```{r, echo=F, warning=F, fig.width=15, fig.height=15}
#Fix Typos in kit ids in PB90
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="KI-0014643")] <- "KL-0014643"
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="kl-0023998")] <- "KL-0023998"


# #Lambda load
# bucket <- "harmonized.dataset" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# s3$download_file(bucket, "harmonized_dataset.csv", temp_file)
# harmonized_data <- read.csv(temp_file,na="")

#Load raw harmonized dataset
harmonized_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean","harmonized_dataset.csv"),na="")

dat <- harmonized_data %>%
  arrange(screen_date) %>% 
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))
dat2 <- dat %>% 
  filter(group=="Type 2 Diabetes" | group == "Lean Control") %>%
  filter(visit=="baseline") %>% 
  filter(!is.na(kit_id)) %>% 
  filter(!is.na(epic_sglti2_1)) %>%  
  filter(!is.na(epic_glp1ra_1)) 

dat2$kit_id[which(dat2$kit_id=="KI-0014643")] <- "KL-0014643"
dat2$kit_id[which(dat2$kit_id=="kl-0023998")] <- "KL-0023998" 
dat2$kit_id[which(dat2$kit_id=="Kl-0014643")] <- "KL-0014643" 
#"KL-0030913" "KL-0031453" "KL-0031460" "KL-0032459" kit IDs with biopsies IDs but missing in the pb90 dataset - potentially run after pb90

ids <- c(dat2$kit_id)
# ids <- ids[which(!ids %in% c("KL-0030913","KL-0031453","KL-0031460","KL-0032459"))] #30 remain
length(ids) #52


#Filter pb90 to these 52 kit ids for aim 1
# so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)

#Check that the ids are there 
length(unique(so_kpmp_sc$kit_id)) #46 - 6 missing
ids[which(!ids %in% unique(so_kpmp_sc$kit_id))] #"KL-0019095" "KL-0030622" "KL-0030913" "KL-0031453" "KL-0031460" "KL-0032459"
#Find their mrns
# dat2$record_id[which(dat2$kit_id %in% ids[which(!ids %in% unique(so_kpmp_sc$kit_id))])]
# dat2$mrn[which(dat2$kit_id %in% ids[which(!ids %in% unique(so_kpmp_sc$kit_id))])]


#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  so_kpmp_sc@meta.data
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(dat2,by="kit_id")
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata back into seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)

#Check number of unique ids
length(unique(so_kpmp_sc$kit_id)) #should be 46
# unique(ids[which(!ids %in% so_kpmp_sc$kit_id)]) 

#Remove metadatasets
rm(meta_kidney_sc,harm_meta_data,harmonized_data,dat,dat2)

# #Load harmonized data that has been filtered from 90 to the 83 participants that have baseline single cell data
# #Local Load
# harm_meta_data <- read.csv(fs::path(dir.dat,"Kidney scRNAseq Project","Data","harmonized_data_kidney_sc_all_metadata2.csv"))
# 
# #Lambda load
# # bucket <- "scrna" # bucket name in Kopah
# # temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
# # s3$download_file(bucket, "data_clean/harmonized_data_kidney_sc_all_metadata2.csv", temp_file)
# # harm_meta_data <- read.csv(temp_file)
# 
# harm_meta_data <- harm_meta_data %>%
#   dplyr::select(-X)
# 
# #Select metadata from seurat object to facilitate merge of new metadata into seurat object
# meta_kidney_sc <-  so_kpmp_sc@meta.data
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# 
# #Merge metadata from 83 participants at baseline into seurat object metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(harm_meta_data,by="kit_id")
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# 
# #Pull ids from 83 participants at baseline to filter seurat object to these participants only 
# ids <- harm_meta_data$kit_id
# 
# #Merge metadata back into seurat object
# so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
# 
# #Check number of unique ids
# length(unique(so_kpmp_sc$kit_id)) #should be 90
# 
# #Filter seurat object to only IDs that have the metadata & sc data (83 individuals at baseline)
# so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)
# 
# #Check number of unique ids after filtering
# length(unique(so_kpmp_sc$kit_id)) #should be 83
# 
# #Remove metadatasets
# rm(meta_kidney_sc,harm_meta_data)
# 
# #Remove two coenrolled IDs
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0030621")
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
# #Check unique number of kit ids now (should be 81)
# length(unique(so_kpmp_sc$kit_id)) #Should be 81

# #Load in most up to date medication data to update medication information
# #Local Load
# med <- read.xlsx(fs::path(dir.dat,"Kidney scRNAseq Project/Data/Biopsies_w_mrn_Oct3.xlsx"))
# 
# # bucket <- "scrna" # bucket name in Kopah
# # temp_file <- tempfile(fileext = ".xlsx") # need to create a temporary file
# # s3$download_file(bucket, "data_clean/Biopsies_w_mrn_Oct3.xlsx", temp_file)
# # med <- read.xlsx(temp_file)
# 
# # rm(s3,session,keys)
# 
# #Select Metformin, RASSI, Insulin data
# med <- med %>%
#   dplyr::select(all_of(c("record_id","mrn","raasi_1","insulin_1","mfm_1")))
# #Pull seurat object metadata to help harmoinize in new metadata
# meta_kidney_sc <-  so_kpmp_sc@meta.data
# #Filter to only those with a unique identifier id in the seurat object metadata
# med <- med %>%
#   filter(mrn %in% as.character(meta_kidney_sc$mrn)) 
# length(unique(med$mrn)) #95 total rows remain, 81 unique individual ids
# #Filter to only those that have a unique record id in the seurat object
# med <- med %>%
#   filter(record_id %in% meta_kidney_sc$record_id) 
# length(unique(med$mrn)) #81 remain
# length(unique(med$record_id)) #81
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# med$mrn <- as.numeric(med$mrn) #Make numeric to merge
# #Merge med data with seurat metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(med,by=c("mrn","record_id"))
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# length(unique(meta_kidney_sc$mrn)) #81 remain
# length(unique(meta_kidney_sc$record_id)) #81
# 
# #Add Med Meta Data to Seurat object
# so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
# #Remove med metadatset
# rm(med,meta_kidney_sc)

#Create medication & disease status groups of interest
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)

so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
so_kpmp_sc@meta.data$medication <- factor(so_kpmp_sc@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))


# #Filter to RH/RH2 at baseline only
# #RENAL-HEIR or RENAL-HEIRitage
# so_kpmp_sc <- subset(so_kpmp_sc,study=="RENAL-HEIR" | study=="RENAL-HEIRitage")

#Ensure default assay in seurat object to RNA
DefaultAssay(so_kpmp_sc) <- "RNA"


#Before filtering
ncol(so_kpmp_sc)
# 72469 cells
nrow(so_kpmp_sc)
#31332 genes
length(unique(so_kpmp_sc$kit_id))
#30 participants
length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIR")]))
unique(so_kpmp_sc$record_id[which(so_kpmp_sc$study=="RENAL-HEIR")])
unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIR")])
#"RH-68-T"  "RH-49-T"  "RH-63-T"  "RH-23-T"  "RH-71-T"  "RH-62-T"  "RH-50-T"  "RH-74-T"  "RH-72-T"  "RH-76-T"  "RH-77-T" 
#"RH-75-T"  "RH-67-T"  "IT_19"    "RH-91-T"  "RH2-23-T"
# length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$cohort=="RENAL HERITAGE")]))
length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$study=="RENAL-HEIRitage")]))
#9, "RH2-51-T" "RH2-53-T" "RH-93-T"  "RH2-22-T" "RH2-38-T" "RH2-21-T" "RH2-55-T" "RH2-43-T" "RH2-42-T"
length(unique(so_kpmp_sc$kit_id[which(so_kpmp_sc$cohort=="IMPROVE")]))
#5 coenrolled in improve and Renal Heirage, 4 in Renal Heir, 1 in RH2
#"RH-66-T"  "RH-65-T"  "RH-59-T"  "RH-60-T"  "RH2-07-O"

length(unique(so_kpmp_sc$record_id[which(so_kpmp_sc$study=="IMPROVE")]))
#21 total from renal heir, 10 from renal heritage
length(unique(so_kpmp_sc$record_id[which(so_kpmp_sc$study=="CROCODILE")]))

ncol(so_kpmp_sc)
#65062 cells
nrow(so_kpmp_sc)
#YE JI's filtering code for percent expression 
#Filter out rare genes expressed in less than "gene_pct" of cells
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, layer = "counts"))
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, assay = "RNA", layer = "counts"))
# expr_matrix <- so_kpmp_sc@assays$RNA@counts
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.05])
so_kpmp_sc <- subset(so_kpmp_sc, features = genes_to_keep)
# #After filtering
ncol(so_kpmp_sc) #72469 cells
nrow(so_kpmp_sc) # 9661 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_kpmp_sc), value = TRUE)
# mito_genes2 <- grep("^MT.", rownames(so_kpmp_sc), value = TRUE)
#Filter out all mitochondrial genes

#keep_ids <- unique(rownames(so_kpmp_sc)[which(!rownames(so_kpmp_sc) %in% mito_genes)])
# so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#so_kpmp_sc$Gene <- rownames(so_kpmp_sc)
#so_kpmp_sc <- subset(so_kpmp_sc, Gene %in% keep_ids)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
#so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc@assays$RNA@counts), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc, !rownames(so_kpmp_sc) %in% mito_genes)
# grep("^MT-", rownames(so_kpmp_sc@assays$RNA@counts), value = TRUE)
# dim(so_kpmp_sc@assays$RNA@counts) #9276 186125
# dim(so_kpmp_sc@assays$RNA@data) #9276 186125
# dim(so_kpmp_sc@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
rownames(so_kpmp_sc)[(grepl("^MT", rownames(so_kpmp_sc)))] #0
ncol(so_kpmp_sc) #186125 cells
nrow(so_kpmp_sc) #15180 genes


#Step 3: Remove ribosomal Genes
# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), ribo_genes))
# sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
length(which(rownames(so_kpmp_sc) %in% ribo_genes)) #0
ncol(so_kpmp_sc) #65,062 cells
nrow(so_kpmp_sc) #15103 genes

#Renormalize & Scale after filtering
so_kpmp_sc <- NormalizeData(so_kpmp_sc)
so_kpmp_sc <- ScaleData(so_kpmp_sc, features = VariableFeatures(so_kpmp_sc))

# Calculate cell library size for offset in NEBULA --------------------------------------
counts_layer <- round(GetAssayData(so_kpmp_sc, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
so_kpmp_sc$library_size <- library_size
# View(so_kpmp_sc@meta.data)

# # TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- log(dge$samples$lib.size) + log(dge$samples$norm.factors)
# so_kpmp_sc$tmm_offset <- tmm_offset

# Pooled offset
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
sce <- computeSumFactors(sce)
# View size factors
sizeFactors(sce)
# STEP 3: Calculate offset → log(size factors)
<<<<<<< HEAD
# pooled_offset <- log(sizeFactors(sce))
=======
>>>>>>> 7b175fa22b1eac6ba6197a6372cc0cc635b3c12f
pooled_offset <- sizeFactors(sce)
so_kpmp_sc$pooled_offset <- pooled_offset
#----------------------------------------------------------------------------

#Lambda save
# write file
# bucket <- "scrna" # bucket name in Kopah
# temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
# write.csv(df, temp_file, row.names = FALSE) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, bucket, 'data_clean/Cleaned_DECODE_so.rds')

<<<<<<< HEAD
saveRDS(so_kpmp_sc,"Cleaned_DECODE_so2.rds")
# so_kpmp_sc <- readRDS("/home/hailey/Documents/DECODE Data/Cleaned_DECODE_so2.rds")
=======
# saveRDS(so_kpmp_sc,"Cleaned_DECODE_so.rds")
saveRDS(so_kpmp_sc,fs::path(dir.dat,"Cleaned_DECODE_so.rds"))
# so_kpmp_sc <- readRDS("/home/hailey/Documents/DECODE Data/Cleaned_DECODE_so.rds")
>>>>>>> 7b175fa22b1eac6ba6197a6372cc0cc635b3c12f

#Local Save
# saveRDS(so_kpmp_sc,"/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/DECODE/DECODE Analysis/Data/Formatted_KPMP_Decode.rds")
# so_kpmp_sc <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/DECODE/DECODE Analysis/Data/Formatted_KPMP_Decode.rds")

#Create general hepatocyte cell type variable
# #Create PT and TAL pseudobulk cell type variable
# so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
#                                   grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
#                                   grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
#                                   grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
#                                   grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
#                                   grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
#                                   grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
#                                   grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
#                                   grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
#                                   so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
#                                   so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
#                                   so_kpmp_sc$celltype_rpca=="B"~"B",
#                                   so_kpmp_sc$celltype_rpca=="T"~"T")
# so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)

so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
                                 so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
                                 so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
                               ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                      ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))
# so_kpmp_sc$celltype2 <- factor(so_kpmp_sc$celltype2)

# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
#   mutate(SGLT2=ifelse(epic_sglt2i_1=="sglt2","SGLT2i","No SGLT2i"))

# #Filter to TCA cycle & Ox Phos Genes
# genes <- unique(c(tca,ox_phos))
# so_kpmp_sc <- subset(so_kpmp_sc, features = genes)
# DefaultAssay(so_kpmp_sc) <- "RNA"
# rownames(so_kpmp_sc) #34 genes remain

# # saveRDS(so_kpmp_sc,fs::path(dir.dat,"Cleaned_so_kpmp_sc2.rds"))
# so_kpmp_sc <- readRDS(fs::path(dir.dat,"Cleaned_so_kpmp_sc2.rds"))
# # so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
# #                                   grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
# #                                   grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
# #                                   grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
# #                                   grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
# #                                   grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
# #                                   grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
# #                                   grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
# #                                   grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
# #                                   so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
# #                                   so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
# #                                   so_kpmp_sc$celltype_rpca=="B"~"B",
# #                                   so_kpmp_sc$celltype_rpca=="T"~"T")
# # so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)
# 
# so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
# so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
#                                  so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
#                                  so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
#                                ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
#                                       ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))
#Make sure TAL includes all types
unique(so_kpmp_sc$KPMP_celltype)

so_kpmp_sc$TAL_celltype <- ifelse((so_kpmp_sc$KPMP_celltype=="C-TAL-1" | 
                                     so_kpmp_sc$KPMP_celltype=="C-TAL-2"|
                                     so_kpmp_sc$KPMP_celltype=="dTAL" |
                                     so_kpmp_sc$KPMP_celltype=="aTAL"), "TAL","Non-TAL")
# so_kpmp_sc$celltype2 <- factor(so_kpmp_sc$celltype2)

# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
#   mutate(SGLT2=ifelse(medication=="sglt2","SGLT2i","No SGLT2i"))

# tca_genes <- rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% tca)]
# ox_phos_genes <- rownames(so_kpmp_sc)[which(rownames(so_kpmp_sc) %in% ox_phos)]

#DCT cells
unique(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$DCT_celltype <- ifelse((so_kpmp_sc$KPMP_celltype=="DCT" | 
                                     so_kpmp_sc$KPMP_celltype=="dDCT"), "DCT","Non-DCT")

# #Calculate K2 and F variables
# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
#   rowwise() %>%
#   mutate(avg_c_k2 = (lc_k2+rc_k2)/2) %>% 
#   mutate(avg_m_k2 = (lm_k2+rm_k2)/2) %>% 
#   mutate(avg_c_f = (lc_f+rc_f)/2) %>% 
#   mutate(avg_m_f = (lm_f+rm_f)/2) %>% 
#   ungroup()
# so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
#   rowwise() %>% 
#   mutate(avg_c_k2_f = (avg_c_k2/avg_c_f)) %>% 
#   mutate(avg_m_k2_f = (avg_m_k2/avg_m_f)) %>% 
#   ungroup()
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))


so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2_exclusive=case_when(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No" ~ "Exclusive SGLT2",
                                   epic_sglti2_1=="Yes" & epic_glp1ra_1=="Yes" ~ "No SGLT2",
                                   epic_sglti2_1=="No" & epic_glp1ra_1=="Yes" ~ "No SGLT2",
                                   epic_sglti2_1=="No" & epic_glp1ra_1=="No" ~ "No SGLT2")) %>% 
  mutate(GLP1_exclusive=case_when(epic_glp1ra_1=="Yes" & epic_sglti2_1=="No" ~ "Exclusive GLP-1",
                                  epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes" ~ "No GLP-1",
                                  epic_glp1ra_1=="No" & epic_sglti2_1=="Yes" ~ "No GLP-1",
                                  epic_glp1ra_1=="No" & epic_sglti2_1=="No" ~ "No GLP-1")) 
```


## f. Explore Distribution & Zero-Inflation
###LC & T2D No Med
```{r}
#Check if data have been normalized 
so_kpmp_sc@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_kpmp_sc, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_kpmp_sc, layer = "data")[, 1:5])    # Normalized data

so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))

so_no_med <- subset(so_kpmp_sc,Medication=="No Medication")

#Check for normality
# Open a PDF device (all plots go here)
#Raw counts
pdf(fs::path(dir.results,"Raw_count_gene_expression_histograms_counts_LC_T2d.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_no_med), 100)
# genes <- rownames(so_no_med)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_no_med, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Count Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Normalized Expression
pdf(fs::path(dir.results,"Normalized_Expression_gene_expression_histograms_counts_lc_t2d.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_no_med), 100)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_no_med, layer = "data")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Normalized Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Zero_Inflation_Visualization_lc_t2d.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_no_med, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_no_med, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Overdispersion_Visualization_lc_t2d.pdf"), width = 8, height = 6)
hist(dispersion, breaks=300, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 8))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)
```
### T2D Med
```{r}
#Check if data have been normalized 
so_kpmp_sc@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_kpmp_sc, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_kpmp_sc, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
#Raw counts
pdf(fs::path(dir.results,"Raw_count_gene_expression_histograms_counts.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_kpmp_sc), 100)
# genes <- rownames(so_kpmp_sc)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_kpmp_sc, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Count Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Normalized Expression
pdf(fs::path(dir.results,"Normalized_Expression_gene_expression_histograms_counts.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_kpmp_sc), 100)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_kpmp_sc, layer = "data")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Normalized Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_kpmp_sc, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_kpmp_sc, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=300, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 8))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)
```

## e. Select Highly Variable Genes (HVGs)
```{r}
so_kpmp_sc <- FindVariableFeatures(so_kpmp_sc, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_kpmp_sc)

# Subset Seurat object to only HVGs
so_kpmp_sc_hvg <- subset(so_kpmp_sc, features = hvgs)
```

## g. Evaluate Covariates before Adjustment
###LC T2D No Med
```{r}
#Categorical Covariates
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))


dat <- dat %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))

dat <- dat %>% 
  filter(Medication=="No Medication")

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
label(dat$SGLT2) <- "SGLT2i"
label(dat$GLP1) <- "GLP-1"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$avg_c_k2) <- "Average cortical k2 (global)"
label(dat$avg_m_k2) <- "Average medulla k2 (global)"
label(dat$avg_c_f) <- "Average cortical F (global)"
label(dat$avg_m_f) <- "Average medulla F (global)"
# label(dat$avg_c_k2_f) <- "Average cortical k2/F"
# label(dat$avg_m_k2_f) <- "Average medulla k2/F"


#Any med vs no med
# dat <- dat %>% 
#   mutate(Medication =  ifelse(GLP1=="GLP-1" | SGLT2 == "SGLT2i", "Medication","No Medication"))
dat$Medication <- factor(dat$Medication)
cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_T2D_LC.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  # p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
  #   geom_bar(position = "fill") +  # use "dodge" for absolute counts
  #   labs(y = "Proportion", x = NULL) +
  #   # title = paste0("Distribution of ", covariate, " by Diabetes Status")
  #   scale_y_continuous(labels = scales::percent_format()) +
  #   theme_minimal() +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#2a9d8f", "#e9c46a")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_T2D_LC.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "group", y = covariate, fill = "group")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()


```
###T2D Only Med
```{r}
#Categorical Covariates
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))

dat <- dat %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i"))
dat <- dat %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1"))

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
label(dat$SGLT2) <- "SGLT2i"
label(dat$GLP1) <- "GLP-1"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$avg_c_k2) <- "Average cortical k2 (global)"
label(dat$avg_m_k2) <- "Average medulla k2 (global)"
label(dat$avg_c_f) <- "Average cortical F (global)"
label(dat$avg_m_f) <- "Average medulla F (global)"
# label(dat$avg_c_k2_f) <- "Average cortical k2/F"
# label(dat$avg_m_k2_f) <- "Average medulla k2/F"

dat$group <- factor(dat$group)
# table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| study, data=dat)
# table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| study, data=dat)
# 
# table1(~ age + sex + bmi + triglycerides + hba1c + medication| group, data=dat)
# table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| group, data=dat)
#Examine covariates
cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1","group")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_SGLT2.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  # p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
  #   geom_bar(position = "fill") +  # use "dodge" for absolute counts
  #   labs(y = "Proportion", x = NULL) +
  #   # title = paste0("Distribution of ", covariate, " by Diabetes Status")
  #   scale_y_continuous(labels = scales::percent_format()) +
  #   theme_minimal() +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  p <- ggplot(dat, aes_string(x = "SGLT2", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1","group")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_GLP1.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  # p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
  #   geom_bar(position = "fill") +  # use "dodge" for absolute counts
  #   labs(y = "Proportion", x = NULL) +
  #   # title = paste0("Distribution of ", covariate, " by Diabetes Status")
  #   scale_y_continuous(labels = scales::percent_format()) +
  #   theme_minimal() +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  p <- ggplot(dat, aes_string(x = "GLP1", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#2a9d8f", "#e9c46a")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_SGLT2.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "SGLT2", y = covariate, fill = "SGLT2")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()

con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#264653", "darkred")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_GLP1.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "GLP1", y = covariate, fill = "GLP1")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()

#Any med vs no med
dat <- dat %>% 
  mutate(AnyMed =  ifelse(GLP1=="GLP-1" | SGLT2 == "SGLT2i", "Medication","No Medication"))
dat$AnyMed <- factor(dat$AnyMed)
cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1","group")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_AnyMed.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  # p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
  #   geom_bar(position = "fill") +  # use "dodge" for absolute counts
  #   labs(y = "Proportion", x = NULL) +
  #   # title = paste0("Distribution of ", covariate, " by Diabetes Status")
  #   scale_y_continuous(labels = scales::percent_format()) +
  #   theme_minimal() +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  p <- ggplot(dat, aes_string(x = "AnyMed", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#2a9d8f", "#e9c46a")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_AnyMed.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "AnyMed", y = covariate, fill = "AnyMed")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()


```

## h. Visualizations 
### i. All Participants (T2D + LC - NO MED)
```{r}
# PCA
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))

so_no_med <- subset(so_kpmp_sc,Medication=="No Medication")
so_no_med <- FindVariableFeatures(object = so_no_med)
so_no_med <- RunPCA(so_no_med, features = VariableFeatures(object = so_no_med),assay="RNA")
ElbowPlot(so_no_med)

# # Find neighbors and clusters (again using integrated data)
so_no_med <- FindNeighbors(so_no_med, assay = "RNA", dims = 1:20)
so_no_med <- FindClusters(so_no_med, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
# so_no_med@reductions
# DimPlot(so_no_med, reduction = "umap.harmony", raster = F)
# DimPlot(so_no_med, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)
p <- DimPlot(so_no_med, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

png(fs::path(dir.results, "UMAP_by_Celltype_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(p)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_no_med@meta.data %>% 
  filter(celltype2 == "PT")

prop_plota <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("PT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_PT_Cells_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(prop_plota)
dev.off()

cellcount <- so_no_med@meta.data %>% 
  filter(celltype2 == "TAL")

prop_plotb <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("TAL Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_TAL_Cells_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(prop_plotb)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_no_med@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("EC Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_EC_Cells_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_no_med@meta.data %>% 
  filter(grepl("DCT",KPMP_celltype) | grepl("dDCT",KPMP_celltype))
prop_plotd <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("DCT Cells") +
  scale_fill_manual(values = c("#264653","darkred"))

png(fs::path(dir.results, "Barchart_DCT_Cells_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(prop_plotd)
dev.off()

umap_plot <- DimPlot(
  so_no_med,
  reduction = "umap.harmony",
  group.by = "group",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("darkred", "lightblue")) +
  ggtitle("UMAP by Diabetes Group")

png(fs::path(dir.results, "UMAP_T2D_LC_No_Med.png"),
    width = 5000, height = 3000, res = 300)
print(umap_plot)
dev.off()
```

### i. T2D Only
```{r}
# PCA
so_T2D <- subset(so_kpmp_sc,group=="Type_2_Diabetes")
so_T2D <- FindVariableFeatures(object = so_T2D)
so_T2D <- RunPCA(so_T2D, features = VariableFeatures(object = so_T2D),assay="RNA")
ElbowPlot(so_T2D)

# # Find neighbors and clusters (again using integrated data)
so_T2D <- FindNeighbors(so_T2D, assay = "RNA", dims = 1:5)
so_T2D <- FindClusters(so_T2D, resolution = 0.5)
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))
# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
# so_T2D@reductions
# DimPlot(so_T2D, reduction = "umap.harmony", raster = F)
# DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)
p <- DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")
p
#Print plot
png(fs::path(dir.results, "UMAP_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot by Cell Type among T2D")
print(p)
dev.off()

# so_T2D$group <- factor(so_T2D$group)
# DimPlot(so_T2D, reduction = "umap.harmony",group.by = "group",label=F,raster=F) +
#   ggtitle(paste0("UMAP by Diabetes Category"))
# 
# so_T2D$medication <- factor(so_T2D$medication)
# DimPlot(so_T2D, reduction = "umap.harmony",group.by = "medication",label=F,raster=F) +
#   ggtitle(paste0("UMAP by Medication Category"))

# so_T2D$medication3 <- ifelse(so_T2D$medication=="sglt2","SGLT2i","No SGLT2i")
# so_T2D$medication3 <- factor(so_T2D$medication3)
DimPlot(
  so_T2D,
  reduction = "umap.harmony",
  group.by = "SGLT2",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("lightgray","darkblue")) +
  ggtitle("UMAP by SGLT2i Status")


#Print plot
png(fs::path(dir.results, "UMAP_SGLT2_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_T2D,
  reduction = "umap.harmony",
  group.by = "SGLT2",
  label = FALSE,
  raster = FALSE
) +
  scale_color_manual(values = c("lightgray","darkblue")) +
  ggtitle("UMAP by SGLT2i Status")
print(p)
dev.off()

#Print plot
png(fs::path(dir.results, "UMAP_Medication_T2D.png"),
    width = 4500, height = 3000, res = 300)
p <- DimPlot(
  so_T2D,
  reduction = "umap.harmony",
  group.by = "medication",
  label = FALSE,
  raster = FALSE
) +
  # scale_color_manual(values = c( "#e9c46a", "#f4a261", "#e76f51","darkred")) +
  ggtitle("UMAP by Medication Status in T2D")
print(p)
dev.off()

#Barcharts of proportions
cellcount <- so_T2D@meta.data
prop_plot <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Participant IDs") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
# ggtitle("PT Cells") +
# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_All_Participants_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()

prop_plot <- ggplot(data=cellcount,aes(sglt2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell Type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) 
png(fs::path(dir.results, "Barchart_SGLT2_All_Cells.png"),width = 4500, height = 3000, res = 300)
print(prop_plot)
dev.off()


# prop_plot <- ggplot(data=cellcount,aes(medication3, fill = KPMP_celltype)) + 
#   geom_bar(stat = "count", position = "fill") +
#   theme_classic() +
#   labs(x = NULL,
#        y = "Proportion of Cells",
#        fill = "Cell type") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
#   theme(plot.title = element_text(hjust=0.5, face="bold"),
#         text = element_text(size = 20)) 
# # ggtitle("PT Cells") +
# # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))
# prop_plot

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "PT")
cellcount$sglt2 <- ifelse(cellcount$sglt2=="Yes","SGLT2","No SGLT2")
label(cellcount$sglt2) <- "SGLT2i Status"
prop_plota <- ggplot(data=cellcount,aes(sglt2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("SGLT2i Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_PT_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plota)
dev.off()

cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "TAL")
cellcount$sglt2 <- ifelse(cellcount$sglt2=="Yes","SGLT2","No SGLT2")

label(cellcount$sglt2) <- "SGLT2i Status"
prop_plotb <- ggplot(data=cellcount,aes(sglt2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("SGLT2i Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_TAL_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotb)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))
cellcount$sglt2 <- ifelse(cellcount$sglt2=="Yes","SGLT2","No SGLT2")
label(cellcount$sglt2) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(sglt2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("SGLT2i Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_EC_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_T2D@meta.data %>% 
  filter(grepl("dDCT",KPMP_celltype) | grepl("DCT",KPMP_celltype))
cellcount$sglt2 <- ifelse(cellcount$sglt2=="Yes","SGLT2","No SGLT2")
label(cellcount$sglt2) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(sglt2, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("SGLT2i Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_SGLT2_DCT_Cells.png"),width = 2000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

#Individual
#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "PT")

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plota <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("PT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_PT_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plota )
dev.off()

cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "TAL")

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotb <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("TAL Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

png(fs::path(dir.results, "Barchart_TAL_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotb)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("EC Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plotc 

png(fs::path(dir.results, "Barchart_EC_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

cellcount <- so_T2D@meta.data %>% 
  filter(grepl("dDCT",KPMP_celltype) | grepl("DCT",KPMP_celltype))

# label(cellcount$record_id) <- "SGLT2i Status"
prop_plotc <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("DCT Cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plotc 

png(fs::path(dir.results, "Barchart_DCT_Cells.png"),width = 4000, height = 2500, res = 300)
print(prop_plotc)
dev.off()

```


## i. Descriptive Stats
### ii. No Med (LC + T2D)
```{r}
dat <- so_kpmp_sc@meta.data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))


dat <- dat %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication"))

dat <- dat %>% 
  filter(Medication=="No Medication")

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR) CKD Epi"
label(dat$gfr_bsa_plasma) <- "Measured Glomerula Filtration Rate (mGFR) BSA"
label(dat$acr_u) <- "ACRu"
label(dat$SGLT2) <- "SGLT2i"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$avg_c_k2) <- "Average cortical k2 (global)"
label(dat$avg_m_k2) <- "Average medulla k2 (global)"
label(dat$avg_c_f) <- "Average cortical F (global)"
label(dat$avg_m_f) <- "Average medulla F (global)"
# label(dat$avg_c_k2_f) <- "Average cortical k2/F"
# label(dat$avg_m_k2_f) <- "Average medulla k2/F"

#Table 1. 
table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| study, data=dat)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +epic_mfm_1+epic_insulin_1| study, data=dat)

table1(~ age + sex + bmi + triglycerides + hba1c +
         pah_clear_bsa + eGFR_CKD_epi + gfr_bsa_plasma +acr_u +epic_mfm_1+epic_insulin_1| group, data=dat)
# table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| group, data=dat)



#T2D + LC
ggplot(dat, aes(x = group, y = age)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "Age by groupi Status",
       x = "groupi (Yes/No)",
       y = "Age") +
  theme_classic()+
  scale_fill_manual(values = c("#264653", "#2a9d8f"))

# scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

ggplot(dat, aes(x = group, y = bmi)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "BMI by groupi Status",
       x = "groupi (Yes/No)",
       y = "BMI") +
  theme_classic()+
  scale_fill_manual(values = c("#2a9d8f", "#e9c46a"))

ggplot(dat, aes(x = group, y = triglycerides)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "Triglycerides by groupi Status",
       x = "groupi (Yes/No)",
       y = "Triglycerides") +
  theme_classic()+
  scale_fill_manual(values = c("#e9c46a", "#f4a261"))

#ACRu
ggplot(dat, aes(x = group, y = acr_u)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "ACRu by groupi Status",
       x = "groupi (Yes/No)",
       y = "ACRu") +
  theme_classic()+
  scale_fill_manual(values = c("#f4a261", "#e76f51"))

#eGFR_CKD_epi
ggplot(dat, aes(x = group, y = eGFR_CKD_epi)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "eGFR by groupi Status",
       x = "groupi (Yes/No)",
       y = "eGFR") +
  theme_classic()+
  scale_fill_manual(values = c("#e76f51","darkred"))

#pah_clear_bsa
ggplot(dat, aes(x = group, y = pah_clear_bsa)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "PAH Clearance (BSA) by groupi Status",
       x = "groupi (Yes/No)",
       y = "PAH Clearance (BSA)") +
  theme_classic()+
  scale_fill_manual(values = c("darkred","#264653"))

#gfr_bsa_plasma
ggplot(dat, aes(x = group, y = gfr_bsa_plasma)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "GFR by groupi Status",
       x = "groupi (Yes/No)",
       y = "GFR (BSA)") +
  theme_classic()+
  scale_fill_manual(values = c("#264653","#2a9d8f"))

#HbA1c
ggplot(dat, aes(x = group, y = hba1c)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "HbA1c by groupi Status",
       x = "groupi (Yes/No)",
       y = "HbA1c") +
  theme_classic()+
  scale_fill_manual(values = c("#2a9d8f","#e9c46a"))

```
### i. T2D Only
```{r, echo = F,warning=F}
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  # filter(group=="Type_2_Diabetes") %>% 
  # group_by(record_id) %>%
  # summarise(across(everything(), first)) %>%
  # ungroup() 
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(mrn, visit))

dat <- dat %>% 
  mutate(SGLT2=ifelse(epic_sglti2_1=="Yes","SGLT2i","No SGLT2i")) %>% 
  mutate(GLP1=ifelse(epic_glp1ra_1=="Yes","GLP-1","No GLP-1")) %>% 
  mutate(Medication=ifelse(epic_sglti2_1=="Yes"|epic_glp1ra_1=="Yes","Medication","No Medication")) %>% 
  filter(group=="Type_2_Diabetes") 

dat <- dat %>% 
  mutate(SGLT2_exclusive=case_when(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No" ~ "Exclusive SGLT2",
                                   epic_sglti2_1=="Yes" & epic_glp1ra_1=="Yes" ~ "No SGLT2",
                                   epic_sglti2_1=="No" & epic_glp1ra_1=="Yes" ~ "No SGLT2",
                                   epic_sglti2_1=="No" & epic_glp1ra_1=="No" ~ "No SGLT2")) %>% 
  mutate(GLP1_exclusive=case_when(epic_glp1ra_1=="Yes" & epic_sglti2_1=="No" ~ "Exclusive GLP-1",
                                  epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes" ~ "No GLP-1",
                                  epic_glp1ra_1=="No" & epic_sglti2_1=="Yes" ~ "No GLP-1",
                                  epic_glp1ra_1=="No" & epic_sglti2_1=="No" ~ "No GLP-1")) 

table(dat$GLP1,dat$SGLT2)
table(dat$GLP1_exclusive,dat$SGLT2_exclusive)

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
label(dat$SGLT2) <- "SGLT2i"
label(dat$GLP1) <- "GLP-1"
label(dat$SGLT2_exclusive) <- "Exclusive SGLT2i"
label(dat$GLP1_exclusive) <- "Exclusive GLP-1"
label(dat$glp1_sglt2) <- "Combined GLP-1/SGLT2i"
label(dat$group) <- "Type 2 Diabetes Status"
label(dat$avg_c_k2) <- "Average cortical k2 (global)"
label(dat$avg_m_k2) <- "Average medulla k2 (global)"
label(dat$avg_c_f) <- "Average cortical F (global)"
label(dat$avg_m_f) <- "Average medulla F (global)"
label(dat$Medication) <- "SGLT2 or GLP-1"
# label(dat$avg_c_k2_f) <- "Average cortical k2/F"
# label(dat$avg_m_k2_f) <- "Average medulla k2/F"

dat2 <- dat %>% 
  filter(glp1_sglt2=="No")  %>% 
  filter(GLP1_exclusive=="No GLP-1")

table(dat2$GLP1,dat2$SGLT2)
table(dat2$GLP1_exclusive,dat2$SGLT2_exclusive)

table1(~age + sex + bmi + triglycerides + hba1c + eGFR_CKD_epi +acr_u +epic_mfm_1+epic_insulin_1|SGLT2_exclusive,data=dat2)


cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1")
plot_list <- list()
custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path("/home/hailey/Documents/DECODE Data/Plot_Categorical_Covariates_SGLT2_exclusive.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  p <- ggplot(dat2, aes_string(x = "SGLT2_exclusive", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# # Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#2a9d8f", "#e9c46a")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path("/home/hailey/Documents/DECODE Data/Plot_Continuous_Covariates_SGLT2_exclusive.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat2, aes_string(x = "SGLT2_exclusive", y = covariate, fill = "SGLT2_exclusive")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()


#SLGT2s Only
dat3 <- dat %>% 
  filter(glp1_sglt2=="No") %>% 
  filter(SGLT2_exclusive=="No SGLT2")
table1(~age + sex + bmi + triglycerides + hba1c + eGFR_CKD_epi +acr_u +epic_mfm_1+epic_insulin_1|GLP1_exclusive,data=dat3)

cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1")
plot_list <- list()
custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path("/home/hailey/Documents/DECODE Data/Plot_Categorical_Covariates_GLP1_exclusive.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  p <- ggplot(dat3, aes_string(x = "GLP1_exclusive", fill = covariate)) +
    geom_bar(position = "fill") +
    labs(y = "Proportion", x = NULL) +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# # Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#264653", "darkred")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path("/home/hailey/Documents/DECODE Data/Plot_Continuous_Covariates_GLP1_exclusive.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat3, aes_string(x = "GLP1_exclusive", y = covariate, fill = "GLP1_exclusive")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()

```



# 3. Comparitive Data Analysis
## A. Type 2 Diabetes (No Med) vs. Healthy Controls
### a. PT Cells
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,celltype2=="PT")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_T2D_LC_No_Med_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#PT Cells
so_kpmp_sc$celltype_new <- ifelse(grepl("PT",so_kpmp_sc$KPMP_celltype),"PT",
                                  ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                         ifelse(grepl("POD",so_kpmp_sc$KPMP_celltype),"POD",
                                                ifelse(grepl("EC",so_kpmp_sc$KPMP_celltype),"EC",NA))))
#PT
so_celltype <- subset(so_kpmp_sc,celltype_new=="PT")
ncol(so_celltype) #41383 cells
nrow(so_celltype) #9276 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

#Try as batch loop
# Set batch size
batch_size <- 2000
total_cores <- 20

# Get total number of genes
# gene_list_total <- gene_list
# total_genes <- length(gene_list_total)
length(gene_list_total)
length(unique(gene_list_total))

# Create an empty list to store results
all_results <- list()

# cl <- makeCluster(total_cores)
# registerDoParallel(cl)

# Loop over batches
for (start_idx in seq(1, total_genes, by = batch_size)) {
  
  # Define end index for the batch
  end_idx <- min(start_idx + batch_size - 1, total_genes)
  
  # Subset genes for this batch
  gene_list <- gene_list_total[start_idx:end_idx]
  
  # # Set number of cores to use
  cl <- makeCluster(total_cores)
  registerDoParallel(cl)
  
  # Define function to process a single gene
  process_gene <- function(gene_idx) {
    gene <- gene_list[gene_idx]  # Get the gene name based on the index
    
    # Ensure that the gene exists in your data subset
    if (sum(data_subset[[gene]]) > 0) {
      # Define model formula
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      
      # Fit the zero-inflated mixed-effects model with error handling
      # model1 <- tryCatch({
      model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      # }, error = function(e) {
      #   return(NULL)
      # })
      
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
      
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Return result
    return(data.frame(Gene = gene, Beta = Beta, PValue = PValue, ZI_Intercept = zi, ZI_PValue = zi_pval))
  }
  
  
  # Run the analysis in parallel
  batch_results <- foreach(i = seq_along(gene_list), .combine = rbind, .packages = c("glmmTMB", "lme4")) %dopar% {
    process_gene(i)
  }
  
  # Stop the cluster
  stopCluster(cl)
  
  # Store batch results
  all_results[[length(all_results) + 1]] <- batch_results
  
  # Print progress
  cat("Processed batch:", start_idx, "to", end_idx, "\n")
}



# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)
# Print the final results
view(full_results)
# full_results4 <- full_results
# full_results <- rbind(full_results,full_results4)
# rm(full_results2,full_results3,full_results4,full_results5,full_results6,full_results7)
#Accidentally ran RORA twice, remove second entry (they are identical)
# full_results <- full_results[-3501,]

# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)

# view(full_results)

full_results <- full_results %>%
  mutate(FoldChange=2^Beta-1)  
# mutate(FoldChange3=2^Beta3-1)
# full_results <- full_results %>% 
#   dplyr::rename(color=color2,
#                 FoldChange=FoldChange2) %>%
#   # dplyr::rename(fdr=fdr2,
#   #               PValue10=PValue10_2) %>%
#   # dplyr::select(-c("Beta3","PValue3")) %>% 
#   dplyr::select(-c("color3","FoldChange3"))

write.csv(full_results,fs::path(dir.results,"Pseudobulk_All_Celltypes_Steatosis.csv"))
write.csv(full_results,fs::path(dir.ipa %>% dirname(),"Liver Pathways","Pseudobulk_All_Celltypes_Steatosis.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "All Cell Types, Adjusted for HbA1c & Ethnicity",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_All_Celltypes_Steatosis.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()


full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# write.csv(full_results,fs::path(dir.results,"Pseudobulk_PT_T2D_HC_No_Med.csv"))

# Add a column to determine color based on the sign of the beta
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "salmon", 
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.1)
significant_df <- full_results[full_results$fdr < 0.05, ]

# Sort the data to get top 10 positive and negative Beta based on FDR
top_positive_beta <- significant_df[significant_df$Beta > 0, ] %>%
  arrange(fdr, desc(Beta)) %>%
  head(10)

top_negative_beta <- significant_df[significant_df$Beta < 0, ] %>%
  arrange(fdr, Beta) %>%
  head(10)

# Combine both top positive and negative Beta data
top_10_significant <- rbind(top_positive_beta, top_negative_beta)
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Pseudobulk PT: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.1"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # Add labels for top 10 significant points (both positive and negative Beta) with ggrepel
  geom_text_repel(data = top_10_significant, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_Pseudobulk_PT_T2D_HC_No_Med.pdf"))
print(volcano_plot)
dev.off()
```

#### ii. PT-S1/2
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S1/S2")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S1_S2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S1/S2 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S1_S2_T2D_LC_No_Med_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S1_S2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S1/S2 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S1/S2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S1/S2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S1_S2_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#PT-S1/2
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S1/S2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. PT-S3
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#PT-S3
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S3")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    if (sum(data_subset[[gene]])>0) {
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
      
    } else {
      beta1 <- NA
      pval1 <-NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1) 
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# write.csv(full_results,fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "red",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "blue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
#
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S3 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  ylim(0, 40) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, 
                  max.overlaps = 20, min.segment.length = 0) 

pdf(fs::path(dir.results,"Plot2_PT_S3_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. aPT
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aPT")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_aPT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in aPT Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_aPT_T2D_LC_No_Med_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```

#### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_aPT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "aPT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "aPT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "aPT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"aPT_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#aPT
so_celltype <- subset(so_filtered,KPMP_celltype=="aPT")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))

write.csv(full_results,fs::path(dir.results,"aPT_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.3 & full_results$Beta > 0, "salmon",
                             ifelse(full_results$fdr < 0.3 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.3, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "aPT Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.3"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_aPT_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
## b. EC Cells
#### i Pseudobulk EC
```{r}
#EC-GC
so_celltype <- subset(so_filtered,celltype_new=="EC")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    if (sum(data_subset[[gene]])>0) {
      # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
      # model <- lmer(m0,data=data_subset)
      #Adjust for key covariates
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
    } else {
      beta1 <- NA
      pval1 <- NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"Pseudobulk_EC_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"Pseudobulk_EC_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Pseudobulk EC Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_Pseudobulk_EC_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### ii. EC-AVR
```{r}
#EC-AVR
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="EC-AVR")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results2$PValue)))+length(which(full_results2$PValue=="NaN")))/length(full_results2$Gene))*100,0),"%")
# write.csv(full_results2,fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
full_results <- full_results %>%
  mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

Nonconvergence <- 
  # Create the volcano plot using ggplot
  volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AVR, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_EC_AVR_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```
#### iii. EC-GC
```{r}
#EC-GC
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="EC-GC")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
full_results <- full_results %>%
  mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-GC, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_EC_GC_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```
#### iv. EC-AEA
```{r}
#EC-AEA
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="EC-AEA")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"EC_AEA_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_AEA_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"EC_AEA_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_AEA_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AEA, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_EC_AEA_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```


## c. TAL
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,TAL_celltype=="TAL")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_TAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in TAL Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_TAL_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```

#### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_TAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "TAL Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "TAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "TAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"TAL_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
### i. C-TAL-1
####NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-1")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_C_TAL_1_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in C-TAL-1 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_C_TAL_1_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```

#### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_C_TAL_1_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "C-TAL-1 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "C-TAL-1 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "C-TAL-1 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"C_TAL_1_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
```{r}
#C-TAL-1
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-1")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"C_TAL_1_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"C-TAL-1_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"C-TAL-1_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"C-TAL-1_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "C-TAL-1, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_C_TAL_1_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```
### ii. C-TAL-2
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-2")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_C_TAL_2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in C-TAL-2 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_C_TAL_2_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_C_TAL_2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "C-TAL-2 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "C-TAL-2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "C-TAL-2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"C_TAL_2_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
```{r}
#C-TAL-2
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"C_TAL_2_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"C-TAL-2_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"C-TAL-2_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"C-TAL-2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "C-TAL-2, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_C_TAL_2_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```

### iii. aTAL
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aTAL")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_aTAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in aTAL Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_aTAL_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_aTAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "aTAL Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "aTAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "aTAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"aTAL_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
```{r}
#aTAL
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aTAL")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"aTAL_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"aTAL_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"aTAL_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"aTAL_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "aTAL, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_aTAL_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```
### iv. dTAL
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="dTAL")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_dTAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in dTAL Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_dTAL_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_dTAL_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "dTAL Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "dTAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "dTAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"dTAL_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
```{r}
#dTAL
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="dTAL")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"dTAL_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"dTAL_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"dTAL_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"dTAL_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "dTAL, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_dTAL_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```

## d. Podocytes
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
```{r}
#POD
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="POD")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))
ncol(so_celltype) #3262 cells
nrow(so_celltype) #9276 genes
#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

# #Gene Set
gene_list_total <- gene_list
# gene_list <- gene_list_total[1:10]

# Define the number of cores to use
num_cores <- detectCores() - 1  # Use one less than the total available cores
cl <- makeCluster(num_cores)
registerDoParallel(cl)

gene_list <- gene_list_total

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Run the loop in parallel
results_list <- foreach(i = seq(1, total_genes, by = batch_size), .combine = rbind, .packages = c("glmmTMB")) %dopar% {
  
  batch_results <- list()  # Store results as a list to avoid repeated rbind
  
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  
  for (gene in gene_list[batch]) { 
    if (sum(data_subset[[gene]]) > 0) {
      # Adjust for key covariates
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      # model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      
      # Safe model fitting with error handling
      model1 <- tryCatch({
        glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      }, error = function(e) {
        NULL  # Return NULL if the model fails
      })
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Store results as a proper data frame with named columns
    batch_results[[length(batch_results) + 1]] <- data.frame(
      Gene = gene,
      Beta = Beta,
      PValue = PValue,
      ZI_Intercept = zi,
      ZI_PValue = zi_pval,
      stringsAsFactors = FALSE
    )
  }
  
  # Combine batch results before returning
  do.call(rbind, batch_results)
}

# Combine results from all parallel batches
full_results <- t(do.call(rbind, results_list))

# Stop the cluster
stopCluster(cl)

# View results
full_results <- data.frame(full_results)
View(full_results)
length(which(is.na(full_results$Beta))) #47 NAs in Beta
length(which(full_results$Beta=="NaN")) #0 NaNs in Beta
length(which(is.na(full_results$PValue))) #47 NAs in Pvalue
length(which(full_results$PValue=="NaN")) #4802 NaNs in Pvalue
Nonconvergence_Rate <- paste0(round(((length(which(is.na(full_results$PValue)))+length(which(full_results$PValue=="NaN")))/length(full_results$Gene))*100,0),"%")
write.csv(full_results2,fs::path(dir.results,"POD_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"POD_T2D_HC_No_Med.csv"))

# #Make volcano plot of all gene results for group
# Ensure Beta and PValue10 are numeric
full_results <- full_results2 %>%
  mutate(
    Beta = as.numeric(Beta),
    PValue10 = as.numeric(PValue10)
  ) %>%
  filter(!is.na(Beta), !is.na(PValue10))   # Remove NA values
# dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(across(everything(),~ifelse(.=="NaN",NA,.))) %>% 
# mutate(PValue=as.numeric(PValue))
# full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
full_results$PValue10 <- ifelse(is.na(full_results$PValue), NA, -log10(pmax(full_results$PValue, 1e-10)))
# full_results <- full_results %>%
#   mutate(FoldChange=2^as.numeric(Beta)-1)  

# write.csv(full_results,fs::path(dir.results,"POD_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"POD_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))


# full_results$Beta <- as.numeric(full_results$Beta)
# full_results$Beta <- ifelse(full_results$Beta=="NA",NA,full_results$Beta)
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

# plot_results <- full_results %>% 
#   filter(!is.na(PValue10)) %>% 
#   filter(!is.na(Beta)) %>% 
#   filter(!is.na(PValue)) %>% 
#   dplyr::select(c("Gene","Beta","PValue10","color"))

# # Ensure Beta and PValue10 are numeric
# plot_results <- full_results %>%
#   mutate(
#     Beta = as.numeric(Beta),
#     PValue10 = as.numeric(PValue10)
#   ) %>%
#   filter(!is.na(Beta), !is.na(PValue10)) %>%   # Remove NA values
#     dplyr::select(c("Gene","Beta","FoldChange","PValue10","color"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "POD, Adjusted for Age, Sex & BMI",
    x = "Beta",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,"; Non-convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(-20,7)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_POD_T2D_HC_No_Med.pdf"),width=15,height=10)
print(volcano_plot)
dev.off()
```

## e. DCT
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

###i. DCT-1
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```
###ii. dDCT
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

## B. Medication Status - Type 2 Diabetes Only
### a. PT Cells
####SGLT2
#####NEBULA 
```{r}
#Filter to PT Cells

so_celltype <- subset(so_kpmp_sc,celltype2=="PT")
so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")

so_celltype <- subset(so_celltype,glp1_sglt2=="No")
so_celltype <- subset(so_celltype,GLP1_exclusive=="No GLP-1")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$SGLT2_exclusive <- factor(so_celltype_hvg$SGLT2_exclusive)
#Make sure to set reference level
so_celltype_hvg$SGLT2_exclusive  <- relevel(so_celltype_hvg$SGLT2_exclusive ,ref="No SGLT2")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(25)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~SGLT2_exclusive, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_SGLT2SGLT2i`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_SGLT2_exclusiveExclusive_SGLT2`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_SGLT2_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_SGLT2SGLT2i` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_SGLT2SGLT2i` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_SGLT2SGLT2i`)
# max <- 3.1
min <- min(full_results$`logFC_SGLT2SGLT2i`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_SGLT2SGLT2i`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT Cells",
    subtitle = "SGLT2 vs. No SGLT2 (T2D), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_T2D_SGLT2_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```
##### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_SGLT2_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_sglt2sglt2i)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted_T2D_SGLT2.jpeg"),
       width = 15, height = 20, scale = 1)
```

####GLP-1
#####NEBULA 
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,celltype2=="PT")
so_celltype <- subset(so_celltype,group=="Type_2_Diabetes")

so_celltype <- subset(so_celltype,glp1_sglt2=="No")
so_celltype <- subset(so_celltype,SGLT2_exclusive=="No SGLT2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$GLP1_exclusive <- factor(so_celltype_hvg$GLP1_exclusive)
#Make sure to set reference level
so_celltype_hvg$GLP1_exclusive  <- relevel(so_celltype_hvg$GLP1_exclusive ,ref="No GLP-1")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~GLP1_exclusive, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_GLPGLP-1`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_GLPGLP-1`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_GLP1_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_GLPGLP-1` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_GLPGLP-1` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_GLPGLP-1`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_GLPGLP-1`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_GLPGLP-1`)
# max <- 3.1
min <- min(full_results$`logFC_GLPGLP-1`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_GLPGLP-1`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT Cells",
    subtitle = "GLP-1 vs. No GLP-1 (T2D), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_T2D_GLP1_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```
##### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

#### ii. PT-S1/2
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S1/S2")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S1_S2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S1/S2 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S1_S2_T2D_LC_No_Med_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S1_S2_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S1/S2 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S1/S2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S1/S2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S1_S2_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#PT-S1/2
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S1/S2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. PT-S3
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in PT-S3 Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_PT_S3_T2D_LC_No_Med_unadjusted_pooled_offset_T2D_truncated.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()

#### GSEA
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_PT_S3_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT-S3 Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"PT_S3_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#PT-S3
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S3")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    if (sum(data_subset[[gene]])>0) {
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
      
    } else {
      beta1 <- NA
      pval1 <-NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1) 
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# write.csv(full_results,fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "red",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "blue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
#
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S3 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  ylim(0, 40) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, 
                  max.overlaps = 20, min.segment.length = 0) 

pdf(fs::path(dir.results,"Plot2_PT_S3_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. aPT
####NEBULA & GSEA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aPT")
so_celltype <- subset(so_celltype,Medication=="No Medication")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9416 genes
ncol(so_celltype) #10136 PT cells

## Select Highly Variable Genes (paths)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvg <- VariableFeatures(so_celltype)

# Subset Seurat object to only paths
so_celltype_hvg <- subset(so_celltype, features = hvg)
DefaultAssay(so_celltype_hvg) <- "RNA"

# #Select TCA and Ox Phos Genes
# # pathway_genes <- c(tca,ox_phos)
# so_celltype_path <- subset(so_celltype, features = tca)
# DefaultAssay(so_celltype_path) <- "RNA"

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype_hvg$group <- factor(so_celltype_hvg$group)
#Make sure to set reference level
so_celltype_hvg$group  <- relevel(so_celltype_hvg$group ,ref="Lean_Control")

counts_path <- round(GetAssayData(so_celltype_hvg, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- hvg

cl <- makeCluster(10)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_path[g, , drop = FALSE]
    meta_gene <- so_celltype@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$library)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_path))-length(unique(full_results$gene)))/length(rownames(counts_path))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"DECODE_NEBULA_aPT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Nuclei <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_SGLT2SGLT2i`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Differentially Expressed 2000 HVG in aPT Cells",
    subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  # xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
# dot_plot <- ggplot(full_results, aes(
#   y = reorder(gene, logFC_groupType_2_Diabetes),
#   x = logFC_groupType_2_Diabetes,
#   color = color,
#   size = abs(logFC_groupType_2_Diabetes)
# )) +
#   geom_point(alpha = 0.7) +
#   scale_color_identity() +
#   scale_size(range = c(2, 6), name = "|LogFC|") +
#   geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
#   theme_minimal() +  # Retains grid lines
#   labs(
#     title = "Differentially Expressed 2000 HVG in PT Cells",
#     subtitle = "T2D vs. LC (No Medication), Unadjusted (Pooled Offset)",
#     x = "Log Fold Change",
#     y = "Gene",
#     caption = paste0(
#       "FDR < 0.05, Genes = ", Genes,
#       ", Nuclei = ", Nuclei,
#       ", Non-Convergence Rate: ", Nonconvergence_Rate,
#       ", Genes Filtered out for Low Expression: ", low_exp
#     )
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.y = element_text(size = 8),
#     # axis.text.x = element_text(angle = 0, hjust = 1),
#     axis.line = element_line(color = "black", size = 0.5),
#     axis.ticks.x = element_line(color = "black"),
#     panel.border = element_blank(),
#     panel.background = element_blank()
#   )
# dot_plot
volcano_plot
png(fs::path(dir.results, "Plot_DECODE_NEBULA_aPT_T2D_LC_No_Med_unadjusted_pooled_offset_T2D.png"), 
    width = 2000, height = 1500, res = 300)
print(volcano_plot)
dev.off()
```

#### GSEA
```{r}
full_results <- read.csv(fs::path(dir.results,"DECODE_NEBULA_aPT_cells_T2D_HC_No_Med_unadjusted_pooled_offset.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)


set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 3,
                            maxSize = 500,
                            nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                         stats = rankings_PT,
                         scoreType = 'std', 
                         minSize = 3,
                         maxSize = 500,
                         nproc = 1)
go_res_PT <- fgsea(pathways = go,
                   stats = rankings_PT,
                   scoreType = 'std', 
                   minSize = 5,
                   maxSize = 500,
                   nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                       "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                       "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")

##### KEGG Legacy
a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "aPT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "aPT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "aPT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"aPT_top30_pathways_unadjusted_LC_T2D_No_Med.jpeg"),
       width = 15, height = 20, scale = 1)
```

```{r}
#aPT
so_celltype <- subset(so_filtered,KPMP_celltype=="aPT")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))

write.csv(full_results,fs::path(dir.results,"aPT_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.3 & full_results$Beta > 0, "salmon",
                             ifelse(full_results$fdr < 0.3 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.3, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "aPT Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.3"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_aPT_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```








### i. Pseudobulk PT Cells
```{r}
#PT Cells
so_filtered$celltype_new <- ifelse(grepl("PT",so_filtered$KPMP_celltype),"PT",
                                   ifelse(grepl("TAL",so_filtered$KPMP_celltype),"TAL",
                                          ifelse(grepl("POD",so_filtered$KPMP_celltype),"POD",
                                                 ifelse(grepl("EC",so_filtered$KPMP_celltype),"EC",NA))))
#PT
so_celltype <- subset(so_filtered,celltype_new=="PT")
ncol(so_celltype) #41383 cells
nrow(so_celltype) #9289 genes

# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

# Number of cores to use for parallel processing
num_cores <- detectCores() - 1  # Use one less than the total number of cores

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Create a function that will handle the analysis for each gene
process_gene <- function(gene) {
  
  # Check if gene exists in data (skipping if not present in data)
  if (sum(data_subset[[gene]]) > 0) {
    
    # Fit the model with key covariates
    m1 <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1, data = data_subset)
    
    # Compute estimated marginal means
    emm <- emmeans(model1, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define and test the contrasts
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
      "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
      "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
      "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
      "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
    ))
    
    contrast_p <- as.data.frame(summary(contrast_results))
    contrast_summary <- confint(contrast_results)
    contrast_df <- as.data.frame(contrast_summary)
    contrast_df$PValue <- contrast_p$p.value
    contrast_df$Gene <- gene
    
    # Estimate the overall beta and confidence intervals
    beta1 <- round(summary(model1)$coef[2, 1], 3)
    pval1 <- round(summary(model1)$coef[2, 5], 5)
    se <- round(summary(model1)$coef[2, 2], 5)
    df <- round(summary(model1)$coef[2, 3], 5)
    lowerci <- round(summary(model1)$coef[2, 1] - 1.96 * se, 5)
    upperci <- round(summary(model1)$coef[2, 1] + 1.96 * se, 5)
    
    result <- data.frame(contrast = "Overall", estimate = beta1, SE = se, df = df,
                         lower.CL = lowerci, upper.CL = upperci, PValue = pval1, Gene = gene)
    result2 <- rbind(result, contrast_df)
    
    return(result2)  # Return the processed result
  } else {
    return(NULL)  # If the gene is not present, return NULL
  }
}

# Now use mclapply to run the analysis in parallel for all genes
gene_results <- mclapply(gene_list, process_gene, mc.cores = num_cores)

# Filter out any NULL results and combine all data into a single data frame
full_results <- do.call(rbind, gene_results)
# full_results <- na.omit(full_results)  # Remove any NULL or incomplete results
view(full_results)

# full_results <- data.frame()
# 
# # Total number of genes
# total_genes <- length(gene_list)
# 
# # Calculate the batch size
# batch_size <- round(total_genes / 5)
# 
# # Simulate a vector of genes (replace this with your actual gene data)
# genes <- 1:total_genes
# 
# # Loop through the genes in batches
# for (i in seq(1, total_genes, by = batch_size)) {
#   
#   # Get the current batch (subsetting the gene vector)
#   batch <- genes[i:min(i + batch_size - 1, total_genes)]
#   for (gene in gene_list[batch]) { #tester genes
#     # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
#     # model <- lmer(m0,data=data_subset)
#     #Adjust for key covariates
#     m1 <- as.formula(paste0(gene," ~ medication + age + sex + bmi + (1 | kit_id)"))
#     model1 <- lmer(m1,data=data_subset)
#     
#     # Compute estimated marginal means
#     # emm <- emmeans(model1, ~ medication, pbkrtest.limit = 19037)
#     emm <- emmeans(model1, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
#     
#     # Define and test the contrasts
#     contrast_results  <- contrast(emm, list(
#       "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
#       "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
#       "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
#       "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
#       "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
#     ))
#     
#     contrast_p <-  as.data.frame(summary(contrast_results))
#     contrast_summary <- confint(contrast_results)
#     contrast_df <- as.data.frame(contrast_summary)
#     contrast_df$PValue <- contrast_p$p.value
#     contrast_df$Gene <- gene
#     
#     # # Plot the pairwise comparisons with ggplot
#     # ggplot(contrast_df, aes(x = contrast, y = estimate, ymin = lower.CL, ymax = upper.CL)) +
#     #   geom_pointrange(color = "blue", size = 1.5) +  # Points with confidence intervals
#     #   geom_hline(yintercept = 0, linetype = "dashed", color = "red") +  # Line at 0 (no difference)
#     #   theme_minimal() +  # Minimal theme
#     #   labs(
#     #     title = "Pairwise Comparisons of Medication Groups",
#     #     x = "Contrast",
#     #     y = "Estimated Difference (Log2FC)",
#     #     caption = "Red dashed line represents no difference (Estimate = 0)"
#     #   ) +
#     #   theme(
#     #     axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
#     #     plot.title = element_text(hjust = 0.5)  # Center title
#     #   )
#     
#     
#     # beta <- round(summary(model)$coef[2,1],3)
#     # pval <-round(summary(model)$coef[2,5],5)
#     beta1 <- round(summary(model1)$coef[2,1],3)
#     pval1 <-round(summary(model1)$coef[2,5],5)
#     se <- round(summary(model1)$coef[2,2],5)
#     df <- round(summary(model1)$coef[2,3],5)
#     lowerci <- round(summary(model1)$coef[2,1] - 1.96*se,5)
#     upperci <- round(summary(model1)$coef[2,1] + 1.96*se,5)
#     result <- data.frame(contrast="Overall", estimate=beta1, SE=se,df=df,lower.CL=lowerci, upper.CL=upperci, PValue=pval1,Gene=gene  )
#     result2 <- rbind(result,contrast_df)
#     full_results <- rbind(full_results,result2)
#   }
# }
# # #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### ii. PT-S1/2
```{r}
#PT-S1/2
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S1/S2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ medication + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # Compute estimated marginal means
    emm <- emmeans(model1, ~ medication)
    
    # Define and test the contrasts
    contrast(emm, list(
      "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
      "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
      "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
      "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
      "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
    ))
    
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. PT-S3
```{r}
#PT-S3
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S3")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    if (sum(data_subset[[gene]])>0) {
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
      
    } else {
      beta1 <- NA
      pval1 <-NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1) 
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# write.csv(full_results,fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "red",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "blue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
#
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S3 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  ylim(0, 40) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, 
                  max.overlaps = 20, min.segment.length = 0) 

pdf(fs::path(dir.results,"Plot2_PT_S3_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. aPT
```{r}
#aPT
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aPT")
# genes <- rownames(so_celltype)[1:10]
# so_subset <- subset(so_celltype,features=genes)
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))

write.csv(full_results,fs::path(dir.results,"aPT_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.3 & full_results$Beta > 0, "salmon",
                             ifelse(full_results$fdr < 0.3 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.3, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "aPT Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.3"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_aPT_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```

