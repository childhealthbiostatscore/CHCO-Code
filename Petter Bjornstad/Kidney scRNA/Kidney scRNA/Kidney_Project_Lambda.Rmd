---
title: "Kidney_Project"
author: "Hailey Hampson"
date: "2025-02-25"
output:
  word_document: default
  pdf_document: default
  html_document: default
  output_dir: "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Kidney scRNAseq Project/Results"
---

# 1. Set up 
## a. Libraries & Directores
```{r, include=F}
library(reprex)
# library(tidyverse)
library(BiocManager)        
library(arsenal)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(Seurat)
library(future)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(venn)
library(rstatix)
library(table1)
# BiocManager::install("Biobase")
library(Biobase)
# BiocManager::install("ReactomeGSA")
library(ReactomeGSA)
# BiocManager::install("GSEABase")
library(GSEABase)
# install.packages('msigdbdf', repos = 'https://igordot.r-universe.dev')
library(msigdbr)
# library(kableExtra)
library(knitr)
# BiocManager::install("SingleCellExperiment")
library(SingleCellExperiment)
# BiocManager::install("fgsea")
library(fgsea)
# BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)
library(openxlsx)
library(BiocManager)
# library(MAST)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(openxlsx)
library(ggplot2)
library(GGally)
library(GSEABase)
# library(limma)
library(reshape2)
library(data.table)
library(knitr)
# BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
# library(NMF)
library(rsvd)
library(RColorBrewer)
# BiocManager::install("devtools")
# library(devtools)
# install_github("Sun-lab/ideas",force=T)
# library(ideas)
library(foreach)
library(doRNG)
library(doParallel)
library(fs)
library(future)
# registerDoParallel(cores = 6)
library(VennDiagram)
#install.packages("survival")
library(survival)
#install.packages("lme4")  # If not already installed
library(lme4)
#install.packages("lmerTest")
library(lmerTest)
# install.packages("emmeans")
library(emmeans)
# install.packages("glmmTMB")
library(glmmTMB)
library(ggrepel)
# library(qpcR)
library(ggpubr)
#install.packages("glmmTMB")
# Reinstall glmmTMB from source
#install.packages("glmmTMB", type = "source")
# library(glmmTMB)
# Install DoubletFinder (if not already installed)
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# Load the package
# Install DoubletFinder from GitHub (use devtools to install)
# if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# library(DoubletFinder)
# install.packages("emmeans")
library(emmeans)
library(ggrepel)
# BiocManager::install("enrichplot")
# library(enrichplot)
library(enrichR)
dbs <- c("GO_Biological_Process_2023", 
         "KEGG_2021_Human",
         # "Reactome_2022", 
         "Reactome_Pathways_2024",
         # "MSigDB_Oncogenic_Signatures",
         # "MSigDB_Computational",
         "MSigDB_Hallmark_2020")


#Set number of cores for parallellization
#maxCores <- detectCores()
#numCores <- maxCores-1
#cl <- makeCluster(numCores)  # Create a cluster with the desired number of cores
#registerDoParallel(cl) 

#Local file path
#dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
#dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
#dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
#dir.results <- c("/Volumes/Peds Endo/Petter Bjornstad/Kidney Project/Results")

# #Lambda file path
# dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
# dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Kidney scRNA/Kidney scRNA")
# dir.results <- c(fs::path(dir.dat,"Kidney Project/Results"))

# #Mac Studio File Path
# dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
# dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Kidney scRNAseq Project/Results")
# dir.ipa <- c("/Users/hhampson/Documents/IPA/Results")

#Load functions
source("Kidney_functions_sc.R")
# source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")
dir.results <- c("/home/hailey/Documents/Results")
dir.results2 <- c("/home/hailey/Documents/Results/New")

```

## b. Cyberduck 
```{r, Cyberduck setup}
# knitr::opts_knit$set(root.dir = dir.results)
# install.packages("reticulate")
# Sys.setenv(RETICULATE_PYTHON = "/home/hailey/miniconda3/envs/py310_env/bin/python")
library(reticulate)
reticulate::py_config()
# library(reticulate)
# reticulate::use_condaenv("py310_env", required = TRUE)
# reticulate::py_config()
# Sys.setenv(LD_LIBRARY_PATH = "/usr/lib/x86_64-linux-gnu")
# reticulate::use_python("/home/hailey/miniconda3/bin/python")
# reticulate::use_condaenv("base", required = TRUE)

## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
# install.packages("jsonlite")  # Install if not already installed
library(jsonlite)  # Load the package

keys <- fromJSON("/home/hailey/keys.json") # replace with your Lambda username
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```

# 2. Quality Control & Preprocessing
## a. Load Kidney scRNA seq Data
```{r, include=F}
#Load PB90 with new KPMP Cell Types
#Mac Studio pathway
# so_kpmp_sc <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/scRNA/data_raw/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds")

#Lambda Pathway
invisible(gc())
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".rds") # need to create a temporary file
s3$download_file(bucket, "Kidney transcriptomics/Single cell RNA seq/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds", temp_file)
so_kpmp_sc <- readRDS(temp_file)
invisible(gc())
```

## b. Data Cleaning, QC & Preprocessing
```{r, echo=F, warning=F, fig.width=15, fig.height=15}
#Fix Typos in kit ids in PB90
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="KI-0014643")] <- "KL-0014643"
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="kl-0023998")] <- "KL-0023998"

#Load harmonized data that has been filtered from 90 to the 83 participants that have baseline single cell data
# harm_meta_data <- read.csv(fs::path(dir.dat,"Kidney scRNAseq Project","Data","harmonized_data_kidney_sc_all_metadata2.csv"))
invisible(gc())
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".csv") # need to create a temporary file
s3$download_file(bucket, "data_clean/harmonized_data_kidney_sc_all_metadata2.csv", temp_file)
harm_meta_data <- read.csv(temp_file)
invisible(gc())

harm_meta_data <- harm_meta_data %>%
  dplyr::select(-X)

#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  so_kpmp_sc@meta.data
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(harm_meta_data,by="kit_id")
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Pull ids from 83 participants at baseline to filter seurat object to these participants only 
ids <- harm_meta_data$kit_id

#Merge metadata back into seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)

#Check number of unique ids
length(unique(so_kpmp_sc$kit_id)) #should be 90

#Filter seurat object to only IDs that have the metadata & sc data (83 individuals at baseline)
so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)

#Check number of unique ids after filtering
length(unique(so_kpmp_sc$kit_id)) #should be 83

#Remove metadatasets
rm(meta_kidney_sc,harm_meta_data)

#Remove two coenrolled IDs
so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0030621")
so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#Check unique number of kit ids now (should be 81)
length(unique(so_kpmp_sc$kit_id)) #Should be 81

#Load in most up to date medication data to update medication information
# med <- read.xlsx(fs::path(dir.dat,"Kidney scRNAseq Project/Data/Biopsies_w_mrn_Oct3.xlsx"))
invisible(gc())
bucket <- "scrna" # bucket name in Kopah
temp_file <- tempfile(fileext = ".xlsx") # need to create a temporary file
s3$download_file(bucket, "data_clean/Biopsies_w_mrn_Oct3.xlsx", temp_file)
med <- read.xlsx(temp_file)
invisible(gc())
rm(s3,session,keys)

#Select Metformin, RASSI, Insulin data
med <- med %>%
  dplyr::select(all_of(c("record_id","mrn","raasi_1","insulin_1","mfm_1")))
#Pull seurat object metadata to help harmoinize in new metadata
meta_kidney_sc <-  so_kpmp_sc@meta.data
#Filter to only those with a unique identifier id in the seurat object metadata
med <- med %>%
  filter(mrn %in% as.character(meta_kidney_sc$mrn)) 
length(unique(med$mrn)) #95 total rows remain, 81 unique individual ids
#Filter to only those that have a unique record id in the seurat object
med <- med %>%
  filter(record_id %in% meta_kidney_sc$record_id) 
length(unique(med$mrn)) #81 remain
length(unique(med$record_id)) #81
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
med$mrn <- as.numeric(med$mrn) #Make numeric to merge
#Merge med data with seurat metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(med,by=c("mrn","record_id"))
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
length(unique(meta_kidney_sc$mrn)) #81 remain
length(unique(meta_kidney_sc$record_id)) #81

#Add Med Meta Data to Seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
#Remove med metadatset
rm(med,meta_kidney_sc)

#Create medication & disease status groups of interest
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)
invisible(gc())
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
so_kpmp_sc@meta.data$medication <- factor(so_kpmp_sc@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))

#Ensure default assay in seurat object to RNA
DefaultAssay(so_kpmp_sc) <- "RNA"
invisible(gc())

#Before filtering
ncol(so_kpmp_sc)
#186125 cells
nrow(so_kpmp_sc)
#31332 genes

#YE JI's filtering code for percent expression 
#Filter out rare genes expressed in less than "gene_pct" of cells
# expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, layer = "counts"))
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, assay = "RNA", layer = "counts"))
# expr_matrix <- so_kpmp_sc@assays$RNA@counts
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.01])
so_kpmp_sc <- subset(so_kpmp_sc, features = genes_to_keep)
#After filtering
ncol(so_kpmp_sc) #186125 nuclei
nrow(so_kpmp_sc) # 14627 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_kpmp_sc), value = TRUE)
# mito_genes2 <- grep("^MT.", rownames(so_kpmp_sc), value = TRUE)
#Filter out all mitochondrial genes

#keep_ids <- unique(rownames(so_kpmp_sc)[which(!rownames(so_kpmp_sc) %in% mito_genes)])
# so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#so_kpmp_sc$Gene <- rownames(so_kpmp_sc)
#so_kpmp_sc <- subset(so_kpmp_sc, Gene %in% keep_ids)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
#so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc@assays$RNA@counts), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc, !rownames(so_kpmp_sc) %in% mito_genes)
# grep("^MT-", rownames(so_kpmp_sc@assays$RNA@counts), value = TRUE)
# dim(so_kpmp_sc@assays$RNA@counts) #9276 186125
# dim(so_kpmp_sc@assays$RNA@data) #9276 186125
# dim(so_kpmp_sc@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
rownames(so_kpmp_sc)[(grepl("^MT", rownames(so_kpmp_sc)))] #0
ncol(so_kpmp_sc) #186125 cells
nrow(so_kpmp_sc) #14614 genes

#Renormalize & Scale after filtering
so_kpmp_sc <- NormalizeData(so_kpmp_sc)
so_kpmp_sc <- ScaleData(so_kpmp_sc, features = VariableFeatures(so_kpmp_sc))

#Create general hepatocyte cell type variable
#Create PT and TAL pseudobulk cell type variable
so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
                                  grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
                                  grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
                                  grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
                                  grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
                                  grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
                                  grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
                                  grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
                                  grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
                                  so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
                                  so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
                                  so_kpmp_sc$celltype_rpca=="B"~"B",
                                  so_kpmp_sc$celltype_rpca=="T"~"T")
so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)

so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
                                 so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
                                 so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
                               ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                      ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))
# so_kpmp_sc$celltype2 <- factor(so_kpmp_sc$celltype2)
```

## c. Visualizations 
```{r}
# PCA
so_kpmp_sc <- FindVariableFeatures(object = so_kpmp_sc)
so_kpmp_sc <- RunPCA(so_kpmp_sc, features = VariableFeatures(object = so_kpmp_sc),assay="RNA")
ElbowPlot(so_kpmp_sc)

# # Find neighbors and clusters (again using integrated data)
so_kpmp_sc <- FindNeighbors(so_kpmp_sc, assay = "RNA", dims = 1:20)
so_kpmp_sc <- FindClusters(so_kpmp_sc, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
so_kpmp_sc@reductions
DimPlot(so_kpmp_sc, reduction = "umap.harmony", raster = F)
DimPlot(so_kpmp_sc, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)
DimPlot(so_kpmp_sc, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

so_kpmp_sc$group <- factor(so_kpmp_sc$group)
DimPlot(so_kpmp_sc, reduction = "umap",group.by = "steatosis_cat",label=F,raster=F) +
  ggtitle(paste0("UMAP by Steatosis Category"))

so_kpmp_sc$fibrosis_cat <- factor(so_kpmp_sc$fibrosis_cat)
DimPlot(so_kpmp_sc, reduction = "umap",group.by = "fibrosis_cat",label=F,raster=F) +
  ggtitle(paste0("UMAP by Fibrosis Category"))


#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "PT")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>% 
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "TAL")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1

#T2D only compare med groups
so_NoMed <- subset(so_kpmp_sc, group=="Type_2_Diabetes" | group=="Lean_Control")
so_NoMed <- subset(so_NoMed,medication="no_med")
# PCA
so_T2D <- FindVariableFeatures(object = so_T2D)
so_T2D <- RunPCA(so_T2D, features = VariableFeatures(object = so_T2D),assay="RNA")
ElbowPlot(so_T2D)

# # Find neighbors and clusters (again using integrated data)
so_T2D <- FindNeighbors(so_T2D, assay = "RNA", dims = 1:20)
so_T2D <- FindClusters(so_T2D, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
so_T2D@reductions
DimPlot(so_T2D, reduction = "umap.harmony", raster = F)
DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)
DimPlot(so_T2D, reduction = "umap", group.by = "celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

so_T2D$group <- factor(so_T2D$group)
DimPlot(so_T2D, reduction = "umap",group.by = "steatosis_cat",label=F,raster=F) +
  ggtitle(paste0("UMAP by Steatosis Category"))

so_T2D$fibrosis_cat <- factor(so_T2D$fibrosis_cat)
DimPlot(so_T2D, reduction = "umap",group.by = "fibrosis_cat",label=F,raster=F) +
  ggtitle(paste0("UMAP by Fibrosis Category"))


#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "PT")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>% 
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "TAL")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1


#T2D only compare med groups
so_T2D <- subset(so_kpmp_sc, group=="Type_2_Diabetes")
# PCA
so_T2D <- FindVariableFeatures(object = so_T2D)
so_T2D <- RunPCA(so_T2D, features = VariableFeatures(object = so_T2D),assay="RNA")
ElbowPlot(so_T2D)

# # Find neighbors and clusters (again using integrated data)
so_T2D <- FindNeighbors(so_T2D, assay = "RNA", dims = 1:20)
so_T2D <- FindClusters(so_T2D, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
so_T2D@reductions
DimPlot(so_T2D, reduction = "umap.harmony", raster = F)
DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)
DimPlot(so_T2D, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP among Type 2 Diabetes")

so_T2D$medication <- factor(so_T2D$medication)
DimPlot(so_T2D, reduction = "umap.harmony",group.by = "medication",label=F,raster=F) +
  ggtitle(paste0("UMAP by Medication Status"))


#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "PT")

label(cellcount$medication) <- "Medication Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$medication <- ifelse(cellcount$medication=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$medication <- factor(cellcount$medication,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
# cellcount <- cellcount %>% 
#   filter(medication!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(medication, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of PT Cell Subtypes by Medication Status in T2D") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(celltype2 == "TAL")

label(cellcount$medication) <- "Medication Status"

prop_plot1 <- ggplot(data=cellcount,aes(medication, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of TAL Cell Subtypes by Medication Status in T2D") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_T2D@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))
label(cellcount$medication) <- "Medication Status"

prop_plot1 <- ggplot(data=cellcount,aes(medication, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of EC Cell Subtypes by Medication Status in T2D") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 

```

## d. Descriptive Statistics
```{r, echo = F,warning=F}
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  group_by(record_id) %>%
  summarise(across(everything(), first)) %>%
  ungroup() 

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)

#Table 1. 
table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| study, data=dat)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| study, data=dat)
table1(~ age + sex + bmi + triglycerides + hba1c + medication| group, data=dat)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| group, data=dat)

dat1 <- dat %>% 
  filter(medication=="no_med") %>% 
  filter(group=="Lean_Control" | group=="Type_2_Diabetes")
table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| study, data=dat1)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| study, data=dat1)
table1(~ age + sex + bmi + triglycerides + hba1c + medication| group, data=dat1)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| group, data=dat1)

#No Med only
ggplot(dat1, aes(x = group, y = age)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=group),color="black")+
  labs(title = "Age by Diabetes Group",
       x = "Group",
       y = "Age") +
  theme_minimal()


#T2D only
dat2 <- dat %>% 
  filter(group=="Type_2_Diabetes")
table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| study, data=dat2)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| study, data=dat2)
table1(~ age + sex + bmi + triglycerides + hba1c | medication, data=dat2)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| medication, data=dat2)

ggplot(dat2, aes(x = medication, y = age)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "Age by Medication Group among T2D",
       x = "Medication",
       y = "Age") +
  theme_minimal()

ggplot(dat2, aes(x = medication, y = bmi)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "BMI by Medication Group among T2D",
       x = "Medication",
       y = "BMI") +
  theme_minimal()

ggplot(dat2, aes(x = medication, y = triglycerides)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "Triglycerides by Medication Group among T2D",
       x = "Medication",
       y = "Triglycerides") +
  theme_minimal()

#ACRu
ggplot(dat2, aes(x = medication, y = acr_u)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "ACRu by Medication Group among T2D",
       x = "Medication",
       y = "ACRu") +
  theme_minimal()

#eGFR_CKD_epi
ggplot(dat2, aes(x = medication, y = eGFR_CKD_epi)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "eGFR by Medication Group among T2D",
       x = "Medication",
       y = "eGFR") +
  theme_minimal()

#pah_clear_bsa
ggplot(dat2, aes(x = medication, y = pah_clear_bsa)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "PAH Clearance (BSA) by Medication Group among T2D",
       x = "Medication",
       y = "PAH Clearance (BSA)") +
  theme_minimal()

#gfr_bsa_plasma
ggplot(dat2, aes(x = medication, y = gfr_bsa_plasma)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "GFR (BSA Plasma) by Medication Group among T2D",
       x = "Medication",
       y = "GFR (BSA Plasma)") +
  theme_minimal()

#HbA1c
ggplot(dat2, aes(x = medication, y = hba1c)) +
  # geom_boxplot(fill = "skyblue", color = "darkblue") +
  geom_boxplot(aes(fill=medication),color="black")+
  labs(title = "HbA1c (%) by Medication Group among T2D",
       x = "Medication",
       y = "HbA1c (%)") +
  theme_minimal()
```

# 3. Comparitive Data Analysis
## A. Type 2 Diabetes (No Med) vs. Healthy Controls
### a. PT Cells
#### i. Pseudobulk PT cells
```{r}
#PT
so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

#Try as batch loop
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"PT_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"PT_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv")) %>% 
#   dplyr::select(-X)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
max <- max(significant_df$Beta,na.rm=T)
min <- min(significant_df$Beta,na.rm=T)


# full_results$Log2FC <- 2^(full_results$Beta)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "PT Cells, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_PT_Cells_T2D_LC_NoMed.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
##### GSEA
```{r echo = F}
#PT
full_results <- read.csv(fs::path(dir.results,"PT_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv")) %>% 
  dplyr::select(-X)
sig_pos <- full_results %>% 
  filter(Beta>0 & fdr<0.05)
sig_neg <- full_results %>% 
  filter(Beta<0 & fdr<0.05)

#Run postive enricher analysis 
sig_pos_en <- enrichr(as.character(sig_pos$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[1]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_pos_en_df <- as.data.frame(sig_pos_en[[2]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - Kegg")
# plotEnrich(as.data.frame(sig_pos_en[[2]]), title = "Model 1 Positive Hepatocytes - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Positive Hepatocytes - Reactome '22")
# # plotEnrich(as.data.frame(sig_pos_en[[3]]), title = "Model 1 Positive Hepatocytes - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[3]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hepatocytes - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_pos_en_df <- as.data.frame(sig_pos_en[[5]])
# # Extract the number of overlapping genes
# sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Positive Hepatocytes - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hepatocytes - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_pos_en_df <- as.data.frame(sig_pos_en[[4]])
# Extract the number of overlapping genes
sig_pos_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_pos_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_pos_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Positive Hepatocytes - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_pos_en[[4]]), title = "Model 1 Positive Hepatocytes - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# Arrange 6 plots in 3 rows x 2 columns
combined_plot <- (p1 | p2) / 
  (p3 | p4) 

# Display or save the plot
figure <- combined_plot + 
  plot_annotation(
    title = "Positive Gene Set Enrichment Analysis",
    subtitle = "T2D vs. Lean Controls in PT cells, No Medications",
    theme = theme(
      plot.title = element_text(
        hjust = 0,         # Center title
        size = 18,           # Bigger font
        face = "bold"        # Bold text
      )
    )
  )

ggsave(fs::path(dir.results2, "Positive_PT_T2D_LC_gsea_figure_no_med.jpeg"), figure, width = 18, height = 10)
rm(p1,p2,p3,p4)
#Run negative enricher analysis 
sig_neg_en <- enrichr(as.character(sig_neg$Gene), dbs)
#Plot results
# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[1]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - GO")
p1 <- plotEnrich(filtered_results, title = "GO")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_go.jpeg"),width=10,height=7)

# Convert enrichment results to a dataframe
sig_neg_en_df <- as.data.frame(sig_neg_en[[2]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
p2 <- plotEnrich(filtered_results, title = "KEGG")
# plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - Kegg")
# plotEnrich(as.data.frame(sig_neg_en[[2]]), title = "Model 1 Negative Hepatocytes - Kegg")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_kegg.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# # plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - Reactome '22")
# p3 <- plotEnrich(filtered_results, title = "Negative Hepatocytes - Reactome '22")
# # plotEnrich(as.data.frame(sig_neg_en[[3]]), title = "Model 1 Negative Hepatocytes - Reactome '22")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome22.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[3]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - Reactome '24")
p3 <- plotEnrich(filtered_results, title = "Reactome '24")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hepatocytes - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

# sig_neg_en_df <- as.data.frame(sig_neg_en[[5]])
# # Extract the number of overlapping genes
# sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# # Filter pathways with at least 3 overlapping genes
# filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# # Plot the filtered results
# p5 <- plotEnrich(filtered_results, title = "Negative Hepatocytes - MsigDB Computational")
# # plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - MsigDB Computational")
# # plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hepatocytes - Reactome '24")
# # ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)

sig_neg_en_df <- as.data.frame(sig_neg_en[[4]])
# Extract the number of overlapping genes
sig_neg_en_df$Num_Genes <- as.numeric(sub("/.*", "", sig_neg_en_df$Overlap))
# Filter pathways with at least 3 overlapping genes
filtered_results <- subset(sig_neg_en_df, Num_Genes >= 3)
# Plot the filtered results
# plotEnrich(filtered_results, title = "Model 1 Negative Hepatocytes - MsigDB Hallmark '20")
# plotEnrich(as.data.frame(sig_neg_en[[4]]), title = "Model 1 Negative Hepatocytes - Reactome '24")
# ggsave(fs::path(dir.results,"All_Cell_Types_pos_gsea_reactome24.jpeg"),width=10,height=7)
p4 <- plotEnrich(filtered_results, title = "MsigDB '20")

# Arrange 6 plots in 3 rows x 2 columns
combined_plot <- (p1 | p2) / 
  (p3 | p4) 

# Display or save the plot
figure <- combined_plot + 
  plot_annotation(
    title = "Negative Gene Set Enrichment Analysis",
    subtitle = "T2D vs. Lean Controls in PT cells, No Medication",
    theme = theme(
      plot.title = element_text(
        hjust = 0,         # Center title
        size = 18,           # Bigger font
        face = "bold"        # Bold text
      )
    )
  )

ggsave(fs::path(dir.results2, "Negative_PT_S1_S2_T2D_LC_gsea_figure_full_cov_set.jpeg"), figure, width = 18, height = 10)
```

#### ii. PT-S1/2
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="PT-S1/S2")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"PT_S1S2_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"PT_S1S2_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))

NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "PT-S1/S2, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_PT_S1S2_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iii. PT-S3
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="PT-S3")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"PT_S3_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))

NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "PT-S3, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_PT_S3_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iv. aPT
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="aPT")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)


rm(all_results, final_results,full_results,significant_df,vol)
# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# # full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"aPT_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"aPT_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "aPT, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_aPT_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```

### b. EC Cells
#### i Pseudobulk EC
```{r}
#EC
so_celltype <- subset(so_kpmp_sc,celltype1=="EC")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

#Try as batch loop
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)

# write.csv(full_results,"test.csv")

write.csv(full_results,fs::path(dir.results,"EC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
full_results <- read.csv(fs::path(dir.results,"EC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
max <- max(significant_df$Beta,na.rm=T)
min <- min(significant_df$Beta,na.rm=T)


# full_results$Log2FC <- 2^(full_results$Beta)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC Cells, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_EC_Cells_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### ii. EC-AVR
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AVR")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"EC_GC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
full_results <- read.csv(fs::path(dir.results,"EC_GC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AVR, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results2,"Plot_EC_GC_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iii. EC-GC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-GC")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

write.csv(full_results,fs::path(dir.results,"EC_GC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-GC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_GC_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iv. EC-PTC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-PTC")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"EC_PTC_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-PTC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_PTC_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### v. EC-AEA
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AEA")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"EC_AEA_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AEA, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_AEA_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```

#### vi. EC-LYM
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AEA")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"EC_AEA_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AEA, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_AEA_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### vii. EC/VSMC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AEA")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"EC_AEA_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "EC-AEA, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_AEA_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
### c. TAL
```{r}
#TAL
so_celltype <- subset(so_kpmp_sc,celltype1=="TAL")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

#Try as batch loop
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# write.csv(full_results,"test.csv")

write.csv(full_results,fs::path(dir.results,"TAL_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)
max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# full_results$Log2FC <- 2^(full_results$Beta)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "TAL Cells, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_TAL_Cells_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### i. C-TAL-1 
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="C-TAL-1")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"EC-AVR_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "C-TAL-1, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-AVR_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### ii. C-TAL-2
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="C-TAL-2")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(full_results$Gene))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"dTAL_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "C-TAL-2, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_dTAL_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iii. dTAL
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="dTAL")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"dTAL_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "dTAL, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_dTAL_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```
#### iv. aTAL
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="aTAL")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# Parameters
batch_size <- 2000
# total_cores <- 50

# Deduplicate genes
gene_list_total <- unique(gene_list_total)

# Split into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Function to process a single gene
process_gene <- function(gene, data_subset) {
  tryCatch({
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    
    return(contrast_df)
  }, error = function(e) {
    return(NULL)  # Skip genes that cause errors
  })
}

# Create a cluster
cl <- makeCluster(total_cores)

# Export necessary objects and packages to each worker
clusterExport(cl, varlist = c("data_subset", "process_gene"), envir = environment())
clusterEvalQ(cl, {
  library(lme4)
  library(emmeans)
})

# Flatten results from each batch
all_results <- list()

for (i in seq_along(gene_batches)) {
  cat("Processing batch", i, "of", length(gene_batches), "\n")
  
  # Apply function in parallel across the current batch
  batch_genes <- gene_batches[[i]]
  batch_results <- parLapply(cl, batch_genes, function(g) process_gene(g, data_subset))
  
  # Remove NULLs and bind into a single dataframe
  batch_df <- do.call(rbind, batch_results[!sapply(batch_results, is.null)])
  
  all_results[[i]] <- batch_df
}

# Stop the cluster
stopCluster(cl)

# Combine all batch results
final_results <- do.call(rbind, all_results)

# Preview
head(final_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"aTAL_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "aTAL, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_aTAL_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

# 
```

### d. Podocytes
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="POD")
# so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
rm(data)
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list_total)))

# library(glmmTMB)
# library(lme4)
# library(doParallel)
# library(foreach)
# Set batch size
batch_size <- 2000
total_cores <- 50

# Deduplicate gene list to avoid double-processing
gene_list_total <- unique(gene_list_total)

# Split the gene list into batches
gene_batches <- split(gene_list_total, ceiling(seq_along(gene_list_total) / batch_size))

# Define the function that processes a single gene
process_gene <- function(gene) {
  if (sum(data_subset[[gene]]) > 0) {
    m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
    
    model1 <- tryCatch({
      glmmTMB(m1, data = data_subset, family = gaussian)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model1)) {
      Beta <- summary(model1)$coef$cond[2,1]
      PValue <- summary(model1)$coef$cond[2,4]
    } else {
      Beta <- NA
      PValue <- NA
    }
  } else {
    Beta <- NA
    PValue <- NA
  }
  
  return(data.frame(Gene = gene, Beta = Beta, PValue = PValue))
}

# Set number of cores
total_cores <- parallel::detectCores() - 1

# Initialize and register cluster
cl <- makeCluster(total_cores)
registerDoParallel(cl)

# Run analysis per batch
all_results <- lapply(seq_along(gene_batches), function(batch_idx) {
  batch_genes <- gene_batches[[batch_idx]]
  
  batch_results <- foreach(
    gene = batch_genes,
    .combine = rbind,
    .packages = c("glmmTMB", "lme4"),
    .export = c("process_gene", "data_subset")
  ) %dopar% {
    process_gene(gene)
  }
  
  cat("Processed batch", batch_idx, "with", length(batch_genes), "genes\n")
  return(batch_results)
})

# Stop cluster
stopCluster(cl)

# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)

# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")


write.csv(full_results,fs::path(dir.results,"POD_Cells_No_Med_T2D_LC_adj_cov_lmm_no_zi.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$Beta,na.rm=T)
min <- min(full_results$Beta,na.rm=T)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls (All No Medication)",
    subtitle = "POD, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_POD_T2D_LC_NoMed_lmm_no_zi.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()

```

## B. Medication Status - Type 2 Diabetes Only
### i. All PT Cells - Pseudobulk 
```{r}
so_celltype <- subset(so_kpmp_sc,celltype1=="PT")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total[1:5000]  # Assuming gene_hold is your full list of genes
# genes <- gene_list_total[which(!gene_list_total %in% results2$Gene)]
# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
#results1 <- final_results
# final_results <- rbind(final_results,results2)
rm(results2)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"All_PT_Cells_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

# Stop the parallel cluster
stopCluster(cl)
Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")
rm(data_subset,cl,all_results)

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "PT Cells, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_PT_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()
```
#### ii. PT-S1/2
```{r}
#PT-S1/S2
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="PT-S1/S2")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total
# genes <- gene_list_total[9000:14627]  # Assuming gene_hold is your full list of genes
# genes <- gene_list_total[which(!gene_list_total %in% results2$Gene)]
# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# chunks19 <- final_results
# results2 <- rbind(results2,final_results)
# final_results <- results2
# rm(results2)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"PT_S1_S2_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))

# Stop the parallel cluster
stopCluster(cl)

# full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")
rm(data_subset,cl,all_results)

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "PT-S1/S2, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```
#### iii. PT-S3
```{r}
#PT-S3
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="PT-S3")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"PT_S3_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "PT-S3, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_PT_S3_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()
```
#### iv. aPT
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="aPT")
ncol(so_celltype) #9052 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"aPT_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"aPT_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "aPT, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_aPT_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```
###ii. TAL
```{r}
so_celltype <- subset(so_kpmp_sc,celltype1=="TAL")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes
# genes <- gene_list_total[which(!gene_list_total %in% results2$Gene)]
# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
#results2 <- final_results
# final_results <- rbind(final_results,results2)
# rm(results2)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"All_TAL_Cells_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

# Stop the parallel cluster
stopCluster(cl)
Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")
rm(data_subset,cl,all_results)

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "TAL, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()
```
####i. C-TAL-1
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="C-TAL-1")
ncol(so_celltype) #9052 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    # formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    formula <- as.formula(paste0(gene, " ~ medication + (1 | kit_id)"))
    
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"C-TAL-1_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"C-TAL-1_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

Nonconvergence_Rate <- paste0(round((1-(length(unique(final_results$Gene))/length(gene_list_total)))*100,3),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "C-TAL-1, Crude",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_C-TAL-1_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```
####ii. C-TAL-2
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="C-TAL-2")
ncol(so_celltype) #9052 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
length(unique(final_results$Gene))
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"C-TAL-2_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"C-TAL-2_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")
# Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "C-TAL-2, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_C-TAL-2_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

####iii. dTAL
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="dTAL")
ncol(so_celltype) #9052 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"dTAL_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"dTAL_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "dTAL, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_dTAL_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```
####iv. aTAL
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="aTAL")
ncol(so_celltype) #9052 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"aTAL_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"aTAL_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "aTAL, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_aTAL_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

###iii. EC
```{r}
so_celltype <- subset(so_kpmp_sc,celltype1=="EC")
ncol(so_celltype) #37948 cells
nrow(so_celltype) #14627 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes
# genes <- gene_list_total[which(!gene_list_total %in% results2$Gene)]
# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
#results2 <- final_results
# final_results <- rbind(final_results,results2)
# rm(results2)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"All_EC_Cells_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))

# Stop the parallel cluster
stopCluster(cl)
Nonconvergence_Rate <- paste0(round((1-length(unique(final_results$Gene))/length(gene_list_total))*100,3),"%")
rm(data_subset,cl,all_results)

#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()
```
####i. EC-AVR
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AVR")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_GC_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC-AVR_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC-AVR, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-AVR_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```
####ii. EC-GC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-GC")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_GC_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC-GC_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC-GC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-GC_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

####iii. EC-PTC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-PTC")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_PTC_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC-PTC_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC-PTC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-PTC_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

####iii. EC-AEA
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-AEA")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_AEA_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC-AEA_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC-AEA, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-AEA_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

####iii. EC-LYM
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC-LYM")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_VSMC_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC-LYM_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC-LYM, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC-LYM_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```

####iii. EC/VSMC
```{r}
so_celltype <- subset(so_kpmp_sc,KPMP_celltype2=="EC/VSMC")
ncol(so_celltype) #3262 cells
nrow(so_celltype) #14614 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","medication","group","age","sex","bmi",all_of(gene_list_total)))
rm(data)
gc()
# rm(so_celltype)

# Define your function for processing a gene
process_gene <- function(gene) {
  # Use tryCatch to handle errors
  result <- tryCatch({
    # Define the formula for the linear mixed-effects model
    formula <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    
    # Fit the model
    model <- suppressWarnings(lmer(formula, data = data_subset))
    
    # Compute emmeans
    emm <- emmeans(model, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define the contrasts to test
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med"        = c(0, 1, 0, -1),
      "SGT2 vs No Med"        = c(0, 0, 1, -1),
      "GLP1+SGT2 vs No Med"   = c(0, 0, 0, 1),
      "GLP1+SGT2 vs GLP1"     = c(0, -1, 1, 0),
      "GLP1+SGT2 vs SGT2"     = c(0, 0, -1, 1)
    ))
    
    # Convert the contrast results to a data frame and add PValue and Gene columns
    contrast_df <- as.data.frame(confint(contrast_results))
    contrast_df$PValue <- summary(contrast_results)$p.value
    contrast_df$Gene <- gene
    contrast_df <- as.data.frame(contrast_df)
    
    return(contrast_df)
  }, error = function(e) {
    # If there's an error, return NULL and print the error message
    message(paste("Error processing gene:", gene, "\n", e))
    return(NULL)  # Return NULL if an error occurs
  })
  
  return(result)
}

# Set up parallel backend (use maximum available cores)
num_cores <- detectCores() - 1  # Reserve one core for the system, adjust as needed
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# List of genes to process
genes <- gene_list_total  # Assuming gene_hold is your full list of genes

# Process genes in chunks of 1000
chunk_size <- 1000
num_chunks <- ceiling(length(genes) / chunk_size)

# Initialize an empty list to store all results
all_results <- list()

# Loop over each chunk
for (i in 1:num_chunks) {
  # Determine the start and end indices for the current chunk
  start_idx <- ((i - 1) * chunk_size) + 1
  end_idx <- min(i * chunk_size, length(genes))
  
  # Get the current chunk of genes
  current_genes <- genes[start_idx:end_idx]
  
  # Run the analysis for this chunk in parallel
  chunk_results <- foreach(gene = current_genes, .combine = rbind, .packages = c("lme4", "emmeans", "dplyr")) %dopar% {
    process_gene(gene)
  }
  
  # Remove any NULL results (in case of errors)
  chunk_results <- chunk_results[!sapply(chunk_results, is.null), ]
  
  # Add the results of the current chunk to the list of all results
  all_results[[i]] <- chunk_results
  
  # Save the current chunk's results to a CSV file
  # write.csv(chunk_results, file = fs::path(dir.results,paste0("Full_results_chunk_", i, "_04_07_2025.csv")))
  
  # Optionally, print progress
  cat("Finished chunk", i, "out of", num_chunks, "\n")
}

# Combine all chunks into a single data frame
final_results <- do.call(rbind, all_results)
# Stop the parallel cluster
stopCluster(cl)
# Save the final combined results
write.csv(final_results, file = fs::path(dir.results,"EC_VSMC_T2D_Medication_Full_results_all_genes_04_14_2025.csv"))
# final_results <- read.csv(fs::path(dir.results,"EC/VSMC_T2D_Medication_Full_results_all_genes_04_07_2025.csv"))
#Visulaize the results
# #Make volcano plot of all gene results for group
full_results <- final_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
NaN_genes <- full_results$Gene[which(full_results$PValue=="NaN")] #THe NaN genes,4367
NA_genes <- full_results$Gene[which(is.na(full_results$PValue))] #The NA genes,5722
Nonconvergence_Rate <- paste0(round((length(unique(NA_genes,NaN_genes))/length(gene_list_total))*100,1),"%")

# group_by(contrast) %>% 
# mutate(fdr=p.adjust(PValue,method="fdr"))  %>% 
# ungroup()
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$estimate > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$estimate < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)

#Figure Range
# max <- max(significant_df$Beta,na.rm=T)
# min <- min(significant_df$Beta,na.rm=T)

max <- max(full_results$estimate,na.rm=T)
min <- min(full_results$estimate,na.rm=T)

full_results$contrast <- factor(full_results$contrast)
# Reorder the contrast variable
full_results$contrast <- factor(full_results$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))
significant_df$contrast <- factor(significant_df$contrast, levels = c("GLP1 vs No Med", "SGT2 vs No Med", "GLP1+SGT2 vs No Med","GLP1+SGT2 vs GLP1","GLP1+SGT2 vs SGT2"))

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = estimate, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  facet_wrap(~ contrast, nrow = 2, ncol = 3)+
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Comparison of Medication Status among Youth with T2D",
    subtitle = "EC/VSMC, Adjusted for Age, Sex & BMI",
    x = "Fold Change",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate)
  ) +
  # xlim(min,max)+
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
pdf(fs::path(dir.results,"Plot_EC_VSMC_T2D_Medications_lmm_no_zi.pdf"),width=12,height=10)
print(volcano_plot)
dev.off()

```