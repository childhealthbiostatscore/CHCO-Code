---
title: "Kidney_Project"
author: "Hailey Hampson"
date: "2025-02-25"
output:
  word_document: default
  pdf_document: default
  html_document: default
  output_dir: "/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Kidney scRNAseq Project/Results"
---

# 1. Set up Libraries & Directores
```{r, include=F}
library(reprex)
library(tidyverse)
library(BiocManager)        
library(arsenal)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(Seurat)
library(future)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(venn)
library(rstatix)
library(table1)
library(Biobase)
library(ReactomeGSA)
library(GSEABase)
library(msigdbr)
library(kableExtra)
library(knitr)
library(SingleCellExperiment)
library(fgsea)
library(EnhancedVolcano)
library(openxlsx)
library(BiocManager)
library(MAST)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(openxlsx)
library(ggplot2)
library(GGally)
library(GSEABase)
library(limma)
library(reshape2)
library(data.table)
library(knitr)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
#library(NMF)
library(rsvd)
library(RColorBrewer)
library(MAST)
library(devtools)
# install_github("Sun-lab/ideas",force=T)
#library(ideas)
library(foreach)
library(parallel)
library(doRNG)
library(doParallel)
library(fs)
# registerDoParallel(cores = 6)
library(VennDiagram)
library(janitor)
# devtools::install_github('immunogenomics/presto')
library(presto)
library(knitr)
library(lme4)
library(lmerTest)
#install.packages("glmmTMB")
# Reinstall glmmTMB from source
# install.packages("glmmTMB", type = "source")
library(glmmTMB)
# Install DoubletFinder (if not already installed)
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# Load the package
# Install DoubletFinder from GitHub (use devtools to install)
# if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
library(DoubletFinder)
# install.packages("emmeans")
library(emmeans)


#Set number of cores for parallellization
#maxCores <- detectCores()
#numCores <- maxCores-1
#cl <- makeCluster(numCores)  # Create a cluster with the desired number of cores
#registerDoParallel(cl) 

#Local file path
#dir.dat <- c("/Volumes/Peds Endo/Petter Bjornstad")
#dir.dat2 <- c("/Volumes/Peds Endo/Petter Bjornstad/scRNA/data_clean")
#dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
#dir.results <- c("/Volumes/Peds Endo/Petter Bjornstad/Kidney Project/Results")

# #Lambda file path
# dir.dat <- c("/run/user/1026/gvfs/smb-share:server=ucdenver.pvt,share=som/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad")
# dir.code <- c("/home/Github_Repo/CHCO-Code/Petter Bjornstad/Kidney scRNA/Kidney scRNA")
# dir.results <- c(fs::path(dir.dat,"Kidney Project/Results"))

#Mac Studio File Path
dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Kidney scRNAseq Project/Results")
dir.ipa <- c("/Users/hhampson/Documents/IPA/Results")

#Load functions
source("Kidney_functions_sc.R")
source("/Users/hhampson/CHCO-Code/Petter Bjornstad/Data Processing and Analysis/Standard_Functions.R")
```

# 2. Quality Control & Preprocessing
## a. Load Kidney scRNA seq Data
```{r, include=F}
#Load PB90 with new KPMP Cell Types
#Mac Studio pathway
so_kpmp_sc <- readRDS("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/scRNA/data_raw/PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds")

```

## b. Data Cleaning, QC & Preprocessing
```{r, echo=F, warning=F, fig.width=15, fig.height=15}
#Fix Typos in kit ids in PB90
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="KI-0014643")] <- "KL-0014643"
so_kpmp_sc$kit_id[which(so_kpmp_sc$kit_id=="kl-0023998")] <- "KL-0023998"

#Load harmonized data that has been filtered from 90 to the 83 participants that have baseline single cell data
harm_meta_data <- read.csv(fs::path(dir.dat,"Kidney scRNAseq Project","Data","harmonized_data_kidney_sc_all_metadata2.csv"))%>%
  dplyr::select(-X)

#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  so_kpmp_sc@meta.data
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(harm_meta_data,by="kit_id")
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Pull ids from 83 participants at baseline to filter seurat object to these participants only 
ids <- harm_meta_data$kit_id

#Merge metadata back into seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)

#Check number of unique ids
length(unique(so_kpmp_sc$kit_id)) #should be 90

#Filter seurat object to only IDs that have the metadata & sc data (83 individuals at baseline)
so_kpmp_sc <- subset(so_kpmp_sc, kit_id %in% ids)

#Check number of unique ids after filtering
length(unique(so_kpmp_sc$kit_id)) #should be 83

#Remove metadatasets
rm(meta_kidney_sc,harm_meta_data)

#Remove two coenrolled IDs
so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0030621")
so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#Check unique number of kit ids now (should be 81)
length(unique(so_kpmp_sc$kit_id)) #Should be 81

#Load in most up to date medication data to update medication information
med <- read.xlsx(fs::path(dir.dat,"Kidney scRNAseq Project/Data/Biopsies_w_mrn_Oct3.xlsx"))
#Select Metformin, RASSI, Insulin data
med <- med %>%
  dplyr::select(all_of(c("record_id","mrn","raasi_1","insulin_1","mfm_1")))
#Pull seurat object metadata to help harmoinize in new metadata
meta_kidney_sc <-  so_kpmp_sc@meta.data
#Filter to only those with a unique identifier id in the seurat object metadata
med <- med %>%
  filter(mrn %in% as.character(meta_kidney_sc$mrn)) 
length(unique(med$mrn)) #95 total rows remain, 81 unique individual ids
#Filter to only those that have a unique record id in the seurat object
med <- med %>%
  filter(record_id %in% meta_kidney_sc$record_id) 
length(unique(med$mrn)) #81 remain
length(unique(med$record_id)) #81
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
med$mrn <- as.numeric(med$mrn) #Make numeric to merge
#Merge med data with seurat metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(med,by=c("mrn","record_id"))
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
length(unique(meta_kidney_sc$mrn)) #81 remain
length(unique(meta_kidney_sc$record_id)) #81

#Add Med Meta Data to Seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
#Remove med metadatset
rm(med,meta_kidney_sc)

#Create medication & disease status groups of interest
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)
invisible(gc())
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
so_kpmp_sc@meta.data$medication <- factor(so_kpmp_sc@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))

#Ensure default assay in seurat object to RNA
DefaultAssay(so_kpmp_sc) <- "RNA"
invisible(gc())

# #Perform Quality Control & Preprocessing Steps
# #Number of cells before filtering: 
cell_total1 <- ncol(so_kpmp_sc) #186125
# #Number of Genes before filtering: 
gene_total1 <- nrow(so_kpmp_sc) #31332

ncol(so_kpmp_sc) #186125 nuclei
nrow(so_kpmp_sc) # 11313 genes
#YE JI's filtering code for percent expression 
#Filter out rare genes expressed in less than "gene_pct" of cells
# expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, layer = "counts"))
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, assay = "RNA", layer = "counts"))
# expr_matrix <- as.matrix(so_kpmp_sc@assays$RNA@layers$counts)
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.05])
so_kpmp_sc <- subset(so_kpmp_sc, features = genes_to_keep)
ncol(so_kpmp_sc) #186125 nuclei
nrow(so_kpmp_sc) # 9289 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_kpmp_sc), value = TRUE)
#keep_ids <- unique(rownames(so_kpmp_sc)[which(!rownames(so_kpmp_sc) %in% mito_genes)])
# so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#so_kpmp_sc$Gene <- rownames(so_kpmp_sc)
#so_kpmp_sc <- subset(so_kpmp_sc, Gene %in% keep_ids)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
#so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc@assays$RNA@counts), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc, !rownames(so_kpmp_sc) %in% mito_genes)
# grep("^MT-", rownames(so_kpmp_sc@assays$RNA@counts), value = TRUE)
# dim(so_kpmp_sc@assays$RNA@counts) #9276 186125
# dim(so_kpmp_sc@assays$RNA@data) #9276 186125
# dim(so_kpmp_sc@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
ncol(so_kpmp_sc) #186125cells
nrow(so_kpmp_sc) #9276 genes

# #Number of Cells after filtering: 
# cell_total2 <- ncol(so_filtered) 
# #Number of Genes after filtering: 
# gene_total2 <- nrow(so_filtered) 
# print(paste0(cell_total1," cells before filtereing, ",cell_total2," cells after filtering (removed ",cell_total1-cell_total2," cells); ",gene_total1," genes before filtering, ",gene_total2," genes after filtering (removed ",gene_total1-gene_total2," genes)"))

```
# 3. Comparitive Data Analysis
## A. Type 2 Diabetes (No Med) vs. Healthy Controls
### a. PT Cells
#### i. Pseudobulk PT cells
```{r}
#PT Cells
so_kpmp_sc$celltype_new <- ifelse(grepl("PT",so_kpmp_sc$KPMP_celltype),"PT",
                                  ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                         ifelse(grepl("POD",so_kpmp_sc$KPMP_celltype),"POD",
                                                ifelse(grepl("EC",so_kpmp_sc$KPMP_celltype),"EC",NA))))
#PT
so_celltype <- subset(so_kpmp_sc,celltype_new=="PT")
ncol(so_celltype) #41383 cells
nrow(so_celltype) #9276 genes
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list_total <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")
data_subset$group <- factor(data_subset$group)
data_subset$group <- relevel(data_subset$group,ref="Lean_Control")
data_subset <- data_subset %>% 
  dplyr::select(c("kit_id","group","age","sex","bmi",all_of(gene_list)))

#Try as batch loop
# Set batch size
batch_size <- 2000
total_cores <- 20

# Get total number of genes
# gene_list_total <- gene_list
# total_genes <- length(gene_list_total)
length(gene_list_total)
length(unique(gene_list_total))

# Create an empty list to store results
all_results <- list()

# cl <- makeCluster(total_cores)
# registerDoParallel(cl)

# Loop over batches
for (start_idx in seq(1, total_genes, by = batch_size)) {
  
  # Define end index for the batch
  end_idx <- min(start_idx + batch_size - 1, total_genes)
  
  # Subset genes for this batch
  gene_list <- gene_list_total[start_idx:end_idx]
  
  # # Set number of cores to use
  cl <- makeCluster(total_cores)
  registerDoParallel(cl)
  
  # Define function to process a single gene
  process_gene <- function(gene_idx) {
    gene <- gene_list[gene_idx]  # Get the gene name based on the index
    
    # Ensure that the gene exists in your data subset
    if (sum(data_subset[[gene]]) > 0) {
      # Define model formula
      m1 <- as.formula(paste0(gene, " ~ group + age + sex + bmi + (1 | kit_id)"))
      
      # Fit the zero-inflated mixed-effects model with error handling
      # model1 <- tryCatch({
      model1 <- glmmTMB(m1, data = data_subset, family = gaussian, ziformula = ~1)
      # }, error = function(e) {
      #   return(NULL)
      # })
      
      if (!is.null(model1)) {
        Beta <- summary(model1)$coef$cond[2,1]
        PValue <- summary(model1)$coef$cond[2,4]
        zi <- summary(model1)$coef$zi[1,1]
        zi_pval <- summary(model1)$coef$zi[1,4]
      } else {
        Beta <- NA
        PValue <- NA
        zi <- NA
        zi_pval <- NA
      }
      
    } else {
      Beta <- NA
      PValue <- NA
      zi <- NA
      zi_pval <- NA
    }
    
    # Return result
    return(data.frame(Gene = gene, Beta = Beta, PValue = PValue, ZI_Intercept = zi, ZI_PValue = zi_pval))
  }
  
  
  # Run the analysis in parallel
  batch_results <- foreach(i = seq_along(gene_list), .combine = rbind, .packages = c("glmmTMB", "lme4")) %dopar% {
    process_gene(i)
  }
  
    # Stop the cluster
  stopCluster(cl)
  
  # Store batch results
  all_results[[length(all_results) + 1]] <- batch_results
  
  # Print progress
  cat("Processed batch:", start_idx, "to", end_idx, "\n")
}



# Combine all batch results into a single data frame
final_results <- do.call(rbind, all_results)
# Print the final results
view(full_results)
# full_results4 <- full_results
# full_results <- rbind(full_results,full_results4)
# rm(full_results2,full_results3,full_results4,full_results5,full_results6,full_results7)
#Accidentally ran RORA twice, remove second entry (they are identical)
# full_results <- full_results[-3501,]

# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# full_results$PValue10_3 <- -log10(pmax(full_results$PValue3, 1e-10))  # Avoid log(0)

# view(full_results)

full_results <- full_results %>%
  mutate(FoldChange=2^Beta-1)  
# mutate(FoldChange3=2^Beta3-1)
# full_results <- full_results %>% 
#   dplyr::rename(color=color2,
#                 FoldChange=FoldChange2) %>%
#   # dplyr::rename(fdr=fdr2,
#   #               PValue10=PValue10_2) %>%
#   # dplyr::select(-c("Beta3","PValue3")) %>% 
#   dplyr::select(-c("color3","FoldChange3"))

write.csv(full_results,fs::path(dir.results,"Pseudobulk_All_Celltypes_Steatosis.csv"))
write.csv(full_results,fs::path(dir.ipa %>% dirname(),"Liver Pathways","Pseudobulk_All_Celltypes_Steatosis.csv"))
# full_results <- read.csv(fs::path(dir.results,"Hep_5_Fibrosis_Steatosis.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# 
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$Beta3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "High Steatosis (2+3) vs. Low Steatosis (0+1)",
    subtitle = "All Cell Types, Adjusted for HbA1c & Ethnicity",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Nuclei = ",Nuclei)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

pdf(fs::path(dir.results,"Plot_All_Celltypes_Steatosis.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()


full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)
# write.csv(full_results,fs::path(dir.results,"Pseudobulk_PT_T2D_HC_No_Med.csv"))

# Add a column to determine color based on the sign of the beta
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "salmon", 
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.1)
significant_df <- full_results[full_results$fdr < 0.05, ]

# Sort the data to get top 10 positive and negative Beta based on FDR
top_positive_beta <- significant_df[significant_df$Beta > 0, ] %>%
  arrange(fdr, desc(Beta)) %>%
  head(10)

top_negative_beta <- significant_df[significant_df$Beta < 0, ] %>%
  arrange(fdr, Beta) %>%
  head(10)

# Combine both top positive and negative Beta data
top_10_significant <- rbind(top_positive_beta, top_negative_beta)
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Pseudobulk PT: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.1"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  # Add labels for top 10 significant points (both positive and negative Beta) with ggrepel
  geom_text_repel(data = top_10_significant, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_Pseudobulk_PT_T2D_HC_No_Med.pdf"))
print(volcano_plot)
dev.off()
```

#### ii. PT-S1/2
```{r}
#PT-S1/2
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S1/S2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. PT-S3
```{r}
#PT-S3
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S3")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    if (sum(data_subset[[gene]])>0) {
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
      
    } else {
      beta1 <- NA
      pval1 <-NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1) 
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# write.csv(full_results,fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "red",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "blue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
#
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S3 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  ylim(0, 40) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, 
                  max.overlaps = 20, min.segment.length = 0) 

pdf(fs::path(dir.results,"Plot2_PT_S3_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. aPT
```{r}
#aPT
so_celltype <- subset(so_filtered,KPMP_celltype=="aPT")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))

write.csv(full_results,fs::path(dir.results,"aPT_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.3 & full_results$Beta > 0, "salmon",
                             ifelse(full_results$fdr < 0.3 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.3, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "aPT Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.3"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_aPT_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
## b. EC Cells
#### i Pseudobulk EC
```{r}
#EC-GC
so_celltype <- subset(so_filtered,celltype_new=="EC")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    if (sum(data_subset[[gene]])>0) {
      # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
      # model <- lmer(m0,data=data_subset)
      #Adjust for key covariates
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
    } else {
      beta1 <- NA
      pval1 <- NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"Pseudobulk_EC_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"Pseudobulk_EC_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Pseudobulk EC Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_Pseudobulk_EC_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### ii. EC-AVR
```{r}
#EC-AVR
so_celltype <- subset(so_filtered,KPMP_celltype=="EC-AVR")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    if (sum(data_subset[[gene]])>0) {
      # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
      # model <- lmer(m0,data=data_subset)
      #Adjust for key covariates
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
    } else {
      beta1 <- NA
      pval1 <- NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_AVR_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "EC-AVR Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_EC_AVR_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. EC-GC
```{r}
#EC-GC
so_celltype <- subset(so_filtered,KPMP_celltype=="EC-GC")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    if (sum(data_subset[[gene]])>0) {
      # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
      # model <- lmer(m0,data=data_subset)
      #Adjust for key covariates
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
    } else {
      beta1 <- NA
      pval1 <- NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


write.csv(full_results,fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))
# full_results <- read.csv(fs::path(dir.results,"EC_GC_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "EC-GC Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_EC_GC_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. EC-PTC
#### v. EC-AEA
## c. TAL
## d. Podocytes

## B. Medication Status - Type 2 Diabetes Only
### i. Pseudobulk PT Cells
```{r}
#PT Cells
so_filtered$celltype_new <- ifelse(grepl("PT",so_filtered$KPMP_celltype),"PT",
                                   ifelse(grepl("TAL",so_filtered$KPMP_celltype),"TAL",
                                          ifelse(grepl("POD",so_filtered$KPMP_celltype),"POD",
                                                 ifelse(grepl("EC",so_filtered$KPMP_celltype),"EC",NA))))
#PT
so_celltype <- subset(so_filtered,celltype_new=="PT")
ncol(so_celltype) #41383 cells
nrow(so_celltype) #9289 genes

# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$medication <- factor(data_subset$medication)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

# Number of cores to use for parallel processing
num_cores <- detectCores() - 1  # Use one less than the total number of cores

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Create a function that will handle the analysis for each gene
process_gene <- function(gene) {
  
  # Check if gene exists in data (skipping if not present in data)
  if (sum(data_subset[[gene]]) > 0) {
    
    # Fit the model with key covariates
    m1 <- as.formula(paste0(gene, " ~ medication + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1, data = data_subset)
    
    # Compute estimated marginal means
    emm <- emmeans(model1, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
    
    # Define and test the contrasts
    contrast_results <- contrast(emm, list(
      "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
      "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
      "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
      "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
      "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
    ))
    
    contrast_p <- as.data.frame(summary(contrast_results))
    contrast_summary <- confint(contrast_results)
    contrast_df <- as.data.frame(contrast_summary)
    contrast_df$PValue <- contrast_p$p.value
    contrast_df$Gene <- gene
    
    # Estimate the overall beta and confidence intervals
    beta1 <- round(summary(model1)$coef[2, 1], 3)
    pval1 <- round(summary(model1)$coef[2, 5], 5)
    se <- round(summary(model1)$coef[2, 2], 5)
    df <- round(summary(model1)$coef[2, 3], 5)
    lowerci <- round(summary(model1)$coef[2, 1] - 1.96 * se, 5)
    upperci <- round(summary(model1)$coef[2, 1] + 1.96 * se, 5)
    
    result <- data.frame(contrast = "Overall", estimate = beta1, SE = se, df = df,
                         lower.CL = lowerci, upper.CL = upperci, PValue = pval1, Gene = gene)
    result2 <- rbind(result, contrast_df)
    
    return(result2)  # Return the processed result
  } else {
    return(NULL)  # If the gene is not present, return NULL
  }
}

# Now use mclapply to run the analysis in parallel for all genes
gene_results <- mclapply(gene_list, process_gene, mc.cores = num_cores)

# Filter out any NULL results and combine all data into a single data frame
full_results <- do.call(rbind, gene_results)
# full_results <- na.omit(full_results)  # Remove any NULL or incomplete results
view(full_results)

# full_results <- data.frame()
# 
# # Total number of genes
# total_genes <- length(gene_list)
# 
# # Calculate the batch size
# batch_size <- round(total_genes / 5)
# 
# # Simulate a vector of genes (replace this with your actual gene data)
# genes <- 1:total_genes
# 
# # Loop through the genes in batches
# for (i in seq(1, total_genes, by = batch_size)) {
#   
#   # Get the current batch (subsetting the gene vector)
#   batch <- genes[i:min(i + batch_size - 1, total_genes)]
#   for (gene in gene_list[batch]) { #tester genes
#     # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
#     # model <- lmer(m0,data=data_subset)
#     #Adjust for key covariates
#     m1 <- as.formula(paste0(gene," ~ medication + age + sex + bmi + (1 | kit_id)"))
#     model1 <- lmer(m1,data=data_subset)
#     
#     # Compute estimated marginal means
#     # emm <- emmeans(model1, ~ medication, pbkrtest.limit = 19037)
#     emm <- emmeans(model1, ~ medication, lmerTest.limit = 19037, pbkrtest.limit = 19037)
#     
#     # Define and test the contrasts
#     contrast_results  <- contrast(emm, list(
#       "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
#       "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
#       "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
#       "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
#       "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
#     ))
#     
#     contrast_p <-  as.data.frame(summary(contrast_results))
#     contrast_summary <- confint(contrast_results)
#     contrast_df <- as.data.frame(contrast_summary)
#     contrast_df$PValue <- contrast_p$p.value
#     contrast_df$Gene <- gene
#     
#     # # Plot the pairwise comparisons with ggplot
#     # ggplot(contrast_df, aes(x = contrast, y = estimate, ymin = lower.CL, ymax = upper.CL)) +
#     #   geom_pointrange(color = "blue", size = 1.5) +  # Points with confidence intervals
#     #   geom_hline(yintercept = 0, linetype = "dashed", color = "red") +  # Line at 0 (no difference)
#     #   theme_minimal() +  # Minimal theme
#     #   labs(
#     #     title = "Pairwise Comparisons of Medication Groups",
#     #     x = "Contrast",
#     #     y = "Estimated Difference (Log2FC)",
#     #     caption = "Red dashed line represents no difference (Estimate = 0)"
#     #   ) +
#     #   theme(
#     #     axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
#     #     plot.title = element_text(hjust = 0.5)  # Center title
#     #   )
#     
#     
#     # beta <- round(summary(model)$coef[2,1],3)
#     # pval <-round(summary(model)$coef[2,5],5)
#     beta1 <- round(summary(model1)$coef[2,1],3)
#     pval1 <-round(summary(model1)$coef[2,5],5)
#     se <- round(summary(model1)$coef[2,2],5)
#     df <- round(summary(model1)$coef[2,3],5)
#     lowerci <- round(summary(model1)$coef[2,1] - 1.96*se,5)
#     upperci <- round(summary(model1)$coef[2,1] + 1.96*se,5)
#     result <- data.frame(contrast="Overall", estimate=beta1, SE=se,df=df,lower.CL=lowerci, upper.CL=upperci, PValue=pval1,Gene=gene  )
#     result2 <- rbind(result,contrast_df)
#     full_results <- rbind(full_results,result2)
#   }
# }
# # #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### ii. PT-S1/2
```{r}
#PT-S1/2
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S1/S2")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes") 
# filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ medication + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # Compute estimated marginal means
    emm <- emmeans(model1, ~ medication)
    
    # Define and test the contrasts
    contrast(emm, list(
      "GLP1 vs No Med" = c(0, 1, 0, -1),  # GLP1 vs No Med
      "SGT2 vs No Med" = c(0, 0, 1, -1),  # SGT2 vs No Med
      "GLP1+SGT2 vs No Med" = c(0, 0, 0, 1),  # GLP1+SGT2 vs No Med
      "GLP1+SGT2 vs GLP1" = c(0, -1, 1, 0),  # GLP1+SGT2 vs GLP1
      "GLP1+SGT2 vs SGT2" = c(0, 0, -1, 1)  # GLP1+SGT2 vs SGT2
    ))
    
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)


# write.csv(full_results,fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S1_S2_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.2 & full_results$Beta > 0, "lightcoral",
                             ifelse(full_results$fdr < 0.2 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.2, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S1/S2 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  # Add a horizontal line at -log10(0.05) ≈ 1.3 (FDR threshold)
  # geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", linewidth = 1) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_PT_S1_S2_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iii. PT-S3
```{r}
#PT-S3
so_celltype <- subset(so_filtered,KPMP_celltype=="PT-S3")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    if (sum(data_subset[[gene]])>0) {
      m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
      model1 <- lmer(m1,data=data_subset)
      
      # # Plot residuals vs fitted values
      # residuals <- residuals(model1)
      # fitted_values <- fitted(model1)
      # 
      # plot(fitted_values, residuals)
      # abline(h = 0, col = "red")
      # 
      # # Histogram of residuals
      # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
      # 
      # # Q-Q plot for normality
      # qqnorm(residuals)
      # qqline(residuals, col = "red")
      
      # beta <- round(summary(model)$coef[2,1],3)
      # pval <-round(summary(model)$coef[2,5],5)
      beta1 <- round(summary(model1)$coef[2,1],3)
      pval1 <-round(summary(model1)$coef[2,5],5)
      
    } else {
      beta1 <- NA
      pval1 <-NA
    }
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1) 
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]
full_results$PValue10 <- -log10(pmax(full_results$PValue, 1e-10))  # Avoid log(0)

# write.csv(full_results,fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))
full_results <- read.csv(fs::path(dir.results,"PT_S3_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$Beta > 0, "red",
                             ifelse(full_results$fdr < 0.05 & full_results$Beta < 0, "blue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
#
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "PT-S3 Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.2"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  ylim(0, 40) +
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  # geom_text_repel(data = significant_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, 
                  max.overlaps = 20, min.segment.length = 0) 

pdf(fs::path(dir.results,"Plot2_PT_S3_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```
#### iv. aPT
```{r}
#aPT
so_celltype <- subset(so_filtered,KPMP_celltype=="aPT")
# Extract the gene expression data for all genes
gene_expression <- as.data.frame(GetAssayData(so_celltype, layer = "data"))

#Assign gene names as rownames, cell names as colnames
# rownames(gene_expression) <- rownames(so_celltype) #Gene Names
# colnames(gene_expression) <- colnames(so_celltype) #Cell Names
#Transpose gene expression dataset to merge with metadata
gene_expression <- t(gene_expression)
gene_expression <- data.frame(gene_expression) #Make a dataframe again after transposing
#Set gene list
gene_list <- colnames(gene_expression)
gene_expression$cellname <- rownames(gene_expression) 
rownames(gene_expression) <- NULL

# Extract the metadata
metadata <- so_celltype@meta.data
# metadata <- metadata %>%
#   mutate(across(everything(),~ifelse(.==".",NA,.)))
metadata$cellname <- rownames(metadata)
rownames(metadata) <- NULL

# Combine the gene expression data and metadata
data <- tidylog::full_join(metadata,gene_expression,by="cellname")
rm(metadata,gene_expression)

#Compare Health Controls to Type 2 Diabetes on no meds
data_subset <- data %>%
  filter(group=="Type_2_Diabetes" | group=="Lean_Control") %>%
  filter(medication=="no_med")

data_subset$group <- factor(data_subset$group)

#Log transform gene expression
data_subset <- data_subset %>% 
  mutate(across(all_of(gene_list),~log2(.+1)))

full_results <- data.frame()

# Total number of genes
total_genes <- length(gene_list)

# Calculate the batch size
batch_size <- round(total_genes / 5)

# Simulate a vector of genes (replace this with your actual gene data)
genes <- 1:total_genes

# Loop through the genes in batches
for (i in seq(1, total_genes, by = batch_size)) {
  
  # Get the current batch (subsetting the gene vector)
  batch <- genes[i:min(i + batch_size - 1, total_genes)]
  for (gene in gene_list[batch]) { #tester genes
    # m0 <- as.formula(paste0(gene," ~ group + (1 | kit_id)"))
    # model <- lmer(m0,data=data_subset)
    #Adjust for key covariates
    m1 <- as.formula(paste0(gene," ~ group + age + sex + bmi + (1 | kit_id)"))
    model1 <- lmer(m1,data=data_subset)
    
    # # Plot residuals vs fitted values
    # residuals <- residuals(model1)
    # fitted_values <- fitted(model1)
    # 
    # plot(fitted_values, residuals)
    # abline(h = 0, col = "red")
    # 
    # # Histogram of residuals
    # hist(residuals, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")
    # 
    # # Q-Q plot for normality
    # qqnorm(residuals)
    # qqline(residuals, col = "red")
    
    # beta <- round(summary(model)$coef[2,1],3)
    # pval <-round(summary(model)$coef[2,5],5)
    beta1 <- round(summary(model1)$coef[2,1],3)
    pval1 <-round(summary(model1)$coef[2,5],5)
    
    result <- data.frame(Gene=gene,Beta=beta1,PValue=pval1)
    full_results <- rbind(full_results,result)
  }
}
# #Make volcano plot of all gene results for group
full_results <- full_results %>%
  mutate(fdr=p.adjust(PValue,method="fdr"))

write.csv(full_results,fs::path(dir.results,"aPT_T2D_HC_No_Med.csv"))

# }
# Add a column to determine color based on the sign of the beta
# Create a new color column based on beta sign and FDR threshold
full_results$color <- ifelse(full_results$fdr < 0.3 & full_results$Beta > 0, "salmon",
                             ifelse(full_results$fdr < 0.3 & full_results$Beta < 0, "lightblue", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.3, ]
# full_results$color <- ifelse(full_results$PValue < 0.05 & full_results$Beta > 0, "red", 
#                              ifelse(full_results$PValue < 0.05 & full_results$Beta < 0, "blue", "gray"))
# 
# # Identify significant points (PValue < 0.05)
# significant_df <- full_results[full_results$PValue < 0.05, ]

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = Beta, y = -log10(PValue), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "aPT Cells: Lean Controls vs. Type 2 Diabetes (No Medication)",
    subtitle = "Adjusted for Age, Sex, & BMI",
    x = "Log2FC",
    y = "-log10(P-Value)",
    color = "Beta Direction",
    caption = "Positive Beta = Upregulation in T2D vs. LC, Negative Beta = Downregulation in T2D vs. LC \n Signficance threshold: FDR < 0.3"
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = gene), 
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
  # Add labels for significant points with ggrepel
  geom_text_repel(data = significant_df, aes(label = Gene),
                  size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

pdf(fs::path(dir.results,"Plot_aPT_T2D_HC_No_Med.pdf"),width=10,height=7)
print(volcano_plot)
dev.off()
```

