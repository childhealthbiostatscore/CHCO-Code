---
title: "Organoid Samples Analysis"
author: "Hailey Hampson"
date: "2025-04-16"
output: html_document
---

#1.Set Up 
```{r,include=FALSE}
library(reprex)
library(tidyverse)
library(BiocManager)        
library(arsenal)
library(dplyr)
library(ggplot2)
library(ggrepel)
library(Seurat)
library(future)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(venn)
library(rstatix)
library(table1)
library(Biobase)
library(ReactomeGSA)
library(GSEABase)
library(msigdbr)
library(kableExtra)
library(knitr)
library(SingleCellExperiment)
library(fgsea)
library(EnhancedVolcano)
library(openxlsx)
library(BiocManager)
library(MAST)
library(ggrepel)
# library(qpcR)
library(ggpubr)
library(openxlsx)
library(ggplot2)
library(GGally)
library(GSEABase)
library(limma)
library(reshape2)
library(data.table)
library(knitr)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
#library(NMF)
library(rsvd)
library(RColorBrewer)
library(MAST)
library(devtools)
# install_github("Sun-lab/ideas",force=T)
#library(ideas)
library(foreach)
library(parallel)
library(doRNG)
library(doParallel)
library(fs)
# registerDoParallel(cores = 6)
library(VennDiagram)
library(janitor)
# devtools::install_github('immunogenomics/presto')
library(presto)
library(knitr)
library(lme4)
library(lmerTest)
#install.packages("glmmTMB")
# Reinstall glmmTMB from source
# install.packages("glmmTMB", type = "source")
library(glmmTMB)
# Install DoubletFinder (if not already installed)
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# Load the package
# Install DoubletFinder from GitHub (use devtools to install)
# if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
# devtools::install_github("chris-mcginnis-ucsf/DoubletFinder",force=T)
# library(DoubletFinder)
# install.packages("emmeans")
library(emmeans)
library(pheatmap)
library(enrichplot)
library(enrichR)
dbs <- c("GO_Biological_Process_2023", 
         "KEGG_2021_Human",
         # "Reactome_2022", 
         "Reactome_Pathways_2024",
         # "MSigDB_Oncogenic_Signatures",
         # "MSigDB_Computational",
         "MSigDB_Hallmark_2020")
# BiocManager::install("edgeR",force=T)
library(edgeR)
library(devtools)
# install_github("lhe17/nebula")
library(nebula)

# remove.packages("boot")  # Remove broken version
# install.packages("boot", type = "source")  # Reinstall from source
library(boot)
library(furrr)
library(future)
# BiocManager::install("scran")
library(scran)
library(BiocParallel)
library(DESeq2)

# #Mac laptop
# dir.dat <- c("//Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive")
# dir.dat2 <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/scRNA")
# dir.code <- c("/Users/hhampson/Documents/CHCO-Code/Petter Bjornstad/Liver analysis/Liver scRNAseq")
# dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Kidney scRNAseq Project/Organoid Results/NEBULA")

#Mac Studio File Path
dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive")
dir.dat2 <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/scRNA")
dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-UW/Biostatistics Core Shared Drive/Kidney scRNAseq Project/Organoid Results/NEBULA")

##c. Load functions ----
source("Kidney_functions_sc.R")
```

# 2. Pre-Processing & Qualtiy Control
## a. Load Data
### i. Biopsy Data
```{r}
#Set ids for organoid samples
ids <- c("CRC-10","CRC-11","CRC-03","RH-50-T","RH-72-T","RH-62-T","IT_19")

##d. Load Data ----
so_kpmp_sc <- readRDS(fs::path(dir.dat2,"data_raw","PB_90_RPCAFix_Metadata_LR_RM_kpmpV1labelled.rds"))
so_kpmp_sc <- subset(so_kpmp_sc,record_id %in% ids)

#Load harmonized data that has been filtered from 90 to the 83 participants that have baseline single cell data
# harm_meta_data <- read.csv(fs::path(dir.dat,"Kidney scRNAseq Project","Data","harmonized_data_kidney_sc_all_metadata2.csv"))
# harm_meta_data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Data Harmonization/Data Clean/harmonized_dataset.csv",na="")
harm_meta_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean/harmonized_dataset.csv",na=""))

harm_meta_data <- harm_meta_data %>%   
  arrange(screen_date) %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(record_id, visit))

##e. Filter to 7 organoid samples ----
meta <- harm_meta_data %>% 
  # dplyr::select(-X) %>% 
  filter(visit=="baseline") %>% 
  filter(record_id %in% ids)
rm(harm_meta_data)
#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  so_kpmp_sc@meta.data
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(meta,by="kit_id")
rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)

#Pull ids from 83 participants at baseline to filter seurat object to these participants only 
ids <- meta$kit_id

#Merge metadata back into seurat object
so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)

#Check number of unique ids
length(unique(so_kpmp_sc$kit_id)) #should be 7

#Remove metadatasets
rm(meta_kidney_sc,meta)

# ##f. Merge metadata into filtered seurat object ----
# #Load in most up to date medication data to update medication information
# med <- read.xlsx(fs::path(dir.dat,"Kidney scRNAseq Project/Data/Biopsies_w_mrn_Oct3.xlsx"))
# #Select Metformin, RASSI, Insulin data
# med <- med %>%
#   dplyr::select(all_of(c("record_id","mrn","raasi_1","insulin_1","mfm_1")))
# #Pull seurat object metadata to help harmoinize in new metadata
# meta_kidney_sc <-  so_kpmp_sc@meta.data
# #Filter to only those with a unique identifier id in the seurat object metadata
# med <- med %>%
#   filter(mrn %in% as.character(meta_kidney_sc$mrn)) 
# length(unique(med$mrn)) #6 participants
# #Filter to only those that have a unique record id in the seurat object
# med <- med %>%
#   filter(record_id %in% meta_kidney_sc$record_id) 
# length(unique(med$mrn)) #6 remain
# length(unique(med$record_id)) #6
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# med$mrn <- as.numeric(med$mrn) #Make numeric to merge
# #Merge med data with seurat metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(med,by=c("mrn","record_id"))
# rownames(meta_kidney_sc) <- rownames(so_kpmp_sc@meta.data)
# length(unique(meta_kidney_sc$mrn)) #6 remain
# length(unique(meta_kidney_sc$record_id)) #6
# 
# #Add Med Meta Data to Seurat object
# so_kpmp_sc <- AddMetaData(so_kpmp_sc, meta_kidney_sc)
# #Remove med metadatset
# rm(med,meta_kidney_sc)

#Create medication & disease status groups of interest
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)
invisible(gc())
so_kpmp_sc@meta.data <- so_kpmp_sc@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
# so_kpmp_sc@meta.data$medication <- factor(so_kpmp_sc@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))

#Ensure default assay in seurat object to RNA
DefaultAssay(so_kpmp_sc) <- "RNA"
invisible(gc())

# #Calculate cell library size for offset
# counts_layer <- round(GetAssayData(so_kpmp_sc, layer = "counts")) # load counts and round
# library_size <- Matrix::colSums(counts_layer) #calculate the column sums aka the sum of all genes in each cell
# so_kpmp_sc$library_size <- library_size #Put into the seurat object
# #Check that it is accessible in the metadata
# meta <- so_kpmp_sc@meta.data #It should be in the dataframe, delete meta data check df
# rm(meta,counts_layer)
# hist(so_kpmp_sc$library_size)

# #Perform Quality Control & Preprocessing Steps
ncol(so_kpmp_sc) #11386 cells
nrow(so_kpmp_sc) #31332 genes
#YE JI's filtering code for percent expression
#Filter out rare genes expressed in less than "gene_pct" of cells
# expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, layer = "counts"))
expr_matrix <- as.matrix(GetAssayData(so_kpmp_sc, assay = "RNA", layer = "counts"))
# expr_matrix <- as.matrix(so_kpmp_sc@assays$RNA@layers$counts)
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.05])
so_kpmp_sc <- subset(so_kpmp_sc, features = genes_to_keep)
ncol(so_kpmp_sc) #11386 Cells
nrow(so_kpmp_sc) # 9209 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(so_kpmp_sc), value = TRUE)
#keep_ids <- unique(rownames(so_kpmp_sc)[which(!rownames(so_kpmp_sc) %in% mito_genes)])
# so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc,kit_id!="KL-0029535")
#so_kpmp_sc$Gene <- rownames(so_kpmp_sc)
#so_kpmp_sc <- subset(so_kpmp_sc, Gene %in% keep_ids)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), mito_genes))
#so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc@assays$RNA@counts), mito_genes))
# so_kpmp_sc <- subset(so_kpmp_sc, !rownames(so_kpmp_sc) %in% mito_genes)
# grep("^MT-", rownames(so_kpmp_sc@assays$RNA@counts), value = TRUE)
# dim(so_kpmp_sc@assays$RNA@counts) #9276 186125
# dim(so_kpmp_sc@assays$RNA@data) #9276 186125
# dim(so_kpmp_sc@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
ncol(so_kpmp_sc) #11386 cells
nrow(so_kpmp_sc) #9196 genes

#Step 3: Remove ribosomal Genes
# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
)
so_kpmp_sc <- subset(so_kpmp_sc, features = setdiff(rownames(so_kpmp_sc), ribo_genes))
# sum(grepl("^MT-", rownames(so_kpmp_sc))) #0
length(which(rownames(so_kpmp_sc) %in% ribo_genes)) #0
ncol(so_kpmp_sc) #65,062 cells
nrow(so_kpmp_sc) #15103 genes

#Renormalize & Scale after filtering
so_kpmp_sc <- NormalizeData(so_kpmp_sc)
so_kpmp_sc <- ScaleData(so_kpmp_sc, features = VariableFeatures(so_kpmp_sc))

# Calculate cell library size for offset in NEBULA --------------------------------------
counts_layer <- round(GetAssayData(so_kpmp_sc, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
so_kpmp_sc$library_size <- library_size
# View(so_kpmp_sc@meta.data)
hist(so_kpmp_sc$library_size)

# # TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- log(dge$samples$lib.size) + log(dge$samples$norm.factors)
# so_kpmp_sc$tmm_offset <- tmm_offset

# Pooled offset
bp <- MulticoreParam(workers = 63) 
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
# sce <- computeSumFactors(sce)
sce <- computeSumFactors(sce, BPPARAM = bp)
# View size factors
# sizeFactors(sce)
# STEP 3: Calculate offset → log(size factors)
pooled_offset <- sizeFactors(sce)
so_kpmp_sc$pooled_offset <- pooled_offset
hist(so_kpmp_sc$pooled_offset)

# saveRDS(so_kpmp_sc,fs::path(dir.dat,"scRNA","data_clean","organoid_scRNA_cleaned.RDS"))
# so_kpmp_sc <- readRDS(fs::path(dir.dat,"scRNA","data_clean","organoid_scRNA_cleaned.RDS"))
#Create general hepatocyte cell type variable
#Create PT and TAL pseudobulk cell type variable
so_kpmp_sc$celltype1 <- case_when(grepl("PT-",so_kpmp_sc$celltype_rpca)~"PT",
                                  grepl("TAL-",so_kpmp_sc$celltype_rpca)~"TAL",
                                  grepl("EC-",so_kpmp_sc$celltype_rpca)~"EC",
                                  grepl("POD",so_kpmp_sc$celltype_rpca)~"POD",
                                  grepl("MAC",so_kpmp_sc$celltype_rpca)~"MAC",
                                  grepl("MON",so_kpmp_sc$celltype_rpca)~"MON",
                                  grepl("PC-",so_kpmp_sc$celltype_rpca)~"PC",
                                  grepl("FIB",so_kpmp_sc$celltype_rpca)~"FIB_MC_VSMC",
                                  grepl("DTL",so_kpmp_sc$celltype_rpca)~"DTL",
                                  so_kpmp_sc$celltype_rpca=="DCT"~"DCT",
                                  so_kpmp_sc$celltype_rpca=="ATL"~"ATL",
                                  so_kpmp_sc$celltype_rpca=="B"~"B",
                                  so_kpmp_sc$celltype_rpca=="T"~"T")
so_kpmp_sc$celltype1 <- as.character(so_kpmp_sc$celltype1)

so_kpmp_sc$KPMP_celltype2 <- as.character(so_kpmp_sc$KPMP_celltype)
so_kpmp_sc$celltype2 <- ifelse(so_kpmp_sc$KPMP_celltype=="aPT" | 
                                 so_kpmp_sc$KPMP_celltype=="PT-S1/S2" | 
                                 so_kpmp_sc$KPMP_celltype == "PT-S3","PT",
                               ifelse(grepl("TAL",so_kpmp_sc$KPMP_celltype),"TAL",
                                      ifelse(grepl("EC-",so_kpmp_sc$KPMP_celltype),"EC",so_kpmp_sc$KPMP_celltype2)))

```

### ii. Organoid Data
```{r}
ids <- c("CRC-10","CRC-11","CRC-03","RH-50-T","RH-72-T","RH-62-T","IT_19")
# unique(sc_org$samples) #"sample_50_15"   "sample_42_15"   "sample_50_30"   "sample_41_1_15" "sample_11_30"   "ITD19_30" #"sample_10_15"   "sample_72_15"   "sample_10_30"   "ITD19_15"       "sample_41_1_30" "sample_72_30"  
#  "41_G_15"        "sample_42_30"   "41_G_30"        "sample_11_15"  
# DKD ids were 42, 50 and 72 and the controls were 10, 11 and 41 

# The 10 and 11 have iCRC, the 50 and 72 have RH, and the remaining ones _ 41, 42, and ITD19 _ don’t have any letters.
#CRC10 -sample_10_15, "sample_10_30
# CRC11 - sample_11_15, sample_11_30
# CRC03 (aka ‘line 41) - "41_G_15", "41_G_30" , sample_41_1_15, sample_41_1_30

# RH50T -  "sample_50_30", sample_50_15
# RH72T -  "sample_72_15" ,sample_72_30
# RH62T (aka ‘line 42’) - "sample_42_15",  "sample_42_30"
# IT2D19 - ITD19_30, ITD19_15

#41 iPS clone I
# 41 iPS clone G

sc_org <- readRDS(fs::path(dir.dat,"scRNA","data_raw","organoids_processed_matrix.rds"))
meta <- sc_org@meta.data

diab_ids <- c("sample_50_15","sample_50_30","sample_72_15","sample_72_30","sample_42_15","sample_42_30","ITD19_15","ITD19_30")
control_ids <- c("sample_10_15","sample_10_30","sample_11_15","sample_11_30","41_G_15","41_G_30","sample_41_1_15","sample_41_1_30")

sc_org$diabetes <- ifelse(sc_org$samples %in% diab_ids,"Diabetes","Control")
sc_org$diabetes <- factor(sc_org$diabetes)

# biopsy_ids <- c("CRC-10","CRC-11","CRC-03","RH-50-T","RH-72-T","RH-62-T","IT_19")
sc_org@meta.data <- sc_org@meta.data %>% 
  mutate(record_id = case_when(sc_org$samples=="sample_10_15" | sc_org$samples=="sample_10_30" ~ "CRC-10",
                               sc_org$samples=="sample_11_15" | sc_org$samples=="sample_11_30" ~ "CRC-11",
                               sc_org$samples=="41_G_15" | sc_org$samples=="41_G_30" | 
                                 sc_org$samples=="sample_41_1_15" | sc_org$samples=="sample_41_1_30" ~"CRC-03",
                               sc_org$samples=="sample_50_15" | sc_org$samples=="sample_50_30" ~ "RH-50-T",
                               sc_org$samples=="sample_72_15" | sc_org$samples=="sample_72_30" ~ "RH-72-T",
                               sc_org$samples=="sample_42_15" | sc_org$samples=="sample_42_30" ~ "RH-62-T",
                               sc_org$samples=="ITD19_15" | sc_org$samples=="ITD19_30" ~ "IT_19"))
# meta <- sc_org@meta.data

#Get gene annotations & rename rows
gene_annotations <- data.frame(sc_org@misc$gene_annotations)
nrow(sc_org) #62,754 genes
ncol(sc_org) #194,063 cells
rownames(sc_org)
colnames(sc_org)

# # #Load harmonized data that has been filtered from 90 to the 83 participants that have baseline single cell data
# harm_meta_data <- read.csv(fs::path(dir.dat,"Kidney scRNAseq Project","Data","harmonized_data_kidney_sc_all_metadata2.csv"))

# harm_meta_data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Data Harmonization/Data Clean/harmonized_dataset.csv",na="")
harm_meta_data <- read.csv(fs::path(dir.dat,"Data Harmonization","Data Clean/harmonized_dataset.csv",na=""))
harm_meta_data <- harm_meta_data %>%   
  arrange(screen_date) %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(record_id, visit))

##e. Filter to 6 organoid samples ----
meta <- harm_meta_data %>% 
  # dplyr::select(-X) %>% 
  filter(visit=="baseline") %>% 
  filter(record_id %in% ids)
rm(harm_meta_data)
#Select metadata from seurat object to facilitate merge of new metadata into seurat object
meta_kidney_sc <-  sc_org@meta.data
rownames(meta_kidney_sc) <- rownames(sc_org@meta.data)

#Merge metadata from 83 participants at baseline into seurat object metadata
meta_kidney_sc <- meta_kidney_sc %>%
  left_join(meta,by="record_id")
rownames(meta_kidney_sc) <- rownames(sc_org@meta.data)

#Pull ids from 83 participants at baseline to filter seurat object to these participants only 
ids <- meta$kit_id

#Merge metadata back into seurat object
sc_org <- AddMetaData(sc_org, meta_kidney_sc)

#Check number of unique ids
length(unique(sc_org$kit_id)) #should be 7

#Remove metadatasets
rm(meta_kidney_sc,meta)

# ##e. Filter to 6 organoid samples ----
# meta <- harm_meta_data %>%
#   dplyr::select(-X) %>%
#   filter(record_id %in% ids)
# rm(harm_meta_data)
# #Select metadata from seurat object to facilitate merge of new metadata into seurat object
# meta_kidney_sc <-  sc_org@meta.data
# rownames(meta_kidney_sc) <-NULL
# rownames(meta) <- NULL
# 
# #Merge metadata from 83 participants at baseline into seurat object metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(meta,by="record_id")
# rownames(meta_kidney_sc) <- rownames(sc_org@meta.data)
# 
# #Pull ids from 83 participants at baseline to filter seurat object to these participants only
# ids <- meta$record_id

# #Merge metadata back into seurat object
# sc_org <- AddMetaData(sc_org, meta_kidney_sc)
# 
# #Check number of unique ids
# length(unique(sc_org$kit_id)) #should be 7
# 
# #Remove metadatasets
# rm(meta_kidney_sc,meta)

# ##f. Merge metadata into filtered seurat object ----
# #Load in most up to date medication data to update medication information
# med <- read.xlsx(fs::path(dir.dat,"Kidney scRNAseq Project/Data/Biopsies_w_mrn_Oct3.xlsx"))
# #Select Metformin, RASSI, Insulin data
# med <- med %>%
#   dplyr::select(all_of(c("record_id","mrn","raasi_1","insulin_1","mfm_1")))
# #Pull seurat object metadata to help harmoinize in new metadata
# meta_kidney_sc <-  sc_org@meta.data
# #Filter to only those with a unique identifier id in the seurat object metadata
# med <- med %>%
#   filter(mrn %in% as.character(meta_kidney_sc$mrn))
# length(unique(med$mrn)) #6 participants
# #Filter to only those that have a unique record id in the seurat object
# med <- med %>%
#   filter(record_id %in% meta_kidney_sc$record_id)
# length(unique(med$mrn)) #7 remain
# length(unique(med$record_id)) #7
# rownames(meta_kidney_sc) <- rownames(sc_org@meta.data)
# med$mrn <- as.numeric(med$mrn) #Make numeric to merge
# #Merge med data with seurat metadata
# meta_kidney_sc <- meta_kidney_sc %>%
#   left_join(med,by=c("mrn","record_id"))
# rownames(meta_kidney_sc) <- rownames(sc_org@meta.data)
# length(unique(meta_kidney_sc$mrn)) #7 remain
# length(unique(meta_kidney_sc$record_id)) #7
# 
# #Add Med Meta Data to Seurat object
# sc_org <- AddMetaData(sc_org, meta_kidney_sc)
# #Remove med metadatset
# rm(med,meta_kidney_sc)

#Create medication & disease status groups of interest
sc_org@meta.data <- sc_org@meta.data %>%
  mutate(glp1_sglt2=ifelse(epic_glp1ra_1=="Yes" & epic_sglti2_1=="Yes","Yes","No")) %>%
  mutate(sglt2=ifelse(epic_sglti2_1=="Yes" & epic_glp1ra_1=="No","Yes","No")) %>%
  mutate(glp1=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="Yes","Yes","No")) %>%
  mutate(no_med=ifelse(epic_sglti2_1=="No" & epic_glp1ra_1=="No","Yes","No"))

#Define 4 exposure groups:
#SGLT2i(+)/GLP1RA(+), SGLT2i(+)/GLP1RA(-), SGLT2i(-)/GLPRA(+), SGLT2i(-)/GLP1RA(-)
invisible(gc())
sc_org@meta.data <- sc_org@meta.data %>%
  mutate(medication = case_when(glp1_sglt2 == "Yes" ~ "glp1_sglt2",
                                sglt2 == "Yes" ~ "sglt2",
                                glp1 == "Yes" ~ "glp1",
                                no_med == "Yes" ~ "no_med"))
sc_org@meta.data$medication <- factor(sc_org@meta.data$medication, levels = c("no_med", "sglt2", "glp1","glp1_sglt2"))

# #Ensure default assay in seurat object to RNA
DefaultAssay(sc_org) <- "RNA"
# invisible(gc())

# #Calculate cell library size for offset
# counts_layer <- round(GetAssayData(sc_org, layer = "counts")) # load counts and round
# library_size <- Matrix::colSums(counts_layer) #calculate the column sums aka the sum of all genes in each cell
# sc_org$library_size <- library_size #Put into the seurat object
# #Check that it is accessible in the metadata
# meta <- sc_org@meta.data #It should be in the dataframe, delete meta data check df
# rm(meta,counts_layer)
# hist(sc_org$library_size)

# #Perform Quality Control & Preprocessing Steps
# ncol(sc_org) #11386 cells
# nrow(sc_org) #31332 genes
nrow(sc_org) #62,754 genes before filtering
ncol(sc_org) #194,063 cells before filtering
#YE JI's filtering code for percent expression
#Filter out rare genes expressed in less than "gene_pct" of cells
# expr_matrix <- as.matrix(GetAssayData(sc_org, layer = "counts"))
# expr_matrix <- as.matrix(GetAssayData(sc_org, assay = "RNA", layer = "counts"))
expr_matrix <- GetAssayData(sc_org, assay = "RNA", layer = "counts")

# expr_matrix <- as.matrix(sc_org@assays$RNA@layers$counts)
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
remove(expr_matrix)
# Keep genes expressed in at least "gene_pct" of cells
genes_to_keep <- names(gene_proportion[gene_proportion >= 0.05])
sc_org <- subset(sc_org, features = genes_to_keep)
ncol(sc_org) #11386 Cells
nrow(sc_org) # 9209 genes

# Step 2: Remove mitochondrial genes (those starting with "MT")
mito_genes <- grep("^MT-", rownames(sc_org), value = TRUE)
#keep_ids <- unique(rownames(sc_org)[which(!rownames(sc_org) %in% mito_genes)])
# sc_org <- subset(sc_org, features = setdiff(rownames(sc_org), mito_genes))
# sc_org <- subset(sc_org,kit_id!="KL-0029535")
#sc_org$Gene <- rownames(sc_org)
#sc_org <- subset(sc_org, Gene %in% keep_ids)
sc_org <- subset(sc_org, features = setdiff(rownames(sc_org), mito_genes))
#sc_org <- subset(sc_org, features = setdiff(rownames(sc_org@assays$RNA@counts), mito_genes))
# sc_org <- subset(sc_org, !rownames(sc_org) %in% mito_genes)
# grep("^MT-", rownames(sc_org@assays$RNA@counts), value = TRUE)
# dim(sc_org@assays$RNA@counts) #9276 186125
# dim(sc_org@assays$RNA@data) #9276 186125
# dim(sc_org@assays$RNA)#9276 186125
sum(grepl("^MT-", rownames(sc_org))) #0
ncol(sc_org) #11386 cells
nrow(sc_org) #9196 genes

#Step 3: Remove ribosomal Genes
# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
)
sc_org <- subset(sc_org, features = setdiff(rownames(sc_org), ribo_genes))
# sum(grepl("^MT-", rownames(sc_org))) #0
length(which(rownames(sc_org) %in% ribo_genes)) #0
ncol(sc_org) #65,062 cells
nrow(sc_org) #15103 genes

#Renormalize & Scale after filtering
sc_org <- NormalizeData(sc_org)
sc_org <- ScaleData(sc_org, features = VariableFeatures(sc_org))

# Calculate cell library size for offset in NEBULA --------------------------------------
counts_layer <- round(GetAssayData(sc_org, layer = "counts"))
library_size <- Matrix::colSums(counts_layer)
sc_org$library_size <- library_size
# View(sc_org@meta.data)
hist(sc_org$library_size)

# # TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- log(dge$samples$lib.size) + log(dge$samples$norm.factors)
# sc_org$tmm_offset <- tmm_offset

# Pooled offset
bp <- MulticoreParam(workers = 63) 
sce <- SingleCellExperiment(assays = list(counts = counts_layer))
# sce <- computeSumFactors(sce)
sce <- computeSumFactors(sce, BPPARAM = bp)
# View size factors
# sizeFactors(sce)
# STEP 3: Calculate offset → log(size factors)
pooled_offset <- sizeFactors(sce)
sc_org$pooled_offset <- pooled_offset
hist(sc_org$pooled_offset)

# saveRDS(sc_org,fs::path(dir.dat,"scRNA","data_clean","organoid_scRNA_cleaned.RDS"))
# sc_org <- readRDS(fs::path(dir.dat,"scRNA","data_clean","organoid_scRNA_cleaned.RDS"))
#Create general hepatocyte cell type variable
#Create PT and TAL pseudobulk cell type variable
# sc_org$celltype1 <- case_when(grepl("PT-",sc_org$`ScType-Kidney-human`)~"PT",
#                                   grepl("TAL-",sc_org$`ScType-Kidney-human`)~"TAL",
#                                   grepl("EC-",sc_org$`ScType-Kidney-human`)~"EC",
#                                   grepl("POD",sc_org$`ScType-Kidney-human`)~"POD",
#                                   grepl("MAC",sc_org$`ScType-Kidney-human`)~"MAC",
#                                   grepl("MON",sc_org$`ScType-Kidney-human`)~"MON",
#                                   grepl("PC-",sc_org$`ScType-Kidney-human`)~"PC",
#                                   grepl("FIB",sc_org$`ScType-Kidney-human`)~"FIB_MC_VSMC",
#                                   grepl("DTL",sc_org$`ScType-Kidney-human`)~"DTL",
#                                   sc_org$`ScType-Kidney-human`=="DCT"~"DCT",
#                                   sc_org$`ScType-Kidney-human`=="ATL"~"ATL",
#                                   sc_org$`ScType-Kidney-human`=="B"~"B",
#                                   sc_org$`ScType-Kidney-human`=="T"~"T")
# sc_org$celltype1 <- as.character(sc_org$celltype1)

# # sc_org$KPMP_celltype2 <- as.character(sc_org$KPMP_celltype)
# sc_org$celltype2 <- ifelse(sc_org$KPMP_celltype=="Proximal tubule cells","PT",sc_org$KPMP_celltype2)))

#Create treatment variable
sc_org$treatment <- ifelse(grepl("15$",sc_org$samples),"15","30")

#Format gene names for results
gene_annotations <- gene_annotations %>% 
  dplyr::rename(Gene = `NA.`) %>%
  dplyr::select(c("Gene","input"))
rownames(gene_annotations) <- NULL

```

## b. Explore Distribution & Zero-Inflation
### i. Biopsy Data
```{r}
#Check if data have been normalized 
so_kpmp_sc@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(so_kpmp_sc, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(so_kpmp_sc, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
pdf(fs::path(dir.results,"Raw_count_gene_expression_histograms_counts_biopsy.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_kpmp_sc), 100)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_kpmp_sc, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

pdf(fs::path(dir.results,"Normalized_gene_expression_histograms_counts_biopsy.pdf"), width = 8, height = 6)

# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(so_kpmp_sc), 100)

# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))

# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(so_kpmp_sc, layer = "data")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Normalized Expression")     # Label for x-axis
}

# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(so_kpmp_sc, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(so_kpmp_sc, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=300, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 10))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)

```

### ii. Organoid Data
```{r}
#Check if data have been normalized 
sc_org@assays  # Should show e.g., "RNA" with "counts" and "data"
head(GetAssayData(sc_org, layer = "counts")[, 1:5])  # Raw counts
head(GetAssayData(sc_org, layer = "data")[, 1:5])    # Normalized data

#Check for normality
# Open a PDF device (all plots go here)
pdf(fs::path(dir.results,"Organoid_Raw_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(sc_org), 100)
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))
# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(sc_org, layer = "counts")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Raw Counts Expression")     # Label for x-axis
}
# Close the PDF device — this writes the file to disk
dev.off()

pdf(fs::path(dir.results,"Organoid_Normalized_gene_expression_histograms_counts.pdf"), width = 8, height = 6)
# Randomly select 100 genes from the Seurat object
genes <- sample(rownames(sc_org), 100)
# Set up a 2x3 plotting layout so you can plot multiple histograms in one figure
par(mfrow = c(2, 3))
# Loop over each randomly selected gene
for (g in genes) {
  
  # Plot a histogram of the expression values for gene 'g'
  # using normalized expression values from the "data" slot
  hist(GetAssayData(sc_org, layer = "data")[g, ],
       main = g,                # Title of the plot = gene name
       xlab = "Expression")     # Label for x-axis
}
# Close the PDF device — this writes the file to disk
dev.off()

#Check for zero inflation
pdf(fs::path(dir.results,"Organoid_Zero_Inflation_Visualization.pdf"), width = 8, height = 6)
counts <- GetAssayData(sc_org, layer = "counts")
zero_prop <- rowMeans(counts == 0)
hist(zero_prop, main = "Proportion of Zeros for Genes", xlab = "Zero Proportion")
# Add a vertical line at 50%
abline(v = 0.5, col = "red", lwd = 2, lty = 2)
dev.off()

#Check for overdispersion
# Use raw counts
counts <- GetAssayData(sc_org, layer = "counts")

# Pick a few genes or do this genome-wide
gene_means <- rowMeans(counts)
gene_vars <- apply(counts, 1, var)

# Dispersion estimate (Var / Mean)
dispersion <- gene_vars / gene_means

# Filter to only genes where mean > 0 (to avoid divide-by-zero)
valid_genes <- gene_means > 0
dispersion <- dispersion[valid_genes]

# View distribution
pdf(fs::path(dir.results,"Organoid_Overdispersion_Visualization.pdf"), width = 8, height = 6)
hist(dispersion, breaks=300, main="Dispersion across genes", xlab="Dispersion (Var / Mean)",xlim = c(0, 10))
abline(v = 1, col="red")  # Poisson expectation
dev.off()

# Check how many genes have dispersion > 1
overdispersed_genes <- sum(dispersion > 1)
total_genes <- length(dispersion)
percent_overdispersed <- (overdispersed_genes / total_genes) * 100

# Print summary and recommendation
print(paste0("Overdispersed genes: ", 
             overdispersed_genes, 
             " out of ", 
             total_genes, 
             " (", 
             round(percent_overdispersed, 3), 
             "%)"))

if (percent_overdispersed > 10) {
  print("✅ Overdispersion detected. Consider using a Negative Binomial model.")
} else {
  print("ℹ️ Little evidence of overdispersion. Poisson model may be sufficient.")
}
rm(counts)


```

## c. Select Highly Variable Genes (HVGs)
```{r}
# so_kpmp_sc <- FindVariableFeatures(so_kpmp_sc, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_kpmp_sc)
# 
# # Subset Seurat object to only HVGs
# so_kpmp_sc_hvg <- subset(so_kpmp_sc, features = hvgs)
```

# 3. Visualize & Descriptive Stats
## a. UMAPS & Barcharts 
###i. Biopsy
```{r}
# PCA
so_kpmp_sc <- FindVariableFeatures(object = so_kpmp_sc)
so_kpmp_sc <- RunPCA(so_kpmp_sc, features = VariableFeatures(object = so_kpmp_sc),assay="RNA")
ElbowPlot(so_kpmp_sc)

# # Find neighbors and clusters (again using integrated data)
so_kpmp_sc <- FindNeighbors(so_kpmp_sc, assay = "RNA", dims = 1:20)
so_kpmp_sc <- FindClusters(so_kpmp_sc, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
so_kpmp_sc@reductions
DimPlot(so_kpmp_sc, reduction = "umap.harmony", raster = F)

DimPlot(so_kpmp_sc, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = FALSE)


plot1 <- DimPlot(so_kpmp_sc, reduction = "umap.harmony", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("Harmony UMAP Plot with Cell Type Labels")

png(fs::path(dir.results,"UMAP_Celltypes_Biopsy.png"),width = 5000, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(plot1)
dev.off()

so_kpmp_sc$group <- factor(so_kpmp_sc$group)
plot2 <- DimPlot(so_kpmp_sc, reduction = "umap.harmony",group.by = "group",label=F,raster=F) +
  ggtitle(paste0("UMAP by Disease Category"))

png(fs::path(dir.results,"UMAP_Celltypes_Biopsy_by_DiseaseStatus.png"),width = 5000, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(plot2)
dev.off()

DimPlot(so_kpmp_sc, reduction = "umap.rpca", raster = F)
DimPlot(so_kpmp_sc, reduction = "umap.rpca", group.by = "KPMP_celltype", raster = FALSE)
DimPlot(so_kpmp_sc, reduction = "umap.rpca", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("rpca UMAP Plot with Cell Type Labels")

so_kpmp_sc$group <- factor(so_kpmp_sc$group)
DimPlot(so_kpmp_sc, reduction = "umap.rpca",group.by = "group",label=F,raster=F) +
  ggtitle(paste0("rpca UMAP by Disease Category"))

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "PT")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
# cellcount <- cellcount %>% 
#   filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_PT_Cells_by_Group.png"),width = 2500, height = 2500, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1 )
dev.off()

#Individual
prop_plot1 <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Kidney Biopsy")+
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_PT_Cells_by_Individual.png"),width = 3500, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

prop_plot2 <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Individual") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot2 

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(celltype2 == "TAL")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
# cellcount <- cellcount %>%
#   filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_TAL_Cells_by_Group.png"),width = 2500, height = 2500, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

#Individual
prop_plot1 <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Kidney Biopsy") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_TAL_Cells_by_Individual.png"),width = 3500, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- so_kpmp_sc@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1
rm(cellcount,plot1,prop_plot1)

```
###ii. Organoid
```{r}
# PCA
sc_org <- NormalizeData(sc_org)
sc_org <- ScaleData(sc_org, features = VariableFeatures(sc_org))
sc_org <- FindVariableFeatures(object = sc_org)
sc_org <- RunPCA(sc_org, features = VariableFeatures(object = sc_org),assay="RNA")
ElbowPlot(sc_org)

# # Find neighbors and clusters (again using integrated data)
sc_org <- FindNeighbors(sc_org, assay = "RNA", dims = 1:20)
sc_org <- FindClusters(sc_org, resolution = 0.5)

# Perform UMAP and tSNE
# so_liver_sc <- RunUMAP(so_liver_sc, dims = 1:15)
sc_org@reductions
DimPlot(sc_org, reduction = "umap", raster = F)

DimPlot(sc_org, reduction = "umap", group.by = "ScType-Kidney-human", raster = FALSE)
png(fs::path(dir.results,"UMAP_Celltypes_Organoid.png"),width = 5000, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(DimPlot(sc_org, reduction = "umap", group.by = "ScType-Kidney-human", raster = FALSE))
dev.off()

plot1 <- DimPlot(sc_org, reduction = "umap", group.by = "ScType-Kidney-human",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("UMAP Plot with Cell Type Labels")

png(fs::path(dir.results,"UMAP_Celltypes_Biopsy.png"),width = 5000, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(plot1)
dev.off()

sc_org$group <- factor(sc_org$group)
plot2 <- DimPlot(sc_org, reduction = "umap",group.by = "group",label=F,raster=F) +
  ggtitle(paste0("UMAP by Disease Category"))

png(fs::path(dir.results,"UMAP_Celltypes_Organoid_by_DiseaseStatus.png"),width = 5000, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(plot2)
dev.off()

DimPlot(sc_org, reduction = "umap.rpca", raster = F)
DimPlot(sc_org, reduction = "umap.rpca", group.by = "KPMP_celltype", raster = FALSE)
DimPlot(sc_org, reduction = "umap.rpca", group.by = "KPMP_celltype",raster = FALSE, label = TRUE, label.size = 4)+
  ggtitle("rpca UMAP Plot with Cell Type Labels")

sc_org$group <- factor(sc_org$group)
DimPlot(sc_org, reduction = "umap",group.by = "group",label=F,raster=F) +
  ggtitle(paste0("rpca UMAP by Disease Category"))

#Barcharts of proportions
# By PT subtypes
cellcount <- sc_org@meta.data 
  # filter(`ScType-Kidney-human` == "Proximal tubule cells")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
# cellcount <- cellcount %>% 
#   filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = `ScType-Kidney-human`)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") 
  # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_Cells_by_Group.png"),width = 3000, height = 2500, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1 )
dev.off()

#Individual
prop_plot1 <- ggplot(data=cellcount,aes(samples, fill = `ScType-Kidney-human`)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Kidney Organoids")
  # scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_PT_Cells_by_Individual.png"),width = 4500, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

prop_plot2 <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Individual") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot2 

#Barcharts of proportions
# By PT subtypes
cellcount <- sc_org@meta.data %>% 
  filter(celltype2 == "TAL")

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
# cellcount <- cellcount %>%
#   filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_TAL_Cells_by_Group.png"),width = 2500, height = 2500, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

#Individual
prop_plot1 <- ggplot(data=cellcount,aes(record_id, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Kidney Biopsy") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1 
png(fs::path(dir.results,"Barchart_TAL_Cells_by_Individual.png"),width = 3500, height = 3000, res=300)
# pdf(plot1,fs::path(dir.results,"UMAP_Celltypes_Organoid_Samples.pdf"),width=10,height=10)
plot(prop_plot1)
dev.off()

#Barcharts of proportions
# By PT subtypes
cellcount <- sc_org@meta.data %>% 
  filter(grepl("EC-",KPMP_celltype) | grepl("EC/VSMC",KPMP_celltype))

label(cellcount$group) <- "Disease Status"
# label(cellcount$steatosis_cat) <- "Steatosis Category"
# cellcount$group <- ifelse(cellcount$group=="0+1", "Low Steatosis (0+1)","High Steatosis (2+3)")
# cellcount$group <- factor(cellcount$group,levels=c("Lean_Control","Obese_Control","Type_1_Diabetes","Type_2_Diabetes"),labels=c("Lean Controls","Obese Controls","Type 1 Diabetes","Type 2 Diabetes"))
# cellcount$KPMP_celltype2 <- factor(cellcount$KPMP_celltype2,levels=c("PT-S1/S2","PT-S3","aPT"),labels=c("PT-S1/S2","PT-S3","aPT"))
cellcount <- cellcount %>%
  filter(group!="Obese Controls")

prop_plot1 <- ggplot(data=cellcount,aes(group, fill = KPMP_celltype)) + 
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion of Cells",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Disease Status") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51","darkred"))

prop_plot1
rm(cellcount,plot1,prop_plot1)

```

## b. Descriptive Statistics 
```{r}
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  mutate(group=as.character(group)) %>% 
  arrange(screen_date) %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, first(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, first(na.omit(.x)))),
                   .by = c(record_id, visit))

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
# dat$group 

#Table 1. 
table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication + eGFR_CKD_epi +acr_u +epic_mfm_1+epic_insulin_1| group, data=dat)


table1(~ age + sex + race_ethnicity  + bmi + triglycerides + hba1c + medication| record_id, data=dat)
table1(~pah_clear_bsa + eGFR_CKD_epi +acr_u +mfm_1+insulin_1| record_id, data=dat)

#Covariates to adjust for: 
#Acru, metformin/insulin,bmi,age,tg
#Although check on metformin/insulin variables...
```

## c. Evaluate Covariates before Adjustment
```{r}
#Categorical Covariates
#Get metadata for everyone
dat <- so_kpmp_sc@meta.data %>%
  group_by(record_id) %>%
  summarise(across(everything(), first)) %>%
  ungroup() 

dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
dat$hba1c <- as.numeric(dat$hba1c)
dat$eGFR_CKD_epi <- as.numeric(dat$eGFR_CKD_epi)
label(dat$hba1c) <- "HbA1c (%)"
label(dat$age) <- "Age (Years)"
label(dat$sex) <- "Sex"
label(dat$race_ethnicity) <- "Race/Ethnicity"
label(dat$bmi) <- "BMI (kg/m2)"
label(dat$triglycerides) <- "Triglycerides (mg/dL)"
label(dat$medication) <- "GLP-1/SGLT2i Status"
label(dat$epic_mfm_1) <- "Metformin"
label(dat$epic_insulin_1) <- "Insulin"
label(dat$pah_clear_bsa) <- "PAH Clearance (BSA)"
label(dat$eGFR_CKD_epi) <- "Estimated Glomerular Filtration Rate (eGFR)"
label(dat$acr_u) <- "ACRu"
# label(dat$SGLT2) <- "SGLT2i"
label(dat$group) <- "Type 2 Diabetes Status"


cat_covariates <- c("sex", "race_ethnicity","epic_mfm_1","epic_insulin_1")
plot_list <- list()

custom_colors <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51", "darkred")

png(fs::path(dir.results, "Plot_Categorical_Covariates_NoMed.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in cat_covariates) {
  p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
    geom_bar(position = "fill") +  # use "dodge" for absolute counts
    labs(y = "Proportion", x = NULL) +
    # title = paste0("Distribution of ", covariate, " by Diabetes Status")
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plot_list[[covariate]] <- p
}

# Display all plots together (adjust depending on how many you have)
wrap_plots(plot_list, ncol = 2)
dev.off()

#Continuous Covariates
con_covariates <- c("age", "bmi", "triglycerides", "hba1c","pah_clear_bsa","eGFR_CKD_epi","gfr_bsa_plasma","acr_u")
# "avg_c_k2","avg_c_f","avg_m_k2","avg_m_f","avg_c_k2_f","avg_m_k2_f")
plot_list <- list()
custom_colors <- c("#f4a261", "darkred")

# Display all plots together (adjust ncol/nrow as needed)
png(fs::path(dir.results, "Plot_Continuous_Covariates_NoMed.png"),
    width = 3000, height = 3000, res = 300)
for (covariate in con_covariates) {
  p <- ggplot(dat, aes_string(x = "group", y = covariate, fill = "group")) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
    scale_fill_manual(values = custom_colors) +
    theme_minimal() +
    theme(legend.position = "none")
  
  plot_list[[covariate]] <- p
}
wrap_plots(plot_list, ncol = 2 )
dev.off()

# cat_covariates <- c("sex", "race_ethnicity", "medication", "epic_mfm_1", "epic_insulin_1")
# plot_list <- list()
# 
# for (covariate in cat_covariates) {
#   p <- ggplot(dat, aes_string(x = "group", fill = covariate)) +
#     geom_bar(position = "fill") +  # use "dodge" for absolute counts
#     labs(title = paste0("Distribution of ", covariate),
#          y = "Proportion", x = NULL) +
#     scale_y_continuous(labels = scales::percent_format()) +
#     theme_minimal() +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1))
#   
#   plot_list[[covariate]] <- p
# }
# 
# # Display all plots together (adjust depending on how many you have)
# wrap_plots(plot_list, ncol = 2)
# 
# 
# #Continuous Covariates
# con_covariates <- c("age", "bmi", "triglycerides", "hba1c", "pah_clear_bsa", "eGFR_CKD_epi", "acr_u")
# plot_list <- list()
# 
# for (covariate in con_covariates) {
#   p <- ggplot(dat, aes_string(x = "group", y = covariate, fill = "group")) +
#     geom_boxplot(outlier.shape = NA, alpha = 0.7) +
#     geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # optional: show points
#     labs(title = paste0("Distribution of ", covariate),
#          x = "Group", y = covariate) +
#     theme_minimal() +
#     theme(legend.position = "none")
#   
#   plot_list[[covariate]] <- p
# }
# 
# # Display all plots together (adjust ncol/nrow as needed)
# wrap_plots(plot_list, ncol = 3)
```

#4. Analysis 
##I. Biopsy
## PT Cells 
##a. PT Cells all
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,celltype2=="PT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_PT_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "PT, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_PT_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_PT_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
# list.files(bg_path)
# gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
# gmt_files
# kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
# reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
# go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
# 
# # rank genes by t-stats in DiD
# rankings_PT <- full_results$LogFC
# names(rankings_PT) <- full_results$Gene
# rankings_PT <- sort(rankings_PT, decreasing = TRUE)
# plot(rankings_PT)
# min(rankings_PT)
# max(rankings_PT)
# 
# 
# set.seed(1234)
# 
# kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
#                             stats = rankings_PT,
#                             scoreType = 'std', 
#                             minSize = 3,
#                             maxSize = 500,
#                             nproc = 1)
# 
# reactome_res_PT <- fgsea(pathways = reactome,
#                          stats = rankings_PT,
#                          scoreType = 'std', 
#                          minSize = 3,
#                          maxSize = 500,
#                          nproc = 1)
# go_res_PT <- fgsea(pathways = go,
#                    stats = rankings_PT,
#                    scoreType = 'std', 
#                    minSize = 5,
#                    maxSize = 500,
#                    nproc = 1)
# 
# PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
#                        "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
#                        "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
# rownames(PT_fgsea) <- c("adj.pval", "p.val")
# 
# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
# #        width = 13, height = 10, scale = 1)
# 
# ##### REACTOME
# b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
# #        width = 13, height = 10, scale = 1)
# ##### GO
# c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
# #        width = 13, height = 10, scale = 1)
# 
# combined_plot <- b + c + plot_layout(ncol = 1)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 15, height = 20, scale = 1)
# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Biopsy_PT_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iii. Targeted Gene
```{r}
#GENES: ROBO4 and FN1
target_genes <- c("ROBO4","FN1")
so_celltype <- subset(so_kpmp_sc,celltype2=="PT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

# ## Select Highly Variable Genes (HVGs)
# so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- target_genes

cl <- makeCluster(2)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)




```

##b. aPT 
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aPT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_aPT_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "aPT, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_aPT_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_aPT_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "aPT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "aPT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_aPT_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

## c. PT-S1/S2 
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S1/S2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_PT_S1_S2_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "PT-S1/S2, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_PT_S1_S2_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```

### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_PT_S1_S2_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-1/2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-1/2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_PT_S1_S2_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

## d. PT-S3 
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="PT-S3")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_PT_S3_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "PT-S3, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")

volcano_plot

png(fs::path(dir.results, "Plot_Biopsy_NEBULA_PT_S3_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_PT_S3_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT-S3 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT-S3 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_PT_S3_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```


## TAL
## a. TAL Cells all
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,celltype2=="TAL")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_TAL_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "TAL, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_TAL_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_TAL_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "TAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "TAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_TAL_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

## b. C-TAL-1 
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-1")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_C_TAL_1_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "C-TAL-1, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_C_TAL_1_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_C_TAL_1_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "TAL-1 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "TAL-1 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_C_TAL_1_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```
### iii. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-1")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

# ## Select Highly Variable Genes (HVGs)
# so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
rownames(so_celltype)[which(grepl("ROB",rownames(so_celltype)))]
rownames(so_celltype)[which(grepl("FN1",rownames(so_celltype)))]

genes_list <- c("FN1")

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Biopsy_NEBULA_C_TAL_1_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "C-TAL-1, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Targeted_Plot_Biopsy_NEBULA_C_TAL_1_Diabetes.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```

## c. C-TAL-2
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_C_TAL_2_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "C-TAL-2, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_C_TAL_2_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_C_TAL_2_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "TAL-2 Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "TAL-2 Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_C_TAL_2_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```
### iii. Targeted Genes
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="C-TAL-2")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

# ## Select Highly Variable Genes (HVGs)
# so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- c("FN1")

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Targeted_Biopsy_NEBULA_C_TAL_2_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "C-TAL-2, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Targeted_Plot_Biopsy_NEBULA_C_TAL_2_Diabetes.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```

## d. dTAL
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="dTAL")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_dTAL_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "dTAL, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_dTAL_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_dTAL_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "dTAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "dTAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_dTAL_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

## e. aTAL
### i. NEBULA
```{r}
#Filter to PT Cells
so_celltype <- subset(so_kpmp_sc,KPMP_celltype=="aTAL")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(20)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType_2_Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType_2_Diabetes`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,"Biopsy_NEBULA_aTAL_cells_diabetes_unadjusted_2000.csv"))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType_2_Diabetes` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]

Genes <- length(unique(full_results$gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType_2_Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType_2_Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType_2_Diabetes`)
# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType_2_Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = "aTAL, Unadjusted (REML, Log Normal, Offset)",
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-5,5)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, "Plot_Biopsy_NEBULA_aTAL_Diabetes_unadjusted_2000_offset.png"), 
    width = 3000, height = 2100, res = 300)
print(volcano_plot)
dev.off()

```
### ii. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_aTAL_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "aTAL Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "aTAL Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Pathways_Biopsy_aTAL_top30_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

## II. Organoid
### i. NEBULA
#### a. 15
```{r}
#15 glucose
so_subset <- subset(sc_org,treatment=="15")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

# nrow(so_celltype) #9196 genes
# ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")

# so_celltype$treatment <- factor(so_celltype$treatment)

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round



# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(60)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset,verbose=TRUE)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40|PT_nebula_converged$Convergence_Code==-50|PT_nebula_converged$Convergence_Code==-60)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries) %>% 
  dplyr::select(-Gene) %>% 
  dplyr::rename(input=gene)

#Change gene names
full_results <- tidylog::left_join(full_results,gene_annotations,by="input")

#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!input %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
  # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment15`,method="fdr"))
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# full_results$PValue10_int <- -log10(pmax(full_results$`p_groupType 2 Diabetes:treatment15`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,paste0("Organoid_NEBULA_",celltype,"_diabetes_lc_treatment15_adj_2000.csv")))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType 2 Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType 2 Diabetes` < 0, "#003366", "gray"))
# full_results$color_int <- ifelse(full_results$fdr_int < 0.05 & full_results$`logFC_groupType 2 Diabetes:treatment15` > 0, "#990000",
#                              ifelse(full_results$fdr_int < 0.05 & full_results$`logFC_groupType 2 Diabetes:treatment15` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# significant_df_int <- full_results[full_results$fdr_int < 0.05, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType 2 Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType 2 Diabetes`)

# max_int <- max(full_results$`logFC_groupType 2 Diabetes:treatment15`)
# max <- 3.1
# min_int <- min(full_results$`logFC_groupType 2 Diabetes:treatment15`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType 2 Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 15 (REML, Log Normal, Pooled Offset)"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  # xlim(min,max)+
  xlim(-3,3)+
  ylim(0,11)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot
# 
# volcano_plot_int <- ggplot(full_results, aes(x = `logFC_groupType 2 Diabetes:treatment15`, y = PValue10_int, color = color_int)) +
#   geom_point(alpha = 0.7) +  # Plot points with transparency
#   scale_color_identity() +  # Use the color column directly
#   theme_minimal() +  # Minimal theme
#   labs(
#     title = "Type 2 Diabetes vs. Lean Controls Interaction with Treatment",
#     subtitle = paste0(celltype,", Unadjusted (REML, Log Normal, Pooled Offset)"),
#     x = "Treatment Interaction FC",
#     y = "-log10(P-Value)",
#     color = "Treatment Interaction FC Direction Direction",
#     caption = paste0("FDR Interaction < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.x = element_text(angle = 0, hjust = 1)
#   )+
#   # xlim(min_int,max_int)+
#   xlim(-3,3)+
#   # # Add labels for significant points
#   geom_text(data = significant_df_int, aes(label = Gene),
#             vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

# volcano_plot_int

# combined_plot <- volcano_plot + volcano_plot_int + plot_layout(ncol = 2)

# pdf(fs::path(dir.results,"Plot_NEBULA_PT_Diabetes_unadjusted_2000_hvg.pdf"),width=10,height=7)
# print(volcano_plot)
# dev.off()
png(fs::path(dir.results, paste0("Plot_Organoid_NEBULA_",celltype,"_Diabetes_lc_2000_offset_15.png")), 
    width = 1500, height = 2100, res = 150)
print(volcano_plot)
dev.off()
}
```

#### b. 30
```{r}
#30 glucose
so_subset <- subset(sc_org,treatment=="30")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

# nrow(so_celltype) #9196 genes
# ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")

# so_celltype$treatment <- factor(so_celltype$treatment)

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round



# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- hvgs

cl <- makeCluster(60)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1,model="NBLMM",reml=1,output_re = T,covariance=T,offset=data_g_gene$offset)
    #model="NBLMM",reml=T
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40|PT_nebula_converged$Convergence_Code==-50|PT_nebula_converged$Convergence_Code==-60)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries) %>% 
  dplyr::select(-Gene) %>% 
  dplyr::rename(input=gene)

#Change gene names
full_results <- tidylog::left_join(full_results,gene_annotations,by="input")

#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!input %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
  # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment30`,method="fdr"))
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# full_results$PValue10_int <- -log10(pmax(full_results$`p_groupType 2 Diabetes:treatment30`, 1e-10))  # Avoid log(0)

write.csv(full_results,fs::path(dir.results,paste0("Organoid_NEBULA_",celltype,"_diabetes_lc_treatment30_adj_2000_LME.csv")))

full_results$color <- ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType 2 Diabetes` > 0, "#990000",
                             ifelse(full_results$fdr < 0.05 & full_results$`logFC_groupType 2 Diabetes` < 0, "#003366", "gray"))
# full_results$color_int <- ifelse(full_results$fdr_int < 0.05 & full_results$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
#                              ifelse(full_results$fdr_int < 0.05 & full_results$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- full_results[full_results$fdr < 0.05, ]
# significant_df_int <- full_results[full_results$fdr_int < 0.05, ]

Genes <- length(unique(full_results$Gene))
Cells <- ncol(so_celltype)
Nonconvergence_Rate <- nebula_nonconverged_percent
# full_results$color3 <- ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(full_results$fdr3 < 0.2 & full_results$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- full_results[full_results$fdr3 < 0.2, ]

max <- max(full_results$`logFC_groupType 2 Diabetes`)
# max <- 3.1
min <- min(full_results$`logFC_groupType 2 Diabetes`)

# max_int <- max(full_results$`logFC_groupType 2 Diabetes:treatment30`)
# max <- 3.1
# min_int <- min(full_results$`logFC_groupType 2 Diabetes:treatment30`)

# Create the volcano plot using ggplot
volcano_plot <- ggplot(full_results, aes(x = `logFC_groupType 2 Diabetes`, y = PValue10, color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 30 (NBLMM, REML, Pooled Offset)"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells,", Non-Convergence Rate: ",Nonconvergence_Rate,", Genes Filtered out for Low Expression: ",low_exp)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-3,3)+
  ylim(0,11)+
  # # Add labels for significant points
  geom_text(data = significant_df, aes(label = Gene),
            vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
# geom_text_repel(data = significant_df, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)

volcano_plot

png(fs::path(dir.results, paste0("Plot_Organoid_NEBULA_",celltype,"_Diabetes_lc_2000_offset_30_NBLMM_REML.png")), 
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
}
```

### ii. Find Markers
#### a. 15 Glucose
```{r}
#15 glucose
so_subset <- subset(sc_org,treatment=="15")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

# nrow(so_celltype) #9196 genes
# ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
so_celltype <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype) <- "RNA"

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")

# so_celltype$treatment <- factor(so_celltype$treatment)

# counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

#Find markers
# Set identities to the 'group' column
Idents(so_celltype) <- "group"
markers <- FindMarkers(
  object = so_celltype,
  ident.1 = "Type 2 Diabetes",
  ident.2 = "Lean Control",  # optional: if omitted, compared to all other cells
  # group.by = "group",  # optional
  min.pct = 0,      # only test genes expressed in >10% of cells
  logfc.threshold = 0  # only return genes with log2FC > 0.25
)

markers$input <- rownames(markers)
markers <- tidylog::left_join(markers,gene_annotations,by="input")

# ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj))) +
#   geom_point(aes(color = p_val_adj < 0.05 & abs(avg_log2FC) > 0.25), alpha = 0.6) +
#   scale_color_manual(values = c("grey", "red")) +
#   theme_minimal() +
#   labs(
#     title = "Volcano Plot: T2D vs Lean Control",
#     x = "Log2 Fold Change",
#     y = "-log10 Adjusted p-value"
#   ) +
#   theme(legend.position = "none")


# markers <- markers %>%
#   mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
  # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment30`,method="fdr"))
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
# markers$PValue10 <- -log10(pmax(markers$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# markers$PValue10_int <- -log10(pmax(markers$`p_groupType 2 Diabetes:treatment30`, 1e-10))  # Avoid log(0)

write.csv(markers,fs::path(dir.results,paste0("Organoid_FindMarkers_",celltype,"_diabetes_lc_treatment15_adj_2000.csv")))

markers$color <- ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC > 0, "#990000",
                             ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC < 0, "#003366", "gray"))
# markers$color_int <- ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
#                              ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- markers[markers$p_val_adj < 0.05, ]
# significant_df_int <- markers[markers$fdr_int < 0.05, ]

Genes <- length(unique(markers$Gene))
Cells <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# markers$color3 <- ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- markers[markers$fdr3 < 0.2, ]

top_up <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC > 0) %>%
  arrange(p_val_adj, desc(avg_log2FC)) %>%
  head(10)

top_down <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC < 0) %>%
  arrange(p_val_adj, avg_log2FC) %>%
  head(10)

top_markers <- bind_rows(top_up, top_down)

max <- max(markers$avg_log2FC)
# max <- 3.1
min <- min(markers$avg_log2FC)


# Create the volcano plot using ggplot
volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 15"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "Log2FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-3,3)+
  # ylim(0,11)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
geom_text_repel(data = top_markers, aes(label = Gene),
                size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # geom_text_repel(data = top_markers, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = Inf)

volcano_plot



png(fs::path(dir.results, paste0("Plot_Organoid_FindMarkers_",celltype,"_Diabetes_lc_2000_treatment_15.png")), 
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
}
```

#### b. 30 Glucose
```{r}
#15 glucose
so_subset <- subset(sc_org,treatment=="30")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

# nrow(so_celltype) #9196 genes
# ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
so_celltype <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype) <- "RNA"

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")

# so_celltype$treatment <- factor(so_celltype$treatment)

# counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

#Find markers
# Set identities to the 'group' column
Idents(so_celltype) <- "group"
markers <- FindMarkers(
  object = so_celltype,
  ident.1 = "Type 2 Diabetes",
  ident.2 = "Lean Control",  # optional: if omitted, compared to all other cells
  # group.by = "group",  # optional
  min.pct = 0,      # only test genes expressed in >10% of cells
  logfc.threshold = 0  # only return genes with log2FC > 0.25
)

markers$input <- rownames(markers)
markers <- tidylog::left_join(markers,gene_annotations,by="input")

# ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj))) +
#   geom_point(aes(color = p_val_adj < 0.05 & abs(avg_log2FC) > 0.25), alpha = 0.6) +
#   scale_color_manual(values = c("grey", "red")) +
#   theme_minimal() +
#   labs(
#     title = "Volcano Plot: T2D vs Lean Control",
#     x = "Log2 Fold Change",
#     y = "-log10 Adjusted p-value"
#   ) +
#   theme(legend.position = "none")


# markers <- markers %>%
#   mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
  # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment30`,method="fdr"))
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
# markers$PValue10 <- -log10(pmax(markers$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# markers$PValue10_int <- -log10(pmax(markers$`p_groupType 2 Diabetes:treatment30`, 1e-10))  # Avoid log(0)

write.csv(markers,fs::path(dir.results,paste0("Organoid_FindMarkers_",celltype,"_diabetes_lc_treatment30_adj_2000.csv")))

markers$color <- ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC > 0, "#990000",
                             ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC < 0, "#003366", "gray"))
# markers$color_int <- ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
#                              ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- markers[markers$p_val_adj < 0.05, ]
# significant_df_int <- markers[markers$fdr_int < 0.05, ]

Genes <- length(unique(markers$Gene))
Cells <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# markers$color3 <- ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- markers[markers$fdr3 < 0.2, ]

top_up <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC > 0) %>%
  arrange(p_val_adj, desc(avg_log2FC)) %>%
  head(10)

top_down <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC < 0) %>%
  arrange(p_val_adj, avg_log2FC) %>%
  head(10)

top_markers <- bind_rows(top_up, top_down)

max <- max(markers$avg_log2FC)
# max <- 3.1
min <- min(markers$avg_log2FC)


# Create the volcano plot using ggplot
volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 30"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "Log2FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-3,3)+
  # ylim(0,11)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
geom_text_repel(data = top_markers, aes(label = Gene),
                size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # geom_text_repel(data = top_markers, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = Inf)

volcano_plot



png(fs::path(dir.results, paste0("Plot_Organoid_FindMarkers_",celltype,"_Diabetes_lc_2000_30.png")), 
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
}
```

### iii. Pseudobulk
#### a. 15 Glucose
```{r}
#15 glucose
so_subset <- subset(sc_org,treatment=="15")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

# nrow(so_celltype) #9196 genes
# ncol(so_celltype) #2127 cells

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
so_celltype <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype) <- "RNA"

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")

# so_celltype$treatment <- factor(so_celltype$treatment)

# counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

#Find markers
# Set identities to the 'group' column
Idents(so_celltype) <- "group"
markers <- FindMarkers(
  object = so_celltype,
  ident.1 = "Type 2 Diabetes",
  ident.2 = "Lean Control",  # optional: if omitted, compared to all other cells
  # group.by = "group",  # optional
  min.pct = 0,      # only test genes expressed in >10% of cells
  logfc.threshold = 0  # only return genes with log2FC > 0.25
)

markers$input <- rownames(markers)
markers <- tidylog::left_join(markers,gene_annotations,by="input")

# ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj))) +
#   geom_point(aes(color = p_val_adj < 0.05 & abs(avg_log2FC) > 0.25), alpha = 0.6) +
#   scale_color_manual(values = c("grey", "red")) +
#   theme_minimal() +
#   labs(
#     title = "Volcano Plot: T2D vs Lean Control",
#     x = "Log2 Fold Change",
#     y = "-log10 Adjusted p-value"
#   ) +
#   theme(legend.position = "none")


# markers <- markers %>%
#   mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
  # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment30`,method="fdr"))
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
# markers$PValue10 <- -log10(pmax(markers$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# markers$PValue10_int <- -log10(pmax(markers$`p_groupType 2 Diabetes:treatment30`, 1e-10))  # Avoid log(0)

write.csv(markers,fs::path(dir.results,paste0("Organoid_FindMarkers_",celltype,"_diabetes_lc_treatment15_adj_2000.csv")))

markers$color <- ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC > 0, "#990000",
                             ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC < 0, "#003366", "gray"))
# markers$color_int <- ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
#                              ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- markers[markers$p_val_adj < 0.05, ]
# significant_df_int <- markers[markers$fdr_int < 0.05, ]

Genes <- length(unique(markers$Gene))
Cells <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# markers$color3 <- ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- markers[markers$fdr3 < 0.2, ]

top_up <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC > 0) %>%
  arrange(p_val_adj, desc(avg_log2FC)) %>%
  head(10)

top_down <- markers %>%
  filter(p_val_adj < 0.05, avg_log2FC < 0) %>%
  arrange(p_val_adj, avg_log2FC) %>%
  head(10)

top_markers <- bind_rows(top_up, top_down)

max <- max(markers$avg_log2FC)
# max <- 3.1
min <- min(markers$avg_log2FC)


# Create the volcano plot using ggplot
volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 15"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "Log2FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-3,3)+
  # ylim(0,11)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
geom_text_repel(data = top_markers, aes(label = Gene),
                size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # geom_text_repel(data = top_markers, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = Inf)

volcano_plot



png(fs::path(dir.results, paste0("Plot_Organoid_FindMarkers_",celltype,"_Diabetes_lc_2000_treatment_15.png")), 
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()
}
```

#### b. 30 Glucose
```{r}
#30 glucose
so_subset <- subset(sc_org,treatment=="30")
#Filter to celltype of interest
celltypes <- unique(so_subset$`ScType-Kidney-human`)
for (celltype in celltypes) {
so_celltype <- subset(so_subset,`ScType-Kidney-human`==celltype)
DefaultAssay(so_celltype) <- "RNA" 

## Select Highly Variable Genes (HVGs)
so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
so_celltype <- subset(so_celltype, features = hvgs)
DefaultAssay(so_celltype) <- "RNA"


# library(Matrix)
# library(dplyr)

# Add a unique pseudobulk ID: e.g. donor_group or sample_type_group
so_celltype$sample_id <- paste0(so_celltype$record_id, "_", so_celltype$group)

# Get raw counts
# counts <- GetAssayData(so_celltype, slot = "counts")
counts <- round(GetAssayData(so_celltype, layer = "counts")) 

# Create named list of cells by sample
cell_groups <- split(colnames(so_celltype), so_celltype$sample_id)

# Pseudobulk: sum counts for each gene across cells in each sample_id
pseudobulk_counts <- sapply(cell_groups, function(cells) {
  Matrix::rowSums(counts[, cells, drop = FALSE])
})

# Convert to matrix (genes x pseudobulk samples)
pseudobulk_counts <- as.matrix(pseudobulk_counts)



# Get raw counts (RNA assay assumed)
# counts <- GetAssayData(so_celltype, slot = "counts")
# counts <- round(GetAssayData(so_celltype, layer = "counts")) 

# Set identities if not already set
so_celltype$group <- str_replace_all(so_celltype$group," ","_")
so_celltype$group <- factor(so_celltype$group)
Idents(so_celltype) <- "group"

# Metadata must match column names of count matrix
metadata <- so_celltype@meta.data

dds <- DESeqDataSetFromMatrix(
  countData = counts,
  colData = metadata,
  design = ~ group  # or ~ your_variable
)

dds <- DESeq(dds)
# dds <- DESeq(dds, fitType = "mean")
# dds <- DESeq(dds, fitType = "local")


# Compare B vs A (reference level is A)
res <- results(dds, contrast = c("group", "Type_2_Diabetes", "Lean_Control"))

# Order by adjusted p-value
res <- res[order(res$padj), ]

resLFC <- lfcShrink(dds, coef = "group_Type_2_Diabetes_vs_Lean_Control", type = "apeglm")
# Assume 'res' is your DESeq2 results object (e.g., from results(dds))
res_df <- as.data.frame(res)

# # Add gene names (row names into column)
# res_df$gene <- rownames(res_df)
res_df$input <- rownames(res_df)
res_df <- tidylog::left_join(res_df,gene_annotations,by="input")

write.csv(res_df,fs::path(dir.results,paste0("Organoid_DESeq2_",celltype,"_diabetes_lc_treatment30.csv")))

res_df$color <- ifelse(res_df$padj < 0.05 & res_df$log2FoldChange > 0, "#990000",
                             ifelse(res_df$padj < 0.05 & res_df$log2FoldChange < 0, "#003366", "gray"))
# res_df$color_int <- ifelse(res_df$fdr_int < 0.05 & res_df$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
#                              ifelse(res_df$fdr_int < 0.05 & res_df$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))

# Identify significant points (fdr < 0.05)
significant_df <- res_df[res_df$padj < 0.05, ]
# significant_df_int <- res_df[res_df$fdr_int < 0.05, ]

Genes <- length(unique(res_df$Gene))
Cells <- ncol(so_celltype)
# Nonconvergence_Rate <- nebula_nonconverged_percent
# res_df$color3 <- ifelse(res_df$fdr3 < 0.2 & res_df$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
#                               ifelse(res_df$fdr3 < 0.2 & res_df$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df3 <- res_df[res_df$fdr3 < 0.2, ]

top_up <- res_df %>%
  filter(padj < 0.05, log2FoldChange > 0) %>%
  arrange(padj, desc(log2FoldChange)) %>%
  head(10)

top_down <- res_df %>%
  filter(padj < 0.05, log2FoldChange < 0) %>%
  arrange(padj, log2FoldChange) %>%
  head(10)

top_res_df <- bind_rows(top_up, top_down)

max <- max(res_df$log2FoldChange)
# max <- 3.1
min <- min(res_df$log2FoldChange)


# Create the volcano plot using ggplot
volcano_plot <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = color)) +
  geom_point(alpha = 0.7) +  # Plot points with transparency
  scale_color_identity() +  # Use the color column directly
  theme_minimal() +  # Minimal theme
  labs(
    title = "Type 2 Diabetes vs. Lean Controls",
    subtitle = paste0(celltype,", Treatment 30 (DESeq2)"),
    x = "FC",
    y = "-log10(P-Value)",
    color = "Log2FC Direction Direction",
    caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells)
  ) +
  theme(
    plot.title = element_text(hjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 1)
  )+
  xlim(min,max)+
  # xlim(-3,3)+
  # ylim(0,11)+
  # # Add labels for significant points
  # geom_text(data = significant_df, aes(label = Gene),
  #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# Add labels for significant points with ggrepel
geom_text_repel(data = top_res_df, aes(label = Gene),
                size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
  # geom_text_repel(data = top_res_df, aes(label = Gene),
  #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = Inf)

volcano_plot



png(fs::path(dir.results, paste0("Plot_Organoid_DESeq2_",celltype,"_Diabetes_lc_2000_30.png")), 
    width = 2500, height = 2100, res = 300)
print(volcano_plot)
dev.off()


# # # Add significance label
# # res_df <- res_df %>%
# #   mutate(
# #     sig = case_when(
# #       padj < 0.05 & abs(log2FoldChange) > 1 ~ "Significant",
# #       TRUE ~ "Not Significant"
# #     )
# #   )
# 
# # write.csv(as.data.frame(res), "deseq2_results.csv")
# 
# 
# 
# # dds <- DESeqDataSetFromMatrix(countData = cts,
# #                               colData = coldata,
# #                               design= ~ batch + condition)
# # dds <- DESeq(dds)
# # resultsNames(dds) # lists the coefficients
# # res <- results(dds, name="condition_trt_vs_untrt")
# # # or to shrink log fold changes association with condition:
# # res <- lfcShrink(dds, coef="condition_trt_vs_untrt", type="apeglm")
# # 
# 
# 
# # nrow(so_celltype) #9196 genes
# # ncol(so_celltype) #2127 cells
# 
# ## Select Highly Variable Genes (HVGs)
# so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_celltype)
# 
# # # Subset Seurat object to only HVGs
# so_celltype <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype) <- "RNA"
# 
# ###
# # meta_hvg <- so_celltype@meta.data
# # pred = model.matrix(~group, data = meta_hvg)
# # data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)
# 
# #Make sure exposure/independent/x variable or group variable is a factor variable
# so_celltype$group <- factor(so_celltype$group)
# #Make sure to set reference level
# so_celltype$group <- relevel(so_celltype$group,ref="Lean Control")
# 
# # so_celltype$treatment <- factor(so_celltype$treatment)
# 
# # counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round
# 
# #Find markers
# # Set identities to the 'group' column
# Idents(so_celltype) <- "group"
# markers <- FindMarkers(
#   object = so_celltype,
#   ident.1 = "Type 2 Diabetes",
#   ident.2 = "Lean Control",  # optional: if omitted, compared to all other cells
#   # group.by = "group",  # optional
#   min.pct = 0,      # only test genes expressed in >10% of cells
#   logfc.threshold = 0  # only return genes with log2FC > 0.25
# )
# 
# markers$input <- rownames(markers)
# markers <- tidylog::left_join(markers,gene_annotations,by="input")
# 
# # ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj))) +
# #   geom_point(aes(color = p_val_adj < 0.05 & abs(avg_log2FC) > 0.25), alpha = 0.6) +
# #   scale_color_manual(values = c("grey", "red")) +
# #   theme_minimal() +
# #   labs(
# #     title = "Volcano Plot: T2D vs Lean Control",
# #     x = "Log2 Fold Change",
# #     y = "-log10 Adjusted p-value"
# #   ) +
# #   theme(legend.position = "none")
# 
# 
# # markers <- markers %>%
# #   mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
#   # mutate(fdr_int=p.adjust(`p_groupType 2 Diabetes:treatment30`,method="fdr"))
# # mutate(fdr3=p.adjust(PValue3,method="fdr"))
# # markers$PValue10 <- -log10(pmax(markers$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)
# # markers$PValue10_int <- -log10(pmax(markers$`p_groupType 2 Diabetes:treatment30`, 1e-10))  # Avoid log(0)
# 
# write.csv(markers,fs::path(dir.results,paste0("Organoid_FindMarkers_",celltype,"_diabetes_lc_treatment30_adj_2000.csv")))
# 
# markers$color <- ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC > 0, "#990000",
#                              ifelse(markers$p_val_adj < 0.05 & markers$avg_log2FC < 0, "#003366", "gray"))
# # markers$color_int <- ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` > 0, "#990000",
# #                              ifelse(markers$fdr_int < 0.05 & markers$`logFC_groupType 2 Diabetes:treatment30` < 0, "#003366", "gray"))
# 
# # Identify significant points (fdr < 0.05)
# significant_df <- markers[markers$p_val_adj < 0.05, ]
# # significant_df_int <- markers[markers$fdr_int < 0.05, ]
# 
# Genes <- length(unique(markers$Gene))
# Cells <- ncol(so_celltype)
# # Nonconvergence_Rate <- nebula_nonconverged_percent
# # markers$color3 <- ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 > 0, "lightcoral",
# #                               ifelse(markers$fdr3 < 0.2 & markers$`logFC_groupType 2 Diabetes`3 < 0, "lightblue", "gray"))
# # 
# # # Identify significant points (fdr < 0.05)
# # significant_df3 <- markers[markers$fdr3 < 0.2, ]
# 
# top_up <- markers %>%
#   filter(p_val_adj < 0.05, avg_log2FC > 0) %>%
#   arrange(p_val_adj, desc(avg_log2FC)) %>%
#   head(10)
# 
# top_down <- markers %>%
#   filter(p_val_adj < 0.05, avg_log2FC < 0) %>%
#   arrange(p_val_adj, avg_log2FC) %>%
#   head(10)
# 
# top_markers <- bind_rows(top_up, top_down)
# 
# max <- max(markers$avg_log2FC)
# # max <- 3.1
# min <- min(markers$avg_log2FC)
# 
# 
# # Create the volcano plot using ggplot
# volcano_plot <- ggplot(markers, aes(x = avg_log2FC, y = -log10(p_val_adj), color = color)) +
#   geom_point(alpha = 0.7) +  # Plot points with transparency
#   scale_color_identity() +  # Use the color column directly
#   theme_minimal() +  # Minimal theme
#   labs(
#     title = "Type 2 Diabetes vs. Lean Controls",
#     subtitle = paste0(celltype,", Treatment 30"),
#     x = "FC",
#     y = "-log10(P-Value)",
#     color = "Log2FC Direction Direction",
#     caption = paste0("FDR < 0.05, Genes = ",Genes,", Cells = ",Cells)
#   ) +
#   theme(
#     plot.title = element_text(hjust = 0),
#     axis.text.x = element_text(angle = 0, hjust = 1)
#   )+
#   xlim(min,max)+
#   # xlim(-3,3)+
#   # ylim(0,11)+
#   # # Add labels for significant points
#   # geom_text(data = significant_df, aes(label = Gene),
#   #           vjust = 1, hjust = 1, size = 3, check_overlap = TRUE, color = "black")
# # Add labels for significant points with ggrepel
# geom_text_repel(data = top_markers, aes(label = Gene),
#                 size = 3, color = "black", box.padding = 0.5, max.overlaps = 20)
#   # geom_text_repel(data = top_markers, aes(label = Gene),
#   #                 size = 3, color = "black", box.padding = 0.5, max.overlaps = Inf)
# 
# volcano_plot
# 
# 
# 
# png(fs::path(dir.results, paste0("Plot_Organoid_FindMarkers_",celltype,"_Diabetes_lc_2000_30.png")), 
#     width = 2500, height = 2100, res = 300)
# print(volcano_plot)
# dev.off()
}
```

### iv. GSEA
```{r echo = F}
full_results <- read.csv(fs::path(dir.results,"Biopsy_NEBULA_PT_cells_diabetes_unadjusted_2000.csv")) %>%
  clean_names() %>% 
  dplyr::select(-x) %>% 
  dplyr::rename(Gene=gene,LogFC=log_fc_group_type_2_diabetes)

# Filter out the gmt files for KEGG, Reactome and GOBP
# list.files(bg_path)
# gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
# gmt_files
# kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
# reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
# go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)
# 
# # rank genes by t-stats in DiD
# rankings_PT <- full_results$LogFC
# names(rankings_PT) <- full_results$Gene
# rankings_PT <- sort(rankings_PT, decreasing = TRUE)
# plot(rankings_PT)
# min(rankings_PT)
# max(rankings_PT)
# 
# 
# set.seed(1234)
# 
# kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
#                             stats = rankings_PT,
#                             scoreType = 'std', 
#                             minSize = 3,
#                             maxSize = 500,
#                             nproc = 1)
# 
# reactome_res_PT <- fgsea(pathways = reactome,
#                          stats = rankings_PT,
#                          scoreType = 'std', 
#                          minSize = 3,
#                          maxSize = 500,
#                          nproc = 1)
# go_res_PT <- fgsea(pathways = go,
#                    stats = rankings_PT,
#                    scoreType = 'std', 
#                    minSize = 5,
#                    maxSize = 500,
#                    nproc = 1)
# 
# PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
#                        "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
#                        "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
# rownames(PT_fgsea) <- c("adj.pval", "p.val")
# 
# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)",xlimit = 4, xnudge = 0.03)+ theme(legend.position.inside = c(0.2, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
# #        width = 13, height = 10, scale = 1)
# 
# ##### REACTOME
# b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position.inside = c(0.15, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
# #        width = 13, height = 10, scale = 1)
# ##### GO
# c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position.inside = c(0.1, 0.5))
# 
# # ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
# #        width = 13, height = 10, scale = 1)
# 
# combined_plot <- b + c + plot_layout(ncol = 1)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 15, height = 20, scale = 1)
# Filter out the gmt files for KEGG, Reactome and GOBP
list.files(bg_path)
gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
gmt_files
kegg_legacy <- prepare_gmt(gmt_files[1], unique(full_results$Gene), savefile = FALSE)
reactome <- prepare_gmt(gmt_files[3], unique(full_results$Gene), savefile = FALSE)
go <- prepare_gmt(gmt_files[4], unique(full_results$Gene), savefile = FALSE)

# rank genes by t-stats in DiD
rankings_PT <- full_results$LogFC
names(rankings_PT) <- full_results$Gene
rankings_PT <- sort(rankings_PT, decreasing = TRUE)
plot(rankings_PT)
min(rankings_PT)
max(rankings_PT)

set.seed(1234)

kegg_legacy_res_PT <- fgsea(pathways = kegg_legacy,
                                     stats = rankings_PT,
                                     scoreType = 'std', 
                                     minSize = 3,
                                     maxSize = 500,
                                     nproc = 1)

reactome_res_PT <- fgsea(pathways = reactome,
                                  stats = rankings_PT,
                                  scoreType = 'std', 
                                  minSize = 3,
                                  maxSize = 500,
                                  nproc = 1)
go_res_PT <- fgsea(pathways = go,
                            stats = rankings_PT,
                            scoreType = 'std', 
                            minSize = 5,
                            maxSize = 500,
                            nproc = 1)

PT_fgsea <- data.frame("KEGG Legacy"=c(sum(kegg_legacy_res_PT[, padj < 0.05]), sum(kegg_legacy_res_PT[, pval < 0.05])),
                                "REACTOME"=c(sum(reactome_res_PT[, padj < 0.05]), sum(reactome_res_PT[, pval < 0.05])),
                                "GO"=c(sum(go_res_PT[, padj < 0.05]), sum(go_res_PT[, pval < 0.05])))
rownames(PT_fgsea) <- c("adj.pval", "p.val")
PT_fgsea

# ##### KEGG Legacy
# a <- plot_fgsea_transpose(kegg_legacy_res_PT, title = "PT Unadjusted Top 30 KEGG (REML, Log Normal, Offset)", xnudge = 0.03)+ theme(legend.position = c(0.2, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_kegg_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)

##### REACTOME
b <- plot_fgsea_transpose(reactome_res_PT, title = "PT Unadjusted Top 30 REACTOME (REML, Log Normal, Offset)", xlimit = 5) + theme(legend.position = c(0.15, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_reactome_pathways_unadjusted.jpeg"),
#        width = 13, height = 10, scale = 1)
##### GO
c <- plot_fgsea_transpose(go_res_PT, title = "PT Unadjusted Top 30 GO (REML, Log Normal, Offset)", xlimit = 8)+ theme(legend.position = c(0.1, 0.5))

# ggsave(fs::path(dir.results,"PT_top30_go_pathways_unadjusted_reml_offset.jpeg"),
#        width = 13, height = 10, scale = 1)

# combined_plot <- b + c + plot_layout(ncol = 3)
# print(combined_plot)
# ggsave(fs::path(dir.results,"PT_top30_pathways_unadjusted.jpeg"),
#        width = 40, height = 10, scale = 1)
combined_plot <- b + c + plot_layout(ncol = 1)
print(combined_plot)
ggsave(fs::path(dir.results,"Biopsy_PT_top30_pathways_unadjusted.jpeg"),
       width = 15, height = 20, scale = 1)
```

### iii. Targeted Gene
```{r}
#GENES: ROBO4 and FN1
target_genes <- c("ROBO4","FN1")
so_celltype <- subset(sc_org,celltype2=="PT")
DefaultAssay(so_celltype) <- "RNA" 

nrow(so_celltype) #9196 genes
ncol(so_celltype) #2127 cells

# ## Select Highly Variable Genes (HVGs)
# so_celltype <- FindVariableFeatures(so_celltype, selection.method = "vst", nfeatures = 2000)
# hvgs <- VariableFeatures(so_celltype)

# # Subset Seurat object to only HVGs
# so_celltype_hvg <- subset(so_celltype, features = hvgs)
# DefaultAssay(so_celltype_hvg) <- "RNA" 

###
# meta_hvg <- so_celltype@meta.data
# pred = model.matrix(~group, data = meta_hvg)
# data_g_hvg = list(count=counts_hvg, id=meta_hvg$kit_id, pred=pred)

#Make sure exposure/independent/x variable or group variable is a factor variable
so_celltype$group <- factor(so_celltype$group)
#Make sure to set reference level
so_celltype$group <- relevel(so_celltype$group,ref="Lean_Control")

counts_hvg <- round(GetAssayData(so_celltype, layer = "counts")) # load counts and round

# offset_hvg = Matrix::colSums(data_g_hvg$count) 

# With parallelization
# List of genes
# genes_list <- rownames(counts_hvg)
genes_list <- target_genes

cl <- makeCluster(2)
registerDoParallel(cl)

start_time <- Sys.time()
nebula_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg[g, , drop = FALSE]
    meta_gene <- subset(so_celltype,features=g)@meta.data
    pred_gene <- model.matrix(~group, data = meta_gene)
    # library <- meta_gene$library_size
    library <- meta_gene$pooled_offset
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$kit_id, pred = pred_gene,offset=library)
    
    if (is.null(data_g_gene)) {
      data_g_gene <- list(count = count_gene, id = meta_gene$kit_id, pred = pred_gene, offset = library)
    }
    
    #With offset
    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, reml=T,model="NBLMM",output_re = T,covariance=T,offset=data_g_gene$offset)
    
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}

stopCluster(cl)
end_time <- Sys.time()
print(end_time - start_time)

# set the names of results based on gene names
nebula_results_list <- Filter(Negate(is.null), nebula_results_list)  # remove NULLs first
names(nebula_results_list) <- sapply(nebula_results_list, function(x) x$gene)  # set names
nebula_results_list <- lapply(nebula_results_list, function(x) x$result)  # clean list back to just results

PT_nebula_converged <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    converged <- nebula_results_list[[gene_name]]$convergence
    df <- data.frame(Gene = gene_name,
                     Convergence_Code = converged)
    return(df)
  }
)

nebula_summaries <- map_dfr(
  names(nebula_results_list),
  function(gene_name) {
    df <- nebula_results_list[[gene_name]]$summary
    df <- df %>% mutate(Gene = gene_name)
    return(df)
  }
)
nonconverge_genes <- unique(PT_nebula_converged$Gene[which(PT_nebula_converged$Convergence_Code==-40)]) 

#Make dataframe of final results
full_results <- as.data.frame(nebula_summaries)
#Calculate number of genes filtered out for low expression 
low_exp <- length(genes_list)-length(full_results$gene)
#Filter out non-converging genes
full_results <- full_results %>% 
  filter(!gene %in%  nonconverge_genes)
#Calculate nonconvergence rate
nebula_nonconverged_percent <- paste0(round((1-(length(genes_list)-length(nonconverge_genes))/length(genes_list))*100,3),"%")
# nebula_nonconverged_percent <- (length(rownames(counts_hvg))-length(unique(full_results$gene)))/length(rownames(counts_hvg))
# print(paste0(nebula_nonconverged_percent*100, "% failed to converge"))
full_results <- full_results %>%
  mutate(fdr=p.adjust(`p_groupType 2 Diabetes`,method="fdr"))  
# mutate(fdr3=p.adjust(PValue3,method="fdr"))
full_results$PValue10 <- -log10(pmax(full_results$`p_groupType 2 Diabetes`, 1e-10))  # Avoid log(0)




```
