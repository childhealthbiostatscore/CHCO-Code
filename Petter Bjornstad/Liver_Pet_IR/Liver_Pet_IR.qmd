---
title: "Liver Pet & IR"
format: revealjs
editor: visual
---

#1. Set Up - RH2 & CRC ##a. Load Libraries & Directores
## a. Libraries & Directories
```{r}
#Libraries
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
source("Libraries.R")
source("Functions.R")
source("01_clean_dataset.R")


#Directories
user <- Sys.info()[["user"]]

if (user == "shivaniramesh") {
  dir.dat <- "/Users/shivaniramesh/Library/CloudStorage/OneDrive-UW/Laura Pyle's files - Biostatistics Core Shared Drive/Liver Pet IR/Data"
  dir.results <- "/Users/shivaniramesh/Library/CloudStorage/OneDrive-UW/CHCO-Code/Petter Bjornstad/Liver Pet IR/Results"
  #use_python("/usr/bin/python3", required = TRUE)
} else {
  #Directories
  dir.dat <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Liver Pet IR/Data")
  dir.results <- c("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Liver Pet IR/Results")
}


```

##b. Load Data & Format
```{r}
#Load PET data & alt, ast, ggt and potentially masld 
harm_meta_data <- read.csv("/Users/hhampson/Library/CloudStorage/OneDrive-SharedLibraries-UW/Laura Pyle - Biostatistics Core Shared Drive/Data Harmonization/Data Clean/harmonized_dataset.csv",na.strings = c("", "NA", "N/A", "n/a", " ","na")) %>% 
  filter(study=="RENAL-HEIR" | study=="RENAL-HEIRitage") %>% 
  dplyr::select(c("record_id","rh_id","rh2_id")) %>% 
  filter(!is.na(rh_id) & !is.na(rh2_id)) %>% 
  distinct()

#Load data
dat <- read.csv(fs::path(dir.dat,"raw-data-2025-10-22.csv"))

dat_ir <- dat %>% 
  dplyr::select(c("record_id","study","procedure","visit","group","age","sex","bmi","hba1c","liver_k1","liver_k2","liver_k3","m_i_gir_190","m_i_p2_raw_lean")) 
# filter(procedure=="ivgtt")

CROC <- dat_ir %>% 
  filter(study=="CROCODILE") %>% 
  dplyr::select(-c("m_i_gir_190"))
# RH <- dat_ir %>% 
#   filter(study == "RENAL-HEIR" | study=="RENAL-HEIRitage") %>% 
#   dplyr::select(-c("m_i_p2_raw_lean"))
rm(dat,dat_ir)

#Number of participants in each study
length(unique(CROC$record_id)) #60
# length(unique(RH$record_id)) #151

#Collapse CROC
CROC_collapsed <- collapse_by_id_visit(CROC)
CROC_collapsed <- CROC_collapsed %>% 
  filter(!is.na(liver_k1)) %>% 
  filter(!is.na(m_i_p2_raw_lean)) #24 participants have complete pet and ir data

#Collapse RH
# RH_collapsed <- collapse_by_id_visit(RH)
# RH_collapsed <- RH_collapsed %>% 
#   filter(!is.na(liver_k1)) 
# RH_collapsed <- tidylog::left_join(RH_collapsed,harm_meta_data,by="record_id")
#   # filter(!is.na(m_i_gir_190))
# unique(RH_collapsed$record_id)
RH_collapsed <- rh_rh2_df %>% 
  filter(!is.na(liver_k1)) %>% 
  filter(!is.na(m_i_gir_190)) #27 participants have complete pet and ir data
rm(harm_meta_data,CROC,rh_rh2_df)
```

#2. Analysis
##a. Descriptive Statistics
```{r}
#CROCODILE
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+m_i_p2_raw_lean| group, data=CROC_collapsed,
       render.continuous = my.render.cont)
#Renal-HEIR/HEIRITAGE
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+m_i_gir_190| group, data=RH_collapsed,
       render.continuous = my.render.cont)

```

##b. Associations Between Pet Vars & IRs
###i. CROCODILE
```{r}
pet_variables <- c("liver_k1","liver_k2","liver_k3")
insulin_vars <- c("m_i_p2_raw_lean")
#Correlation/association between each pet var and each insulin var
total_results <- data.frame()
for(pet in pet_variables) {
  for (insulin in insulin_vars){
    # Pearson correlation test
    pearson_test <- cor.test(CROC_collapsed[[pet]], CROC_collapsed[[insulin]], 
                             method = "pearson",
                             conf.level = 0.95)
    corr.p <- pearson_test$estimate
    p.p <- pearson_test$p.value
    
    # Spearman correlation test
    spearman_test <- cor.test(CROC_collapsed[[pet]], CROC_collapsed[[insulin]], 
                              method = "spearman",
                              conf.level = 0.95)
    corr.s <- spearman_test$estimate
    p.s <- spearman_test$p.value
    
    #Linear regression of x = insulin on y = pet variable
    m0 <- as.formula(paste0(pet,"~",insulin))
    m1 <- lm(m0,data=CROC_collapsed)
    beta <- summary(m1)$coef[2,1]
    pval <- summary(m1)$coef[2,4] 
    
    results <- data.frame(Pet=pet,IR=insulin,Corr_p=corr.p,Pval_p=p.p,Corr_s=corr.s,Pval_s=p.s,Beta=beta,Pval=pval)
    total_results <- rbind(total_results,results)
  }
}

#Visualize results
get_sig_stars <- function(p) {
  case_when(
    p < 0.001 ~ "***",
    p < 0.01 ~ "**",
    p < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Function to create a heatmap with significance stars
create_heatmap <- function(data, value_col, pval_col, title, 
                           color_low = "blue", color_high = "red", 
                           color_mid = "white", limits = NULL) {
  
  # Reshape data to wide format for values
  values_wide <- data %>%
    dplyr::select(Pet, IR, all_of(value_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(value_col))
  
  # Reshape data to wide format for p-values
  pvals_wide <- data %>%
    dplyr::select(Pet, IR, all_of(pval_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(pval_col))
  
  # Convert to matrix for melting
  values_matrix <- as.matrix(values_wide[,-1])
  rownames(values_matrix) <- values_wide$Pet
  
  pvals_matrix <- as.matrix(pvals_wide[,-1])
  rownames(pvals_matrix) <- pvals_wide$Pet
  
  # Melt for ggplot
  values_melt <- melt(values_matrix, varnames = c("Pet", "IR"), value.name = "value")
  pvals_melt <- melt(pvals_matrix, varnames = c("Pet", "IR"), value.name = "pval")
  
  # Combine and add stars
  plot_data <- values_melt %>%
    left_join(pvals_melt, by = c("Pet", "IR")) %>%
    mutate(stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Set limits if not provided
  if (is.null(limits)) {
    limits <- c(min(plot_data$value, na.rm = TRUE), 
                max(plot_data$value, na.rm = TRUE))
  }
  
  # Create heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3.5) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,face="bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = title)
  
  return(p)
}

heatmap_spearman <- create_heatmap(total_results, 
                                   value_col = "Corr_s", 
                                   pval_col = "Pval_s",
                                   title = "Spearman Correlation Coefficients",
                                   limits = c(-1, 1))

# 2. Pearson Correlation Heatmap
heatmap_pearson <- create_heatmap(total_results, 
                                  value_col = "Corr_p", 
                                  pval_col = "Pval_p",
                                  title = "Pearson Correlation Coefficients",
                                  limits = c(-1, 1))
heatmap_pearson 
heatmap_spearman

# Function to create a single box plot
create_boxplot <- function(data, pet_var, group_var = "group") {
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.5) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         x = "Group",
         y = pet_var) +
    stat_compare_means(method = "t.test", label.y.npc = 0.95) # Add p-value
  return(p)
}

# Create box plots for all PET variables
boxplot_list <- lapply(pet_variables, function(pet) {
  create_boxplot(CROC_collapsed, pet)
})

# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group_CROCODILE.png"), 
    width = 6000, height = 2500, res = 300)
do.call(grid.arrange, c(boxplot_list, ncol = 3))
dev.off()
```
###ii. RH/RH2
```{r}
pet_variables <- c("liver_k1","liver_k2","liver_k3")
insulin_vars <- c("m_i_gir_190")
#Correlation/association between each pet var and each insulin var
total_results <- data.frame()
for(pet in pet_variables) {
  for (insulin in insulin_vars){
    # Pearson correlation test
    pearson_test <- cor.test(RH_collapsed[[pet]], RH_collapsed[[insulin]], 
                             method = "pearson",
                             conf.level = 0.95)
    corr.p <- pearson_test$estimate
    p.p <- pearson_test$p.value
    
    # Spearman correlation test
    spearman_test <- cor.test(RH_collapsed[[pet]], RH_collapsed[[insulin]], 
                              method = "spearman",
                              conf.level = 0.95)
    corr.s <- spearman_test$estimate
    p.s <- spearman_test$p.value
    
    #Linear regression of x = insulin on y = pet variable
    m0 <- as.formula(paste0(pet,"~",insulin))
    m1 <- lm(m0,data=RH_collapsed)
    beta <- summary(m1)$coef[2,1]
    pval <- summary(m1)$coef[2,4] 
    
    results <- data.frame(Pet=pet,IR=insulin,Corr_p=corr.p,Pval_p=p.p,Corr_s=corr.s,Pval_s=p.s,Beta=beta,Pval=pval)
    total_results <- rbind(total_results,results)
  }
}

#Visualize results
get_sig_stars <- function(p) {
  case_when(
    p < 0.001 ~ "***",
    p < 0.01 ~ "**",
    p < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Function to create a heatmap with significance stars
create_heatmap <- function(data, value_col, pval_col, title, 
                           color_low = "blue", color_high = "red", 
                           color_mid = "white", limits = NULL) {
  
  # Reshape data to wide format for values
  values_wide <- data %>%
    dplyr::select(Pet, IR, all_of(value_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(value_col))
  
  # Reshape data to wide format for p-values
  pvals_wide <- data %>%
    dplyr::select(Pet, IR, all_of(pval_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(pval_col))
  
  # Convert to matrix for melting
  values_matrix <- as.matrix(values_wide[,-1])
  rownames(values_matrix) <- values_wide$Pet
  
  pvals_matrix <- as.matrix(pvals_wide[,-1])
  rownames(pvals_matrix) <- pvals_wide$Pet
  
  # Melt for ggplot
  values_melt <- melt(values_matrix, varnames = c("Pet", "IR"), value.name = "value")
  pvals_melt <- melt(pvals_matrix, varnames = c("Pet", "IR"), value.name = "pval")
  
  # Combine and add stars
  plot_data <- values_melt %>%
    left_join(pvals_melt, by = c("Pet", "IR")) %>%
    mutate(stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Set limits if not provided
  if (is.null(limits)) {
    limits <- c(min(plot_data$value, na.rm = TRUE), 
                max(plot_data$value, na.rm = TRUE))
  }
  
  # Create heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3.5) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,face="bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = title)
  
  return(p)
}

heatmap_spearman <- create_heatmap(total_results, 
                                   value_col = "Corr_s", 
                                   pval_col = "Pval_s",
                                   title = "Spearman Correlation Coefficients",
                                   limits = c(-1, 1))

# 2. Pearson Correlation Heatmap
heatmap_pearson <- create_heatmap(total_results, 
                                  value_col = "Corr_p", 
                                  pval_col = "Pval_p",
                                  title = "Pearson Correlation Coefficients",
                                  limits = c(-1, 1))
heatmap_pearson 
heatmap_spearman

# Function to create a single box plot
create_boxplot <- function(data, pet_var, group_var = "group") {
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.5) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         x = "Group",
         y = pet_var) +
    stat_compare_means(method = "t.test", label.y.npc = 0.95) # Add p-value
  return(p)
}

# Create box plots for all PET variables
boxplot_list <- lapply(pet_variables, function(pet) {
  create_boxplot(RH_collapsed, pet)
})

# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group_RH.png"), 
    width = 6000, height = 2500, res = 300)
do.call(grid.arrange, c(boxplot_list, ncol = 3))
dev.off()


pet_variables <- c("liver_k1","liver_k2","liver_k3")
insulin_vars <- c("m_i_p2_raw_lean")
#Correlation/association between each pet var and each insulin var
total_results <- data.frame()
for(pet in pet_variables) {
  for (insulin in insulin_vars){
    m0 <- as.formula(paste0(pet,"~",insulin))
    m1 <- lm(m0,data=CROC_collapsed)
    m0_adj <- as.formula(paste0(pet,"~",insulin,"+age+sex"))
    m1_adj <- lm(m0_adj,data=CROC_collapsed)
    beta <- summary(m1)$coef[2,1]
    pval <- summary(m1)$coef[2,4]
    beta_adj <- summary(m1_adj)$coef[2,1]
    pval_adj <- summary(m1_adj)$coef[2,4]
    full_results <- c(Insulin=insulin,Pet=pet,Beta=beta,Pval=pval,Beta_Adj=beta_adj,Pval_adj=pval_adj)
    total_results <- rbind(total_results,full_results)
  }
}
  
  
  
```
```{r}
# clamp <- harm_meta_data %>% 
#   filter(procedure=="clamp") %>% 
#   dplyr::select(c("record_id","mrn","study","procedure","visit","group","age","sex","bmi","hba1c","liver_k1","liver_k2","liver_k3","mm_ir","mm_si","m_i")) 
# 
# #Number of participants
# length(unique(harm_meta_data$record_id)) #651 changed to 656 on 08/25, 633 on 10/06
# length(unique(harm_meta_data$mrn)) #480 unique mrns, 521 on 10/05
# 
# #Filter to RH2 and CRC 
# harm_meta_data <- harm_meta_data %>%
#   filter(grepl("RH",record_id)|grepl("RH2",record_id)|grepl("CRC",record_id)|grepl("PEN",record_id))
# # harm_meta_data <- harm_meta_data %>% 
# #   filter(grepl("CRC",record_id))
# 
# #Number of participants
# length(unique(harm_meta_data$record_id)) #60 CRC people, 233 including RH and RH2 and PEN
# 
# #Number of participants with Pet data
# length(which(!is.na(harm_meta_data$liver_k1))) #57 
# length(which(!is.na(harm_meta_data$liver_k2))) #57
# length(which(!is.na(harm_meta_data$liver_k3))) #57

pet_dat <- harm_meta_data %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, last(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, mean(.x, na.rm = TRUE))),
                   .by = c(mrn, visit)) %>%
  arrange(mrn)
length(unique(pet_dat$record_id)) #200
length(unique(pet_dat$mrn)) #200

#select variables of interest
pet_dat2 <- pet_dat %>%
  dplyr::select(c("record_id","mrn","study","visit","group","age","sex","bmi","hba1c","liver_k1","liver_k2","liver_k3","mm_ir","mm_si"))
# pet_dat2 <- pet_dat %>%
#   dplyr::select(c("record_id","mrn","study","visit","screen_date","group","age","sex","bmi","hba1c","liver_k1","liver_k2","liver_k3","gir_190","gir_200","p2_gc_leanm", "p2_gc_m"))
# pet_dat2 <- pet_dat %>%
#   dplyr::select(c("record_id","mrn","study","visit","screen_date","group","liver_k1","liver_k2","liver_k3","search_eis",
#                   "homa_ir","p1_ffa_suppression","gir_190","gir_200","p2_gc_leanm", "p2_gc_m",
#                   "p1_gc_leanm","p1_gc_m","p1_raw_leanm","p1_raw_m","p1_steady_state_ffa",
#                   "p2_ffa_suppression","p2_gc_leanm","p2_gc_m","p2_raw_leanm","p2_raw_m",
#                   "p2_steady_state_ffa"))
#Filter to thoser with pet and insulin data
pet_dat3 <- pet_dat2 %>% filter(study %in% c("CROCODILE", "RENAL-HEIR", "RENAL-HEIRitage")) %>%
  filter(!is.na(liver_k1) & !is.na(gir_190))
#44 have gir_190 and gir_200
#24 have p2_gc_leanm
#26 have p2_gc_m
# > length(which(is.na(pet_dat3$p2_gc_leanm)))
# [1] 20
# > length(which(is.na(pet_dat3$p2_gc_m)))
# [1] 18


# pet_dat2 <- pet_dat %>%
#   arrange(screen_date) %>%
#   # arrange(date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, dplyr::first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, dplyr::first(na.omit(.x)))),
#                    .by = c(record_id, visit))
# pet_dat2 <- pet_dat %>%
#   arrange(screen_date) %>%
#   # arrange(date) %>% 
#   dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, dplyr::first(na.omit(.x)))),
#                    across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, dplyr::first(na.omit(.x)))),
#                    .by = c(mrn, screen_date))

# Table 1: Summary Table - Total counts of missing and non-missing data
summary_table <- pet_dat3 %>%
  summarise(across(everything(), 
                   list(n_not_missing = ~sum(!is.na(.)),
                        n_missing = ~sum(is.na(.)),
                        pct_missing = ~round(mean(is.na(.)) * 100, 1)))) %>%
  pivot_longer(everything(), 
               names_to = c("variable", ".value"), 
               names_pattern = "(.*)_(n_not_missing|n_missing|pct_missing)") %>%
  dplyr::select(variable, n_not_missing, n_missing, pct_missing) %>%
  mutate(total = n_not_missing + n_missing) %>%
  arrange(desc(n_not_missing))

# Define a custom rendering function without median
my.render.cont <- function(x) {
  with(stats.apply.rounding(stats.default(x), digits=2), c("",
                                                           "Mean (SD)" = sprintf("%s (%s)", MEAN, SD)))
}
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+gir_190+gir_200+p2_gc_leanm+p2_gc_m| group, data=pet_dat3,
       render.continuous = my.render.cont)
table1(~age+sex+bmi+hba1c+liver_k1+liver_k2+liver_k3+gir_190+gir_200+p2_gc_leanm+p2_gc_m| study, data=pet_dat3,
       render.continuous = my.render.cont)
#Filter to those with at least one pet variable
pet_variables <- c("liver_k1","liver_k2","liver_k3")
# pet_dat3 <- pet_dat2 %>%
#   filter(if_any(all_of(pet_variables), ~ !is.na(.)))
# #55 participants have at least 1 pet variable of data 
# #But RH2-25-O has pet data and no insulin variable data, so need to exclude
# insulin_vars <- c("search_eis",
#                   "homa_ir","p1_ffa_suppression","gir_190","gir_200",
#                   "p1_gc_leanm","p1_gc_m","p1_raw_leanm","p1_raw_m","p1_steady_state_ffa",
#                   "p2_ffa_suppression","p2_gc_leanm","p2_gc_m","p2_raw_leanm","p2_raw_m",
#                   "p2_steady_state_ffa")
insulin_vars <- c("gir_190","gir_200","p2_gc_leanm", "p2_gc_m")
# pet_dat4 <- pet_dat3 %>%
#   filter(if_any(all_of(insulin_vars), ~ !is.na(.)))
#28 remain that have at least 1 pet var and at least 1 insulin var

#Correlation/association between each pet var and each insulin var
total_results <- data.frame()
for(pet in pet_variables) {
  for (insulin in insulin_vars){
    # Pearson correlation test
    pearson_test <- cor.test(pet_dat3[[pet]], pet_dat3[[insulin]], 
                             method = "pearson",
                             conf.level = 0.95)
    corr.p <- pearson_test$estimate
    p.p <- pearson_test$p.value
    
    # Spearman correlation test
    spearman_test <- cor.test(pet_dat3[[pet]], pet_dat3[[insulin]], 
                              method = "spearman",
                              conf.level = 0.95)
    corr.s <- spearman_test$estimate
    p.s <- spearman_test$p.value
    
    #Linear regression of x = insulin on y = pet variable
    m0 <- as.formula(paste0(pet,"~",insulin))
    m1 <- lm(m0,data=pet_dat3)
    beta <- summary(m1)$coef[2,1]
    pval <- summary(m1)$coef[2,4] 
    
    results <- data.frame(Pet=pet,IR=insulin,Corr_p=corr.p,Pval_p=p.p,Corr_s=corr.s,Pval_s=p.s,Beta=beta,Pval=pval)
    total_results <- rbind(total_results,results)
  }
}

#Visualize results
get_sig_stars <- function(p) {
  case_when(
    p < 0.001 ~ "***",
    p < 0.01 ~ "**",
    p < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Function to create a heatmap with significance stars
create_heatmap <- function(data, value_col, pval_col, title, 
                           color_low = "blue", color_high = "red", 
                           color_mid = "white", limits = NULL) {
  
  # Reshape data to wide format for values
  values_wide <- data %>%
    dplyr::select(Pet, IR, all_of(value_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(value_col))
  
  # Reshape data to wide format for p-values
  pvals_wide <- data %>%
    dplyr::select(Pet, IR, all_of(pval_col)) %>%
    pivot_wider(names_from = IR, values_from = all_of(pval_col))
  
  # Convert to matrix for melting
  values_matrix <- as.matrix(values_wide[,-1])
  rownames(values_matrix) <- values_wide$Pet
  
  pvals_matrix <- as.matrix(pvals_wide[,-1])
  rownames(pvals_matrix) <- pvals_wide$Pet
  
  # Melt for ggplot
  values_melt <- melt(values_matrix, varnames = c("Pet", "IR"), value.name = "value")
  pvals_melt <- melt(pvals_matrix, varnames = c("Pet", "IR"), value.name = "pval")
  
  # Combine and add stars
  plot_data <- values_melt %>%
    left_join(pvals_melt, by = c("Pet", "IR")) %>%
    mutate(stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Set limits if not provided
  if (is.null(limits)) {
    limits <- c(min(plot_data$value, na.rm = TRUE), 
                max(plot_data$value, na.rm = TRUE))
  }
  
  # Create heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3.5) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Value") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,face="bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = title)
  
  return(p)
}

library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
library(viridis)
library(gridExtra)

# Create the three heatmaps
# 1. Spearman Correlation Heatmap
heatmap_spearman <- create_heatmap(total_results, 
                                   value_col = "Corr_s", 
                                   pval_col = "Pval_s",
                                   title = "Spearman Correlation Coefficients",
                                   limits = c(-1, 1))

# 2. Pearson Correlation Heatmap
heatmap_pearson <- create_heatmap(total_results, 
                                  value_col = "Corr_p", 
                                  pval_col = "Pval_p",
                                  title = "Pearson Correlation Coefficients",
                                  limits = c(-1, 1))

# 3. Linear Regression Beta Coefficients Heatmap
# For betas, we might want different color scheme and no fixed limits
# heatmap_beta <- create_heatmap(total_results, 
#                               value_col = "Beta", 
#                               pval_col = "Pval",
#                               title = "Linear Regression Beta Coefficients")

# Display individual heatmaps
png(fs::path(dir.results,"Heatmaps_Pearson_Corr_Liver_Pet_IR2.png"),width=3000,height=2000,res=300)
print(heatmap_pearson)
dev.off()
png(fs::path(dir.results,"Heatmaps_Spearman_Corr_Liver_Pet_IR2.png"),width=3000,height=2000,res=300)
print(heatmap_spearman)
dev.off()
# print(heatmap_beta)

# Function to create a single box plot
create_boxplot <- function(data, pet_var, group_var = "group") {
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.5) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         x = "Group",
         y = pet_var) +
    stat_compare_means(method = "t.test", label.y.npc = 0.95) # Add p-value
  return(p)
}

# Create box plots for all PET variables
boxplot_list <- lapply(pet_variables, function(pet) {
  create_boxplot(pet_dat3, pet)
})

# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group.png"), 
    width = 6000, height = 2500, res = 300)
do.call(grid.arrange, c(boxplot_list, ncol = 3))
dev.off()

library(ggplot2)
library(ggpubr)
library(rstatix)
library(gridExtra)
library(dplyr)

# Function to create box plot with ANOVA and Tukey HSD
create_boxplot_with_stats <- function(data, pet_var, group_var = "group") {
  # Perform ANOVA
  anova_formula <- as.formula(paste(pet_var, "~", group_var))
  anova_result <- aov(anova_formula, data = data)
  anova_pval <- summary(anova_result)[[1]][["Pr(>F)"]][1]
  
  # Perform Tukey HSD test
  tukey_result <- TukeyHSD(anova_result)
  tukey_df <- as.data.frame(tukey_result[[group_var]])
  
  # Get unadjusted p-values using pairwise t-tests
  pwc_raw <- data %>%
    rstatix::pairwise_t_test(
      formula = as.formula(paste(pet_var, "~", group_var)),
      p.adjust.method = "none"  # No adjustment for raw p-values
    ) %>%
    add_xy_position(x = group_var)
  
  # Add significance labels for raw p-values
  pwc_raw <- pwc_raw %>%
    mutate(p.signif = case_when(
      p < 0.001 ~ "***",
      p < 0.01 ~ "**",
      p < 0.05 ~ "*",
      p < 0.1 ~ ".",
      TRUE ~ "ns"
    ))
  
  # Create the plot
  p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
    geom_boxplot(alpha = 0.7, outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(face = "bold", size = 12),
          axis.title = element_text(size = 14),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          plot.subtitle = element_text(hjust = 0.5, size = 12)) +
    labs(title = paste("Distribution of", pet_var, "by Group"),
         subtitle = paste("ANOVA p =", format(anova_pval, digits = 3), 
                          "| p-values"),
         x = "Group",
         y = pet_var) +
    stat_pvalue_manual(pwc_raw, 
                       label = "p.signif",  # Use raw p-value significance
                       tip.length = 0.01, 
                       bracket.nudge.y = 0.05) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))  # Add space for brackets
  
  # Return all results
  return(list(
    plot = p, 
    anova_pval = anova_pval, 
    tukey_hsd = tukey_df,  # Tukey HSD results for reference
    pairwise_raw = pwc_raw  # Raw p-values that are plotted
  ))
}

# Create box plots and statistical tests for all PET variables
results_list <- list()
plot_list <- list()

for(pet in pet_variables) {
  result <- create_boxplot_with_stats(pet_dat3, pet)
  plot_list[[pet]] <- result$plot
  results_list[[pet]] <- list(
    anova_pval = result$anova_pval,
    tukey_hsd = result$tukey_hsd,
    pairwise_raw = result$pairwise_raw
  )
}

# Optional: Print summary of results
for(pet in names(results_list)) {
  cat("\n", pet, ":\n", sep = "")
  cat("ANOVA p-value:", format(results_list[[pet]]$anova_pval, digits = 4), "\n")
  cat("\nTukey HSD adjusted p-values:\n")
  print(results_list[[pet]]$tukey_hsd[, "p adj", drop = FALSE])
  cat("\nUnadjusted p-values (shown on plot):\n")
  print(results_list[[pet]]$pairwise_raw[, c("group1", "group2", "p", "p.signif")])
  cat("\n", rep("-", 50), "\n", sep = "")
}
# library(ggplot2)
# library(ggpubr)
# library(rstatix)
# library(gridExtra)
# 
# # Function to create box plot with ANOVA and pairwise comparisons
# create_boxplot_with_stats <- function(data, pet_var, group_var = "group") {
#   # Perform ANOVA
#   anova_formula <- as.formula(paste(pet_var, "~", group_var))
#   anova_result <- aov(anova_formula, data = data)
#   anova_pval <- summary(anova_result)[[1]][["Pr(>F)"]][1]
#   
#   # Perform pairwise comparisons
#   pwc <- data %>%
#     rstatix::pairwise_t_test(
#       formula = as.formula(paste(pet_var, "~", group_var)),
#       p.adjust.method = "bonferroni"
#     ) %>%
#     add_xy_position(x = group_var)
#   
#   # Create the plot
#   p <- ggplot(data, aes_string(x = group_var, y = pet_var, fill = group_var)) +
#     geom_boxplot(alpha = 0.7, outlier.shape = NA) +
#     geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
#     theme_minimal() +
#     theme(legend.position = "none",
#           axis.text.x = element_text(face = "bold", size = 12),
#           axis.title = element_text(size = 14),
#           plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
#           plot.subtitle = element_text(hjust = 0.5, size = 12)) +
#     labs(title = paste("Distribution of", pet_var, "by Group"),
#          subtitle = paste("ANOVA p-value:", format(anova_pval, digits = 3)),
#          x = "Group",
#          y = pet_var) +
#     stat_pvalue_manual(pwc, label = "p.adj.signif", 
#                        tip.length = 0.01, 
#                        bracket.nudge.y = 0.05)
#   
#   return(list(plot = p, anova_pval = anova_pval, pairwise = pwc))
# }
# 
# # Create box plots and statistical tests for all PET variables
# results_list <- list()
# plot_list <- list()
# 
# for(pet in pet_variables) {
#   result <- create_boxplot_with_stats(pet_dat3, pet)
#   plot_list[[pet]] <- result$plot
#   results_list[[pet]] <- list(
#     anova_pval = result$anova_pval,
#     pairwise = result$pairwise
#   )
# }
# 
# Save combined box plots
png(fs::path(dir.results, "Boxplots_Liver_Pet_by_Group_with_Stats2.png"),
    width = 7000, height = 3000, res = 300)
do.call(grid.arrange, c(plot_list, ncol = 3))
dev.off()

# Create a summary table of ANOVA results
anova_summary <- data.frame(
  PET_Variable = pet_variables,
  ANOVA_pvalue = sapply(results_list, function(x) x$anova_pval),
  Significant = sapply(results_list, function(x) ifelse(x$anova_pval < 0.05, "Yes", "No"))
)

write.csv(anova_summary, 
          fs::path(dir.results, "ANOVA_Summary_PET_by_Group.csv"), 
          row.names = FALSE)

# Create detailed pairwise comparison table
all_pairwise <- data.frame()
for(pet in names(results_list)) {
  pwc_data <- results_list[[pet]]$pairwise
  pwc_data$PET_Variable <- pet
  all_pairwise <- rbind(all_pairwise, pwc_data)
}

write.csv(all_pairwise, 
          fs::path(dir.results, "Pairwise_Comparisons_PET_by_Group.csv"), 
          row.names = FALSE)

# Correlation analysis stratified by group
total_results_by_group <- data.frame()
for(grp in unique(pet_dat3$group)) {
  # Subset data by group
  group_data <- pet_dat3[pet_dat3$group == grp, ]
  
  for(pet in pet_variables) {
    for(insulin in insulin_vars) {
      # Check if we have enough non-missing values
      complete_cases <- sum(!is.na(group_data[[pet]]) & !is.na(group_data[[insulin]]))
      
      if(complete_cases > 3) {  # Need at least 4 observations for correlation
        # Pearson correlation test
        pearson_test <- cor.test(group_data[[pet]], group_data[[insulin]], 
                                 method = "pearson", conf.level = 0.95)
        corr.p <- pearson_test$estimate
        p.p <- pearson_test$p.value
        
        # Spearman correlation test
        spearman_test <- cor.test(group_data[[pet]], group_data[[insulin]], 
                                  method = "spearman", conf.level = 0.95)
        corr.s <- spearman_test$estimate
        p.s <- spearman_test$p.value
      } else {
        corr.p <- corr.s <- p.p <- p.s <- NA
      }
      
      results <- data.frame(Group = grp, Pet = pet, IR = insulin, 
                            Corr_p = corr.p, Pval_p = p.p, 
                            Corr_s = corr.s, Pval_s = p.s,
                            N = complete_cases)
      total_results_by_group <- rbind(total_results_by_group, results)
    }
  }
}

# Create faceted heatmap function
create_faceted_heatmap <- function(data, value_col, pval_col, title, 
                                   color_low = "blue", color_high = "red", 
                                   color_mid = "white", limits = c(-1, 1)) {
  
  # Prepare data with significance stars
  plot_data <- data %>%
    mutate(value = .data[[value_col]],
           pval = .data[[pval_col]],
           stars = get_sig_stars(pval),
           label = paste0(round(value, 2), stars))
  
  # Create faceted heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = value)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "Correlation") +
    facet_wrap(~ Group, ncol = 2) +  # Adjust ncol based on number of groups
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          strip.text = element_text(face = "bold", size = 14),
          strip.background = element_rect(fill = "lightgray", color = "black"),
          panel.spacing = unit(1, "lines")) +
    labs(title = title)
  
  return(p)
}

# Create faceted heatmaps
heatmap_spearman_faceted <- create_faceted_heatmap(total_results_by_group, 
                                                   value_col = "Corr_s", 
                                                   pval_col = "Pval_s",
                                                   title = "Spearman Correlation Coefficients by Group")

heatmap_pearson_faceted <- create_faceted_heatmap(total_results_by_group, 
                                                  value_col = "Corr_p", 
                                                  pval_col = "Pval_p",
                                                  title = "Pearson Correlation Coefficients by Group")

# Save faceted heatmaps
png(fs::path(dir.results, "Heatmap_Pearson_Faceted_by_Group2.png"), 
    width = 4000, height = 3000, res = 300)
print(heatmap_pearson_faceted)
dev.off()

png(fs::path(dir.results, "Heatmap_Spearman_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(heatmap_spearman_faceted)
dev.off()


# Stratified linear regression by group
regression_results_by_group <- data.frame()

for(grp in unique(pet_dat3$group)) {
  # Subset data by group
  group_data <- pet_dat3[pet_dat3$group == grp, ]
  
  for(pet in pet_variables) {
    for(insulin in insulin_vars) {
      # Check if we have enough non-missing values
      complete_cases <- sum(!is.na(group_data[[pet]]) & !is.na(group_data[[insulin]]))
      
      if(complete_cases > 3) {  # Need at least 4 observations for regression
        # Linear regression: pet ~ insulin
        formula <- as.formula(paste0(pet, " ~ ", insulin))
        model <- lm(formula, data = group_data)
        
        # Extract coefficients
        beta <- summary(model)$coef[2, 1]  # Insulin coefficient
        se <- summary(model)$coef[2, 2]    # Standard error
        pval <- summary(model)$coef[2, 4]  # P-value
        
        # Get R-squared
        r_squared <- summary(model)$r.squared
        
        # Get confidence intervals
        ci <- confint(model)[2, ]
        ci_lower <- ci[1]
        ci_upper <- ci[2]
      } else {
        beta <- se <- pval <- r_squared <- ci_lower <- ci_upper <- NA
      }
      
      # Store results
      results <- data.frame(
        Group = grp,
        Pet = pet,
        IR = insulin,
        Beta = beta,
        SE = se,
        Pval = pval,
        CI_lower = ci_lower,
        CI_upper = ci_upper,
        R_squared = r_squared,
        N = complete_cases
      )
      
      regression_results_by_group <- rbind(regression_results_by_group, results)
    }
  }
}

# Create faceted heatmap for regression coefficients
create_faceted_regression_heatmap <- function(data, title, 
                                              color_low = "blue", color_high = "red", 
                                              color_mid = "white") {
  
  # Prepare data with significance stars
  plot_data <- data %>%
    mutate(stars = get_sig_stars(Pval),
           label = paste0(round(Beta, 2), stars),
           # Create a label with CI for tooltip or alternative display
           full_label = paste0("β=", round(Beta, 2), 
                               " [", round(CI_lower, 2), ", ", round(CI_upper, 2), "]",
                               stars))
  
  # Determine color limits based on beta values
  beta_range <- range(plot_data$Beta, na.rm = TRUE)
  max_abs <- max(abs(beta_range))
  limits <- c(-max_abs, max_abs)
  
  # Create faceted heatmap
  p <- ggplot(plot_data, aes(x = IR, y = Pet, fill = Beta)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = label), size = 3) +
    scale_fill_gradient2(low = color_low, mid = color_mid, high = color_high,
                         midpoint = 0, limits = limits,
                         name = "β Coefficient") +
    facet_wrap(~ Group, ncol = 2) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
          axis.title = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
          strip.text = element_text(face = "bold", size = 14),
          strip.background = element_rect(fill = "lightgray", color = "black"),
          panel.spacing = unit(1, "lines")) +
    labs(title = title)
  
  return(p)
}

# Create the faceted heatmap
regression_heatmap_faceted <- create_faceted_regression_heatmap(
  regression_results_by_group,
  title = "Linear Regression β Coefficients (PET ~ Insulin) by Group"
)

# Save the heatmap
png(fs::path(dir.results, "Heatmap_Regression_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(regression_heatmap_faceted)
dev.off()

# Create a summary table with comparisons between groups
regression_comparison <- regression_results_by_group %>%
  select(Group, Pet, IR, Beta, Pval, R_squared) %>%
  pivot_wider(names_from = Group, 
              values_from = c(Beta, Pval, R_squared),
              names_sep = "_") %>%
  # Calculate differences if you have exactly 2 groups
  # Adjust group names as needed
  mutate(
    Beta_diff = abs(Beta_Group1 - Beta_Group2),  # Adjust group names
    Both_sig = ifelse(Pval_Group1 < 0.05 & Pval_Group2 < 0.05, "Both", 
                      ifelse(Pval_Group1 < 0.05, "Group1 only",
                             ifelse(Pval_Group2 < 0.05, "Group2 only", "Neither")))
  ) %>%
  arrange(desc(Beta_diff))

write.csv(regression_comparison, 
          fs::path(dir.results, "Regression_Comparison_by_Group.csv"), 
          row.names = FALSE)

# Optional: Create a plot showing R-squared values by group
r_squared_plot <- ggplot(regression_results_by_group, 
                         aes(x = IR, y = Pet, fill = R_squared)) +
  geom_tile(color = "white", size = 0.5) +
  geom_text(aes(label = round(R_squared, 2)), size = 3) +
  scale_fill_gradient(low = "white", high = "darkgreen",
                      name = "R²") +
  facet_wrap(~ Group, ncol = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        strip.text = element_text(face = "bold", size = 14),
        strip.background = element_rect(fill = "lightgray", color = "black")) +
  labs(title = "Model R² Values by Group")

png(fs::path(dir.results, "Heatmap_R_squared_Faceted_by_Group.png"), 
    width = 4000, height = 3000, res = 300)
print(r_squared_plot)
dev.off()

# Create a combined visualization showing both beta and significance
# This creates a more detailed view with confidence intervals
create_detailed_regression_plot <- function(data, pet_var) {
  pet_data <- data[data$Pet == pet_var, ]
  
  p <- ggplot(pet_data, aes(x = IR, y = Beta, color = Group)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
    geom_point(position = position_dodge(width = 0.3), size = 3) +
    geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper), 
                  position = position_dodge(width = 0.3), 
                  width = 0.2) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(hjust = 0.5, face = "bold")) +
    labs(title = paste("Regression Coefficients for", pet_var),
         x = "Insulin Variable",
         y = "β Coefficient (95% CI)",
         color = "Group")
  
  return(p)
}

# Create individual plots for each PET variable
for(pet in pet_variables) {
  p <- create_detailed_regression_plot(regression_results_by_group, pet)
  
  png(fs::path(dir.results, paste0("Regression_CI_Plot_", pet, ".png")), 
      width = 2500, height = 2000, res = 300)
  print(p)
  dev.off()
}
```

