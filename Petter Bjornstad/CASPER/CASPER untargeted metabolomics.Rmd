---
title: "CASPER Untargeted Metabolomics"
author: "Tim Vigers & Laura Pyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics")
library(arsenal)
library(skimr)
library(knitr)
library(mixOmics)
library(limma)
library(tidyverse)
library(haven)
library(psych)
library(WGCNA)
library(pheatmap)
library(pander)
library(parallel)
set.seed(1017)
```

```{r data,include=FALSE}
# Import data
raw_data <- read.csv("./Raw data/2020-03-20 Bjornstad discovery mode results jrh v2.csv",stringsAsFactors=F,na.strings = "")
samples <- read.csv("./Clean data/KNN_serum.csv_sampledata.csv")
samples$X <- NULL
# Transpose
compounds <- 
  paste("W",raw_data$Molecular.Weight,raw_data$RT..min.,sep="_")
df <- raw_data %>% dplyr::select(CS.01:RH.47.L) %>% t()
colnames(df) <- compounds
df <- as.data.frame(df)
# Sample data
df$ID <- sub("\\.","-",sub(".L","",rownames(df)))
df <- left_join(df,samples,by = "ID")
# Outcome 
df$group <- factor(df$group,levels = c(1,4),labels = c("T1D","Control"))
# SAS data
sas <- read_sas("./Raw data/casperheir_for_laura.sas7bdat")
# Add
df <- left_join(df,by = "ID",
                sas[,c("ID","kidney_GFR","medullary_GFR","cortex_GFR",
                       "M_I_kg_GC","M_I_leankg_GC")])
# Reorganize
df <- df %>% dplyr::select(ID:M_I_leankg_GC,everything())
# Delete SAS data
rm(sas)
```

# Preprocessing

```{r preprocessing}
# Check for samples missing > 80% of compounds, remove them
missing <- 
  which(rowSums(is.na(df[,11:ncol(df)])) / length(11:ncol(df)) > 0.8)
if (length(missing)>0){df <- df[-missing,]}
# Same for 0 instead of NA - none
missing0 <- 
  which(rowSums(df[,11:ncol(df)] == 0) / length(11:ncol(df)) > 0.8)
```

Removed `r length(missing)` samples missing > 80% of compounds and `r length(missing0)` samples with > 80% of compounds equal to 0. 

```{r}
X <- df[,16:ncol(df)]
rownames(X) = df$ID
```

# PCA

```{r pca,eval=FALSE}
# 3 PCs
pca.res <- pca(X, ncomp = 3, center = TRUE, scale = FALSE)
# Plot
plotIndiv(pca.res,group = df$group,legend = TRUE,ind.names = FALSE,
          title = 'PCA by Group (PCs 1 & 2)',ellipse = T)
plotIndiv(pca.res,comp = c(1,3),group = df$group,legend = TRUE,
          ind.names = FALSE,title = 'PCA by Group (PCs 1 & 3)',
          ellipse = T)
plotIndiv(pca.res,comp = c(2,3),group = df$group,legend = TRUE,
          ind.names = FALSE,title = 'PCA by Group (PCs 2 & 3)',
          ellipse = T)
```

# PLS-DA

## PLS-DA Performance

```{r plsda loo,cache=TRUE}
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
                        validation = "loo")
plot(perf_plsda_true,
     col = color.mixo(5:7), sd = TRUE, legend.position = "horizontal")
# The performance plot looks a little bit strange, but it appears the 2 components is the best option
auc_true1 <- as.numeric(perf_plsda_true$auc$comp1["AUC.mean"])
auc_true2 <- as.numeric(perf_plsda_true$auc$comp2["AUC.mean"])
```

Performance was evaluated for 10 PLS-DA components using leave one out (LOO) cross-validation (CV). Two components resulted in the lowest overall classification error. For component 1, overall error rate was `r round(perf_plsda_true$error.rate.all$overall$centroids.dist[1],3)` with AUC of `r auc_true1`. For component 2, overall error rate was `r round(perf_plsda_true$error.rate.all$overall$centroids.dist[2],3)` with AUC of `r auc_true2`.

```{r plsda results}
plotIndiv(plsda_true,comp = c(1,2),title = "PLS-DA Components 1 & 2",
          ellipse = T,legend = T,ind.names = F)
```

## Permutation Testing

```{r permutation testing,cache=TRUE,include=FALSE}
# Permutation testing
n_perm <- 10
# Parallel
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
aucs = clusterApply(cl,c(1:n_perm),function(i){
  set.seed(1+i)
  Y <- sample(df$group,replace = F)
  plsda_res <- plsda(X,Y,ncomp = 2)
  perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
                     validation = "loo")
  auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
  auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
  return(c(auc1,auc2))
})
stopCluster(cl)
aucs = as.data.frame(do.call(rbind,aucs))
```

```{r plot perms}
# Plot for each component
plot1 <- ggplot(aucs,aes(x=V1)) + 
  geom_histogram(binwidth = 0.01) + 
  geom_vline(aes(xintercept=auc_true1),color="red") + 
  theme_bw() + xlab("AUC") + ggtitle("Component 1")
plot1
plot2 <- ggplot(aucs,aes(x=V2)) + 
  geom_histogram(binwidth = 0.01) + 
  geom_vline(aes(xintercept=auc_true2),color="red") + 
  theme_bw() + xlab("AUC") + ggtitle("Component 2")
plot2
# Permutation p values
p1 <- (sum(aucs$V1 > auc_true1) + 1) / (length(aucs$V1) + 1)
p2 <- (sum(aucs$V2 > auc_true2) + 1) / (length(aucs$V2) + 1)
```

Group labels were permuted `r n_perm` times. Two component PLS-DA was run for each permutation and AUC was calculated using LOO CV. Red line indicates the AUC calculated for non-permuted data, and the gray histogram represents the null distribution of AUC. So, the permutation-based p value for AUC of component 1 is `r format.pval(p1,eps = 0.001)` and is `r  format.pval(p2,eps = 0.001)` for component 2. In other words, it's likely that PLS-DA is finding genuine differences between group 1 and group 4 and the AUC is not purely due to overfitting.

## Loadings

List of top 20 identified compounds in terms of discrimination for component 1 of the PLS-DA:

```{r comp1 vars}
var1 <- selectVar(plsda_true,comp = 1)$name
names <- raw_data$Name[match(var1,compounds)]
top20_pls <- var1[which(!is.na(names))[1:20]]
kable(head(names[!is.na(names)],20),col.names = "Compound Name")
```

List of top 20 identified compounds in terms of discrimination for component 2:

```{r comp2 vars}
var2 <- selectVar(plsda_true,comp = 2)$name
names <- raw_data$Name[match(var2,compounds)]
kable(head(names[!is.na(names)],20),col.names = "Compound Name")
```

# Moderated t tests

Top 20 identified metabolites that are significantly different between groups. P values adjusted using the FDR method. The reference group here is T1D, so negative logFC values indicate that the metabolite was lower in controls (and positive values indicate it was higher).

```{r message=FALSE}
# Design matrix - 0 and 1 for CAC progression
design <- model.matrix(~factor(group),df)
# Linear model - X is "expression" matrix (samples in columns)
# Log base 2 transformation
fit <- lmFit(log(t(X),base = 2),design)
fit <- eBayes(fit)
# Results
results <- topTable(fit,coef = "factor(group)Control",number = ncol(X),
                    adjust.method = "BH")
results$m.z <- sapply(strsplit(rownames(results),"_"),"[[",2)
results$p.value <- results$P.Value
results$t.score <- results$t
results$Compound <- raw_data$Name[match(rownames(results),compounds)]
top20 <- rownames(results[!is.na(results$Compound),])[1:20]
# These results must then be uploaded to MetaboAnalyst for compound identification.
write.csv(results[,c("m.z","p.value","t.score")],na="",row.names = F,
          file = "./Clean data/untargeted_metaboanalyst.csv")
write.csv(results[,c("m.z","logFC","p.value","t.score")],
          na="",row.names = F,
          file = "./Clean data/untargeted_results.csv")
# table
results <- 
  results[!is.na(results$Compound),
          c("Compound","m.z","logFC","t.score","p.value","adj.P.Val")]
kable(head(results,20),row.names = F)
```

# Heatmap

```{r cim,include=FALSE,cache=TRUE}
# Color by T1D status
colors <- c("steelblue","orange")
colors <- colors[as.numeric(factor(Y))]
# Heatmap
obj.cim = cim(plsda_true,col.names = F,row.sideColors = colors,
              clust.method = c("complete","complete"),save = 'jpeg',
              name.save = 'PLScim')
```

![](Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics/PLScim.jpeg)

# Correlations for the Metabolites by Moderated t test

```{r}
vars = c("M_I_kg_GC","M_I_leankg_GC","body_fat",
         "screen_bmi_percentile","rpf","acr_mean","kidney_oxygenation",
         "gfr","kidney_GFR","medullary_GFR","cortex_GFR")
varnames = c("M_I_kg_GC","M_I_leankg_GC","Body fat","BMI %ile","RPF",
             "Mean ACR","Kidney Oxy.","GFR","Kidney GFR","Medullary GFR",
             "Cortex GFR")
intersection = intersect(top20,top20_pls)
```

### Correlations

```{r}
c = corr.test(X[,intersection],df[,vars],method = "spearman")
rownames(c$r) <- raw_data$Name[match(rownames(c$r),compounds)]
colnames(c$r) <- varnames

emphasize.strong.cells(which(c$p < 0.05, arr.ind = TRUE))
pander(c$r)
```

### Heatmap

```{r}
heatmap(c$r,margins = c(8,8))
```

## Correlations by interesting metabolite

```{r results='asis'}
# Find interesting results to report
report = as.data.frame(which(c$p < 0.07 & abs(c$r) >= 0.4,arr.ind = T))
for (r in levels(factor(report$row))) {
  col = report$col[report$row == r]
  corrs = as.data.frame(cbind(c$r[as.numeric(r),c(col)],
                              c$p[as.numeric(r),c(col)]))
  rownames(corrs) = colnames(c$r)[col]
  colnames(corrs) = c("R","p")
  print(kable(corrs,
              caption = rownames(report)[
                which(report$row ==  as.numeric(r))[1]]))
}
```

# Pathway expression

```{r}
results = read.csv("./Clean data/untargeted_results.csv")
# Import list of metabolites
matched = read.csv("./Clean data/mummichog_matched_compound_all.csv")
# Galactose
galactose = 
  read.csv("./Clean data/galactose_compounds.csv",na.strings = "")
galactose_w = matched$Query.Mass[match(galactose$significant,
                                       matched$Matched.Compound)]
galactose_dir = results$logFC[match(galactose_w,results$m.z)]
# methionine
methionine = 
  read.csv("./Clean data/methionine_cysteine_compounds.csv",
           na.strings = "")
methionine_w = matched$Query.Mass[match(methionine$significant,
                                        matched$Matched.Compound)]
methionine_dir = unlist(lapply(methionine_w, function(w){
  results$logFC[which.min(abs(w-as.numeric(as.character(results$m.z))))]
}))
# selenoamino
selenoamino = 
  read.csv("./Clean data/selenoamino_compounds.csv",
           na.strings = "")
selenoamino_w = matched$Query.Mass[match(selenoamino$significant,
                                         matched$Matched.Compound)]
selenoamino_dir = unlist(lapply(selenoamino_w, function(w){
  results$logFC[which.min(abs(w-as.numeric(as.character(results$m.z))))]
}))
# b12
b12 = 
  read.csv("./Clean data/b12_compounds.csv",
           na.strings = "")
b12_w = 
  matched[match(b12$significant,matched$Matched.Compound),"Query.Mass"]
b12_dir = unlist(lapply(b12_w, function(w){
  results$logFC[which.min(abs(w-as.numeric(as.character(results$m.z))))]
}))
# valine
valine = 
  read.csv("./Clean data/valine_etc_degradation_compounds.csv",
           na.strings = "")
valine_w = matched$Query.Mass[match(valine$significant,
                                         matched$Matched.Compound)]
valine_dir = unlist(lapply(valine_w, function(w){
  results$logFC[which.min(abs(w-as.numeric(as.character(results$m.z))))]
}))
```
