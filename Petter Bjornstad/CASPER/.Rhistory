df$group <- factor(df$group,levels = c(1,4),labels = c("T1D","Control"))
# SAS data
sas <- read_sas("./Raw data/casperheir_for_laura.sas7bdat")
# Add
df <- left_join(df,by = "ID",
sas[,c("ID","kidney_GFR","medullary_GFR","cortex_GFR",
"M_I_kg_GC","M_I_leankg_GC")])
# Reorganize
df <- df %>% dplyr::select(ID:cortex_GFR,everything())
# Delete SAS data
rm(sas)
# Check for samples missing > 80% of compounds, remove them
missing <-
which(rowSums(is.na(df[,11:ncol(df)])) / length(11:ncol(df)) > 0.8)
if (length(missing)>0){df <- df[-missing,]}
# Same for 0 instead of NA - none
missing0 <-
which(rowSums(df[,11:ncol(df)] == 0) / length(11:ncol(df)) > 0.8)
X <- df[,14:ncol(df)]
rownames(X) = df$ID
# 3 PCs
pca.res <- pca(X, ncomp = 3, center = TRUE, scale = FALSE)
# Plot
plotIndiv(pca.res,group = df$group,legend = TRUE,ind.names = FALSE,
title = 'PCA by Group (PCs 1 & 2)',ellipse = T)
# 3 PCs
pca.res <- pca(X, ncomp = 3, center = TRUE, scale = FALSE)
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
validation = "loo")
# Permutation testing
cl = makeCluster(12)
library(parallel)
cl = makeCluster(12)
n_perm <- 5
aucs1 <- vector(mode="numeric", length=n_perm)
aucs2 <- vector(mode="numeric", length=n_perm)
parLapply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1[i] <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2[i] <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
})
?makeCluster
# Permutation testing
cl = makeCluster(12,type = "FORK")
install.packages("snow")
library(snow)
stopCluster(cl)
# Permutation testing
cl = snow::makeCluster(12)
?makeCluster
n_perm <- 5
aucs1 <- vector(mode="numeric", length=n_perm)
aucs2 <- vector(mode="numeric", length=n_perm)
parLapply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1[i] <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2[i] <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
})
clusterApply()
?clusterApply
clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1[i] <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2[i] <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
})
stopCluster(cl)
n_perm <- 5
aucs1 <- vector(mode="numeric", length=n_perm)
aucs2 <- vector(mode="numeric", length=n_perm)
lapply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1[i] <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2[i] <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
})
lapply(c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1[i] <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2[i] <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
})
n_perm <- 1
i = 1
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
aucs1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
aucs2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
aucs1
aucs2
return(c(auc1,auc2))
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
aucs = lapply(c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
View(aucs)
n_perm <- 2
aucs = lapply(c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
View(aucs)
# Permutation testing
cl = snow::makeCluster(12)
n_perm <- 10
aucs = clusterApply(c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
aucs = clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
sample(df$group,replace = F)
samples = lapply(1:n_perm, function(i){
set.seed(1+i)
sample(df$group,replace = F)
})
samples[1]
aucs = clusterApply(cl,samples,function(s){
plsda_res <- plsda(X,s,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
?makeCluster
getClusterOption("type")
# Permutation testing
cl = snow::makeCluster(12,type = "FORK")
library(parallel)
?clusterExport
?clusterEvalQ
# Permutation testing
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
stopCluster(cl)
# Permutation testing
n_perm <- 10
# Parallel
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
aucs = clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
# Permutation testing
n_perm <- 5
# Permutation testing
n_perm <- 5
# Parallel
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
aucs = clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
stopCluster(cl)
aucs = do.call(rbind,aucs)
warnings
warnings()
stopCluster(cl)
View(aucs)
# Plot for each component
plot1 <- ggplot(aucs,aes(x=V1)) +
geom_histogram(binwidth = 0.01) +
geom_vline(aes(xintercept=auc_true1),color="red") +
theme_bw() + xlab("AUC") + ggtitle("Component 1")
# Permutation testing
n_perm <- 2
# Parallel
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
aucs = clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
stopCluster(cl)
aucs = as.data.frame(do.call(rbind,aucs))
# Plot for each component
plot1 <- ggplot(aucs,aes(x=V1)) +
geom_histogram(binwidth = 0.01) +
geom_vline(aes(xintercept=auc_true1),color="red") +
theme_bw() + xlab("AUC") + ggtitle("Component 1")
plot1
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
validation = "loo")
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics")
library(arsenal)
library(skimr)
library(knitr)
library(mixOmics)
library(limma)
library(tidyverse)
library(haven)
library(psych)
library(WGCNA)
library(pheatmap)
library(pander)
library(parallel)
set.seed(1017)
# Import data
raw_data <- read.csv("./Raw data/2020-03-20 Bjornstad discovery mode results jrh v2.csv",stringsAsFactors=F,na.strings = "")
samples <- read.csv("./Clean data/KNN_serum.csv_sampledata.csv")
samples$X <- NULL
# Transpose
compounds <-
paste("W",raw_data$Molecular.Weight,raw_data$RT..min.,sep="_")
df <- raw_data %>% dplyr::select(CS.01:RH.47.L) %>% t()
colnames(df) <- compounds
df <- as.data.frame(df)
# Sample data
df$ID <- sub("\\.","-",sub(".L","",rownames(df)))
df <- left_join(df,samples,by = "ID")
# Outcome
df$group <- factor(df$group,levels = c(1,4),labels = c("T1D","Control"))
# SAS data
sas <- read_sas("./Raw data/casperheir_for_laura.sas7bdat")
# Add
df <- left_join(df,by = "ID",
sas[,c("ID","kidney_GFR","medullary_GFR","cortex_GFR",
"M_I_kg_GC","M_I_leankg_GC")])
# Reorganize
df <- df %>% dplyr::select(ID:cortex_GFR,everything())
# Delete SAS data
rm(sas)
# Check for samples missing > 80% of compounds, remove them
missing <-
which(rowSums(is.na(df[,11:ncol(df)])) / length(11:ncol(df)) > 0.8)
if (length(missing)>0){df <- df[-missing,]}
# Same for 0 instead of NA - none
missing0 <-
which(rowSums(df[,11:ncol(df)] == 0) / length(11:ncol(df)) > 0.8)
X <- df[,14:ncol(df)]
rownames(X) = df$ID
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
validation = "loo")
plot(perf_plsda_true,
col = color.mixo(5:7), sd = TRUE, legend.position = "horizontal")
# The performance plot looks a little bit strange, but it appears the 2 components is the best option
auc_true1 <- as.numeric(perf_plsda_true$auc$comp1["AUC.mean"])
auc_true2 <- as.numeric(perf_plsda_true$auc$comp2["AUC.mean"])
plotIndiv(plsda_true,comp = c(1,2),title = "PLS-DA Components 1 & 2",
ellipse = T,legend = T,ind.names = F)
# Permutation testing
n_perm <- 2
# Parallel
cl = makeCluster(12)
clusterEvalQ(cl, library(mixOmics))
#You need to load your data into the cluster also
clusterExport(cl, "X")
clusterExport(cl, "df")
aucs = clusterApply(cl,c(1:n_perm),function(i){
set.seed(1+i)
Y <- sample(df$group,replace = F)
plsda_res <- plsda(X,Y,ncomp = 2)
perf_plsda <- perf(plsda_res,progressBar=FALSE, auc=TRUE,
validation = "loo")
auc1 <- as.numeric(perf_plsda$auc$comp1["AUC.mean"])
auc2 <- as.numeric(perf_plsda$auc$comp2["AUC.mean"])
return(c(auc1,auc2))
})
stopCluster(cl)
aucs = as.data.frame(do.call(rbind,aucs))
# Plot for each component
plot1 <- ggplot(aucs,aes(x=V1)) +
geom_histogram(binwidth = 0.01) +
geom_vline(aes(xintercept=auc_true1),color="red") +
theme_bw() + xlab("AUC") + ggtitle("Component 1")
plot1
plot2 <- ggplot(aucs,aes(x=V2)) +
geom_histogram(binwidth = 0.01) +
geom_vline(aes(xintercept=auc_true2),color="red") +
theme_bw() + xlab("AUC") + ggtitle("Component 2")
plot2
# Permutation p values
p1 <- (sum(aucs$V1 > auc_true1) + 1) / (length(aucs$V1) + 1)
p2 <- (sum(aucs$V2 > auc_true2) + 1) / (length(aucs$V2) + 1)
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics")
library(arsenal)
library(skimr)
library(knitr)
library(mixOmics)
library(limma)
library(tidyverse)
library(haven)
library(psych)
library(WGCNA)
library(pheatmap)
library(pander)
library(parallel)
set.seed(1017)
# Import data
raw_data <- read.csv("./Raw data/2020-03-20 Bjornstad discovery mode results jrh v2.csv",stringsAsFactors=F,na.strings = "")
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics")
library(arsenal)
library(skimr)
library(knitr)
library(mixOmics)
library(limma)
library(tidyverse)
library(haven)
library(psych)
library(WGCNA)
library(pheatmap)
library(pander)
library(parallel)
set.seed(1017)
# Import data
raw_data <- read.csv("./Raw data/2020-03-20 Bjornstad discovery mode results jrh v2.csv",stringsAsFactors=F,na.strings = "")
samples <- read.csv("./Clean data/KNN_serum.csv_sampledata.csv")
samples$X <- NULL
# Transpose
compounds <-
paste("W",raw_data$Molecular.Weight,raw_data$RT..min.,sep="_")
df <- raw_data %>% dplyr::select(CS.01:RH.47.L) %>% t()
colnames(df) <- compounds
df <- as.data.frame(df)
# Sample data
df$ID <- sub("\\.","-",sub(".L","",rownames(df)))
df <- left_join(df,samples,by = "ID")
# Outcome
df$group <- factor(df$group,levels = c(1,4),labels = c("T1D","Control"))
# SAS data
sas <- read_sas("./Raw data/casperheir_for_laura.sas7bdat")
# Add
df <- left_join(df,by = "ID",
sas[,c("ID","kidney_GFR","medullary_GFR","cortex_GFR",
"M_I_kg_GC","M_I_leankg_GC")])
# Reorganize
df <- df %>% dplyr::select(ID:cortex_GFR,everything())
# Delete SAS data
rm(sas)
# Check for samples missing > 80% of compounds, remove them
missing <-
which(rowSums(is.na(df[,11:ncol(df)])) / length(11:ncol(df)) > 0.8)
if (length(missing)>0){df <- df[-missing,]}
# Same for 0 instead of NA - none
missing0 <-
which(rowSums(df[,11:ncol(df)] == 0) / length(11:ncol(df)) > 0.8)
X <- df[,14:ncol(df)]
rownames(X) = df$ID
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
validation = "loo")
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Metabolomics")
library(arsenal)
library(skimr)
library(knitr)
library(mixOmics)
library(limma)
library(tidyverse)
library(haven)
library(psych)
library(WGCNA)
library(pheatmap)
library(pander)
library(parallel)
set.seed(1017)
# Import data
raw_data <- read.csv("./Raw data/2020-03-20 Bjornstad discovery mode results jrh v2.csv",stringsAsFactors=F,na.strings = "")
samples <- read.csv("./Clean data/KNN_serum.csv_sampledata.csv")
samples$X <- NULL
# Transpose
compounds <-
paste("W",raw_data$Molecular.Weight,raw_data$RT..min.,sep="_")
df <- raw_data %>% dplyr::select(CS.01:RH.47.L) %>% t()
colnames(df) <- compounds
df <- as.data.frame(df)
# Sample data
df$ID <- sub("\\.","-",sub(".L","",rownames(df)))
df <- left_join(df,samples,by = "ID")
# Outcome
df$group <- factor(df$group,levels = c(1,4),labels = c("T1D","Control"))
# SAS data
sas <- read_sas("./Raw data/casperheir_for_laura.sas7bdat")
# Add
df <- left_join(df,by = "ID",
sas[,c("ID","kidney_GFR","medullary_GFR","cortex_GFR",
"M_I_kg_GC","M_I_leankg_GC")])
# Reorganize
df <- df %>% dplyr::select(ID:cortex_GFR,everything())
# Delete SAS data
rm(sas)
# Check for samples missing > 80% of compounds, remove them
missing <-
which(rowSums(is.na(df[,11:ncol(df)])) / length(11:ncol(df)) > 0.8)
if (length(missing)>0){df <- df[-missing,]}
# Same for 0 instead of NA - none
missing0 <-
which(rowSums(df[,11:ncol(df)] == 0) / length(11:ncol(df)) > 0.8)
X <- df[,14:ncol(df)]
rownames(X) = df$ID
# Group as outcome
Y <- as.factor(df$group)
# PLS-DA function
plsda_true <- plsda(X,Y,ncomp = 10)
# Check error and look at optimal number of components
perf_plsda_true <- perf(plsda_true,progressBar=FALSE, auc=TRUE,
validation = "loo")
plot(perf_plsda_true,
col = color.mixo(5:7), sd = TRUE, legend.position = "horizontal")
# The performance plot looks a little bit strange, but it appears the 2 components is the best option
auc_true1 <- as.numeric(perf_plsda_true$auc$comp1["AUC.mean"])
auc_true2 <- as.numeric(perf_plsda_true$auc$comp2["AUC.mean"])
plotIndiv(plsda_true,comp = c(1,2),title = "PLS-DA Components 1 & 2",
ellipse = T,legend = T,ind.names = F)
