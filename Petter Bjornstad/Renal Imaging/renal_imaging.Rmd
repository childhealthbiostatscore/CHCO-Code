---
title: "Predicting GFR From Renal Imaging"
author: "Tim Vigers & Laura Pyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
library(redcapAPI)
library(arsenal)
library(tidyverse)
library(performance)
library(knitr)
library(GGally)
library(glmnet)
library(broom)
library(naniar)
library(caret)
knitr::opts_chunk$set(echo = FALSE)
if(Sys.info()["sysname"] == "Windows"){
  home_dir = "B:/Projects"
} else if (Sys.info()["sysname"] == "Linux"){
  home_dir = "~/UCD/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Renal Imaging"
} else if (Sys.info()["sysname"] == "Darwin"){
  home_dir = "/Volumes/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/Peds Endo/Petter Bjornstad/Renal Imaging"
}
knitr::opts_knit$set(root.dir = home_dir)
```

```{r}
# Import
api = read.table("api.txt")
rcon <- redcapConnection(url="https://redcap.ucdenver.edu/api/", token=api[1,1])
df = exportRecords(rcon,labels = F)
# Combine variables
df$r_rbf_avg = rowSums(df[,c('r_rbf_avg_sr','r_rbf_avg_sup_sr',
                             'r_rbf_avg_inf_sr','r_rbf_avg_3b_sr')],na.rm = T)
df$r_rbf_avg[df$r_rbf_avg == 0] = NA
df$r_rbf_avg_vein = 
  rowSums(df[,c('r_rbf_avg_vein_sr','r_rbf_avg_vein_sup_sr','r_rbf_avg_vein_inf_sr')],na.rm = T)
df$r_rbf_avg_vein[df$r_rbf_avg_vein == 0] = NA
df$l_rbf_avg = 
  rowSums(df[,c('l_rbf_avg_sr','l_rbf_avg_sup_sr','l_rbf_avg_inf_sr','l_rbf_avg_3b_sr')],na.rm = T)
df$l_rbf_avg[df$l_rbf_avg == 0] = NA
df$l_rbf_avg_vein = 
  rowSums(df[,c('l_rbf_avg_vein_sr','l_rbf_avg_vein_sup_sr','l_rbf_avg_vein_inf_sr')],na.rm = T)
df$l_rbf_avg_vein[df$l_rbf_avg_vein == 0] = NA
# This is an indicator of stiffness of the various branches. Sums don’t make sense because if we get the artery at the takeoff, then we won’t have other measurements. Petter and I are unsure of the best approach, but we think perhaps an ‘if’, ‘then’, i.e.:
# 
# 1.	If we have the 1st branch, i.e. r_rbf_peak, then use that peak
# 
# 2.	If we have the 2nd, 3rd branches, then do an average of them?
df$r_rbf_peak = ifelse(!is.na(df$r_rbf_peak_sr),df$r_rbf_peak_sr,
                       rowMeans(df[,c('r_rbf_peak_sup_sr','r_rbf_peak_inf_sr','r_rbf_peak_3b_sr')],
                                na.rm = T))

df$r_rbf_peak_vein = ifelse(!is.na(df$r_rbf_peak_vein_sr),df$r_rbf_peak_vein_sr,
                            rowMeans(df[,c('r_rbf_peak_vein_sup_sr','r_rbf_peak_vein_inf_sr')],
                                     na.rm = T))

df$l_rbf_peak = ifelse(!is.na(df$l_rbf_peak_sr),df$l_rbf_peak_sr,
                       rowMeans(df[,c('l_rbf_peak_sup_sr','l_rbf_peak_inf_sr','l_rbf_peak_3b_sr')],
                                na.rm = T))

df$l_rbf_peak_vein = ifelse(!is.na(df$l_rbf_peak_vein_sr),df$l_rbf_peak_vein_sr,
                            rowMeans(df[,c('l_rbf_peak_vein_sup_sr','l_rbf_peak_vein_inf_sr')],
                                     na.rm = T))
# Same again for rbv peak
df$r_rbv_peak = ifelse(!is.na(df$r_rbv_peak_sr),df$r_rbv_peak_sr,
                       rowMeans(df[,c('r_rbv_peak_sup_sr','r_rbv_peak_inf_sr','r_rbv_peak_3b_sr')],
                                na.rm = T))

df$r_rbv_peak_vein = ifelse(!is.na(df$r_rbv_peak_vein_sr),df$r_rbv_peak_vein_sr,
                            rowMeans(df[,c('r_rbv_peak_vein_sup_sr','r_rbv_peak_vein_inf_sr')],
                                     na.rm = T))

df$l_rbv_peak = ifelse(!is.na(df$l_rbv_peak_sr),df$l_rbv_peak_sr,
                       rowMeans(df[,c('l_rbv_peak_sup_sr','l_rbv_peak_inf_sr','l_rbv_peak_3b_sr')],
                                na.rm = T))

df$l_rbv_peak_vein = ifelse(!is.na(df$l_rbv_peak_vein_sr),df$l_rbv_peak_vein_sr,
                            rowMeans(df[,c('l_rbv_peak_vein_sup_sr','l_rbv_peak_vein_inf_sr')],
                                     na.rm = T))
df$avg_vol = df[,'a2_avg_flow_sr'] - df[,'a1_avg_vol_sr']
# Average and sum calculated variables
df$rbf_avg = rowSums(df[,c('r_rbf_avg','l_rbf_avg')],na.rm = T)
df$rbf_avg[df$rbf_avg == 0] = NA
df$rbf_avg_vein = rowSums(df[,c('r_rbf_avg_vein','l_rbf_avg_vein')],na.rm = T)
df$rbf_avg_vein[df$rbf_avg_vein == 0] = NA
df$rbf_peak = rowMeans(df[,c('r_rbf_peak','l_rbf_peak')],na.rm = T)
df$rbf_peak_vein = rowMeans(df[,c('r_rbf_peak_vein','l_rbf_peak_vein')],na.rm = T)
df$rbv_peak = rowMeans(df[,c('r_rbv_peak','l_rbv_peak')],na.rm = T)
df$rbv_peak_vein = rowMeans(df[,c('r_rbv_peak_vein','l_rbv_peak_vein')],na.rm = )
# Outcomes
# Schwartz
df$eGFR_schwartz = round(0.413*(df$ht/df$screat),2)
# Pottel
df$sex = as.character(df$sex)
pottel = read.csv("./Data_Clean/pottel_table_1.csv")
df$qcr = apply(df,1,function(r){
  age = round(as.numeric(r['age']))
  if (is.na(age)){
    qcr = NA
  } else {
    if (age > 20){age = 20}
    if (age < 15){
      qcr = pottel$Qb_mg_dL[which(age == pottel$Age_years)]
    } else {
      sex = as.character(r['sex'])
      qcr = pottel[which(pottel$Age_years == age & pottel$Sex == sex),'Qb_mg_dL']
    }
    return(qcr)
  }
})
df$eGFR_cr = 107.3 / (df$screat/df$qcr)
```

# Missing data

```{r warning=FALSE}
# Outcome and predictor lists
outcomes = c('igfr','igfr_ab','eGFR_schwartz','eGFR_cr')
pred = c('hr_mri_la_sr','a2_peak_flow_sr','rbf_avg','rbf_avg_vein','rbf_peak',
         'rbf_peak_vein','rbv_peak','rbv_peak_vein')
# Missingness
vis_miss(df[,c(outcomes,pred)])
gg_miss_upset(df[,c(outcomes,pred)])
```

# Outcomes and Predictor Pairs

Plots on the diagonal represent the distribution of the variable.

```{r fig.height=12,fig.width=12,warning=FALSE}
ggpairs(df[,c(outcomes,pred)]) + 
  theme_bw() +
  theme(axis.line=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank()) 
```

# ElasticNet

The ElasticNet is similar to the Lasso approach for model selection, but performs better when predictors are highly correlated. To select a model, we used leave one out (LOO) cross validation (CV) to find the tuning parameter $\lambda$ that results in the lowest model error. Because $\lambda$ essentially controls how many variables are selected, common practice is to use the model with the lowest CV error ($\lambda_{min}$), or a model with CV error within one standard error of the absolute minimum ($\lambda_{1se}$). In general, the $\lambda_{min}$ model will include more predictors but therefore risks overfitting, while a $\lambda_{1se}$ model is a more parsimonious model that still has an acceptable error level.

```{r}
easly_elnet = function(outcome,predictors,data){
  # LOO CV
  cv = trainControl(method = "LOOCV")
  # Model formula
  f = as.formula(paste0(outcome,"~",paste0(predictors,collapse = "+")))
  # Matrices
  m = lm(f,data)$model
  X = data.matrix(m[,predictors])
  Y = m[,outcome]
  # Train
  elnet = train(x = X,y = Y,method = "glmnet",metric = "RMSE",
                trControl = cv,na.action = "na.omit")
  # Best results
  se = sd(elnet$results$RMSE)/sqrt(length(elnet$results$RMSE))
  min = min(elnet$results$RMSE)
  good = which(elnet$results$RMSE <= min+se)
  params = elnet$results[good,]
  if(nrow(params)>1){
    mods = apply(params,1,function(p){
      a = as.numeric(p['alpha'])
      l = as.numeric(p['lambda'])
      mod = glmnet(x = X,y = Y,alpha = a,lambda = l)
      m = coef(mod)
      m = as.matrix(m)
      m = rownames(m)[m != 0]
      return(m)
    })
    invisible(lapply(mods, function(m){
      print(kable(m,col.names = "Selected"))
    }))
  } else {
    mod = glmnet(x = X,y = Y,alpha = elnet$bestTune$alpha,lambda = elnet$bestTune$lambda)
    m = coef(mod)
    m = as.matrix(m)
    m = rownames(m)[m != 0]
    print(kable(m,col.names = "Selected"))
  }
}
```

## igfr

```{r results='asis'}
easly_elnet(outcome = "igfr",predictors = pred,data = df)
```

## igfr_ab

```{r results='asis'}
easly_elnet(outcome = "igfr_ab",predictors = pred,data = df)
```

## eGFR (Schwartz)

```{r results='asis'}
easly_elnet(outcome = "eGFR_schwartz",predictors = pred,data = df)
```

## eGFR (Pottel)

```{r results='asis'}
easly_elnet(outcome = "eGFR_cr",predictors = pred,data = df)
```


```{r}
# Write data for checking
write.csv(df[,c(outcomes,pred,colnames(df)[grep("_sr",colnames(df))])],
          "renal_imaging_data.csv",row.names = F)
getwd()
```